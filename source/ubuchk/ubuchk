#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/ubuchk
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/ubuchk/ubuchk
# Started On        - Mon  3 Feb 18:22:57 GMT 2020
# Last Change       - Wed 19 Jan 17:51:38 GMT 2022
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# An ever-growing Perl rewrite and vast overhaul of `ubuntu-syschk`.
#
# Features:
#
#TODO: Add an exception to #3579 for directory being in user's HOME.
#TODO: Check for Firefox parameters, whether to optimize or make more secure.
#
#      https://forums.linuxmint.com/viewtopic.php?p=1962270#p1962270
#      https://forums.linuxmint.com/viewtopic.php?p=1962675#p1962675
#
#TODO: Search for files without a user and/or group assigned to them.
#
#      For example, in Shell: find / -xdev \( -nouser -o -nogroup \)
#
#TODO: Check for module `pam_namespace` for user's own `/tmp` and `/var/tmp`.
#TODO: Add file permissions and ownership section (not just directories).
#TODO: Add SSH permission and ownership checks for contents of ~/.ssh.
#TODO: Add `AllowUsers` check to `SSHServer` key.
#TODO: Add `kernel.exec-shield` parameter; recommend value of `1`.
#TODO: Add a voltage check for the CMOS battery.
#TODO: Add check for CPU governor when using a laptop and regular PC.
#TODO: Add check for X amount of space taken up in Trash.
#TODO: Add check for fan speeds; alert when low/off.
#TODO: Add check for listening TCP/UDP ports, via netstat(8) or ss(8).
#TODO: Add check for using something other than `UUID=` in `fstab`.
#TODO: Add checks for unsecure network-related packages. (RSH, for example)
#TODO: Add keys for block size 1000 and 1024, and for SI toggling.
#TODO: Add netstat(8) and ss(8) port and/or address security checks.
#TODO: Alert of all SUID (+4000) and SGID (+2000) files in PATH.
#TODO: Check (almost) entire system for non-group & non-user files.
#TODO: Check `/etc/inetd.conf` for malicious lines. (IE: Ramen Worm; '^asp')
#TODO: Check `/proc/kallsyms` file for malicious lines. ('(adore|sebek)')
#TODO: Check chklastlog(1) & chkwtmp(1) executables.
#TODO: Check for APT options without the use of `apt-config` executable.
#TODO: Check for Flash & Java (OpenJDK & Oracle Java) to suggest removal.
#TODO: Check for SSH scanners, via `/{var/tmp,tmp}/{vuln.txt,ssh-scan,pscan2}`.
#TODO: Check for UFW service without the use of `systemctl` executable.
#TODO: Check for Wine packages and (separately) Mono packages; suggest removal.
#TODO: Check for `apparmor=1` and `security=apparmor` in GRUB command line.
#TODO: Check for `apparmor=1` and `security=apparmor` in LILO command line.
#TODO: Check for installation of fonts unrelated to the user's region/language.
#TODO: Check for periodic filesystem check. (EXT2/3/4)
#TODO: Check if the Secure Boot is enabled; suggest disabling it, if so.
#TODO: Check it's not possible to log in as the `root` user.
#TODO: Check most of the system for files writeable by anybody.
#TODO: Check the `/etc/shadow` file for empty user passwords.
#TODO: Have `postinst` shell script check for appropriate default settings.
#TODO: Parse `/etc/{logrotate.conf,logrotate.d/*}` to suggest reducing logs.
#TODO: Parse files, like `sources.list`, for abnormals, like 'Proposed' & PPAs.
#TODO: Somehow check for reduction in SystemD log file, via journalctl(1).
#TODO: Somehow handle the first digit in `stat()` mode.
#TODO: Use integer booleans instead of string booleans, except in config file.
#
# Ports for which to add a check:
#
#   114,   145,   465,   511,   600,  1008,  1524,  1978,  1999,  2881,  3049,
#  3133,  3879,  4000,  4369,  5190,  5665,  6667,  7222, 10008, 12321, 23132,
# 27374, 29364, 30999, 31336, 31337, 37998, 45454, 47017, 47889, 60001
#
# Those ports can be found via the REGEX '[0-9:]443', with `netstat -tunla` or
# `ss -tunla`), and for which are also searched in chkrootkit(1).
#
# Bugs:
#
#TODO: Key overriding using OPT is ignored if key not found in config.
#
#      Simply assigning a default set of values (default config) would fix
#      this, but it would be easier (not really, but more dynamic) to have
#      UbuChk programmatically resort to the existing default config.
#
#      This bug and its potential resolution will likely be present and
#      applicable in some similarly-written programs of mine, like TuDu.
#
#TODO: Alerts and/or `Info()` calls are repeated for duplicate keys.
#TODO: Mismatch between temperatures shown from UbuChk and sensors(1).
#TODO: Not checking for invalid keys specified with `--key|-k` option.
#TODO: Not checking for valid `Color_*` and `Char_*` keys.
#TODO: Potentially, `UnwantedPKGs` are not being detected, despite existing.
#TODO: Queries, when auto-shown, showing duplicates. (correct, but unintended)
#
#      Not sure if this is still applicable, as I've yet to notice this since.
#
# Dependencies:
#
#   libfilesys-diskspace-perl (>= 0.05-16)
#   libterm-readkey-perl (>= 2.33-1build1)
#   libtext-wrapi18n-perl (>= 0.06-7.1)
#   perl (>= 5.26.1-6)
#   perl-modules-5.26 (>= 5.26.1-6)
#------------------------------------------------------------------------------

require Filesys::DiskSpace;
require Term::ANSIColor;
require Term::ReadKey;
require Text::Wrap;
require POSIX;

use v5.26.1;
use strict;
use warnings;
use autodie;
use Term::ANSIColor 'color', 'colorvalid';

no warnings 'uninitialized';

my $CurVer = '2022-01-19';
my $Progrm = 'ubuchk';
my $ProgrmFancy = 'UbuChk';

my $Domain = 'https://github.com/terminalforlife/PerlProjects';

sub Usage {
	print(qq{Usage: $Progrm [OPTS]

		  -h, --help               - Display this help information.
		  -v, --version            - Output the version datestamp.
		  --force-reset            - Force generation of config file.
		  --force-run              - Execute as though in Ubuntu Linux.
		  --hush-ignored           - When verbose, omit 'Ignoring' messages.
		  --list-dbalerts          - List alerts found within the database.
		  --list-keys              - List available configuration keys.
		  --skip=N[,N ...]         - Skip one or more N alerts, by ID.
		  -Q, --query N            - Read about alert ID number N.
		  -V, --verbose            - Execute checks verbosely.
		  -c, --config [FILE]      - Use alternative configuration file.
		  -k, --key K=V            - Override key K with value V.
	} =~ tr/\t//dr)
}

sub Err($;$) {
	printf(STDERR "ERROR: %s\n", $_[1]);
	$_[0] > 0 and exit($_[0])
}

my (
	$ForceReset, $KernParams, $PathPerms, @SkipKP, $Query, $HelpAlertID,
	@UnwantedPKGs, $ForceRun, $PurgeChk, $HardAPT, @SkipAPT, $SSHServer,
	$SSHDConfig, $Verbose, $UFW, $SystemD, $KernMods, @CustomKMs,
	@SkipKMs, @SkipIDs, $AlertCount, $Recommend, $SSHClient, $ProcVuln,
	$DiskSpace, @ShownAlerts, $AutoQuery, $QueryIndent, $DSLimit, @DBData,
	$DirPerms, @SkipSysD, $Laptop, @Installed, @NotPurged, $BatCrit, $BatLow,
	$MountHome, @SkipMountOpts, $CPUTemp, $CoreTempCrit, $FailedLogins,
	$TempScale, $AptCache, $AptCacheMBLimit, $LightDM, $RootKits, @IgnoreFiles,
	$HomeCache, $HomeCacheMBLimit, $Thumbnails, $ThumbsMBLimit, $DpkgConf,
	@SkipDpkgOpts, $Swaps, $MBMaxSwap, $RAM, $MBMaxRAM, $CMOS, $ListKeys,
	$ListDbAlerts, $ChkPasswd, %KeyOpt, $ID0NonRoots, $AppArmor, %ColorHash,
	$ANSIColors, $Char_Margin, %Syms, $ShowTTL, $HushIgnored, $SymsFileMode,
	$CPUGovernor
);

my $SymsFile = '/proc/kallsyms';

# Let me know if I missed any.
my @ValidGovs = (
	'performance', 'schedutil', 'powersave',
	'conservative', 'userspace', 'ondemand'
);

# These distributions are deemed supported and these strings are the value to
# the 'ID' key in the '/etc/os-release' file.
my @SupportedLSBs = ('ubuntu', 'pop');

my $MainDir = "$ENV{HOME}/.config/$Progrm";
my $ConfigFile = "$MainDir/config";
my $Database = '/usr/share/ubuchk/database';
my $RKDatabase = '/usr/share/ubuchk/database-rk';
my $DefaultConfigFile = "/usr/share/$Progrm/config";

# Used with human-readable sizes.
my $HumanDivisor = 1024;

my $GID = (split(' ', $())[0];

mkdir($MainDir) unless -d $MainDir;

while (defined($ARGV[0])) {
	if ($ARGV[0] =~ /^(--help|-h|-\?)$/) {
		Usage(); exit(0)
	} elsif ($ARGV[0] =~ /^(--version|-v)$/) {
		print("$CurVer\n"); exit(0)
	} elsif ($ARGV[0] =~ /^(--config|-c)$/) {
		shift();

		length($ARGV[0]) or Err(1, "OPT '$1' requires a file.");

		# Not checking for a valid file, because UbuChk can generate its own.
		my $DirName = ($ARGV[0] =~ m{(.*[^/])?(?:/.*)})[0];
		-d $DirName or Err(1, "Directory '$DirName' not found.");

		$ConfigFile = $ARGV[0]
	} elsif ($ARGV[0] =~ /^(--force-reset|-F)$/) {
		$ForceReset = 'true'
	} elsif ($ARGV[0] eq '--force-run') {
		$ForceRun = 'true'
	} elsif ($ARGV[0] eq '--hush-ignored') {
		$HushIgnored = 'true'
	} elsif ($ARGV[0] =~ /^(--query|-Q)$/) {
		shift();

		length($ARGV[0]) or Err(1, "OPT '$1' requires an alert ID.");
		$ARGV[0] =~ '^[[:digit:]]{4}$' or Err(1, 'Invalid alert ID.');

		$Query = 'true';
		$HelpAlertID = $ARGV[0]
	} elsif ($ARGV[0] =~ /^(--skip=)(.*)$/) {
		@SkipIDs = split(',', $2);

		scalar(@SkipIDs) or Err(1, "OPT '$1' requires at least one ID.");

		my $Failed = 0;
		foreach my $ID (@SkipIDs) {
			unless (/^[[:digit:]]{4}$/) {
				Err(0, "Alert ID '$ID' invalid.");
				$Failed++
			}
		}

		exit(1) if $Failed
	} elsif ($ARGV[0] =~ /^(--verbose|-V)$/) {
		$Verbose = 'true'
	} elsif ($ARGV[0] eq '--list-keys') {
		$ListKeys = 'true'
	} elsif ($ARGV[0] eq '--list-dbalert s') {
		$ListDbAlerts = 'true'
	} elsif ($ARGV[0] =~ /^(--key|-k)$/) {
		shift();

		length($ARGV[1]) or Err(1, "OPT '$1' requires a key.");

		my ($Key, $Value) = split('=', $ARGV[0]);
		$KeyOpt{$Key} = $Value
	} elsif ($ARGV[0] =~ substr($ARGV[0], 0, 1)) {
		Err(1, "Incorrect option(s) specified.")
	} else {
		last
	}

	shift()
}

-w $MainDir or Err(1, "Directory '$MainDir' unwritable.");
-x $MainDir or Err(1, "Directory '$MainDir' unexectuable.");

sub DepChk {
	my @Files;
	foreach my $Dir (split(':', $ENV{'PATH'})) {
		-d -r -x $Dir or next;

		foreach my $File (glob("$Dir/*")) {
			-f -r -x $File or next;

			my $Base = ($File =~ m{(?:.*/)([^/.*])})[0];
			push(@Files, $Base)
		}
	}

	foreach my $CurDep (@_) {
		grep({$_ eq $CurDep} @Files) or return(0)
	}

	return(1)
}

# Taken directly from the TFL module. (2020-02-29)
sub GetDirSize($) {
	my $Dir = $_[0];
	my (@Dirs, $Size);
	foreach (glob("$Dir/{*,.*}")) {
		next if m{/(\.\.|\.)$};
		next if -l; # <-- Avoid infinite loop.

		push(@Dirs, $_) if -d -r -x;

		$Size += -s if -f
	}

	foreach (@Dirs) {
		foreach (glob("$_/{*,.*}")) {
			next if m{/(\.\.|\.)$};
			next if -l; # <-- Avoid infinite loop.

			push(@Dirs, $_) if -d -x;

			$Size += -s if -f
		}
	}

	return($Size)
}

#---------------------------------------------------------------OS & LSB Checks

unless ($ForceRun eq 'true') {
	if ($^O ne 'linux') {
		# Second & final chance to determine the OS type.
		my $VerFile = '/proc/version';
		if (-f -r $VerFile) {
			if (open(my $FH, '<', $VerFile)) {
				my $OS = substr(<$FH>, 0, 5);
				close($FH);

				$OS eq 'Linux' or Err(1, 'Unsupported OS.')
			} else {
				die("$!")
			}
		} else {
			Err(1, 'Unrecognised OS.')
		}
	}

	my $OSRelFile = '/etc/os-release';
	if (-f -r $OSRelFile) {
		if (open(my $FH, '<', $OSRelFile)) {
			my $Found = 0;
			while (my $Line = <$FH>) {
				chomp(my ($Key, $Value) = split('=', $Line));

				$Key eq 'ID' and grep({$_ eq 'ubuntu'} @SupportedLSBs)
					and $Found = 1
			}

			close($FH);

			$Found or Err(1, 'Unsupported LSB.')
		} else {
			die("$!")
		}
	} else {
		Err(1, 'Unrecognised LSB.')
	}
}

# Needs to be here, for the FileChk() function.
my $VulnDir = '/sys/devices/system/cpu/vulnerabilities';

#-----------------------------------------------------Miscellaneous Subroutines

# Usage: Human(<BYTES>)
sub Human($) {
	my $Size = $_[0];
	foreach ('', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y') {
		if ($Size < $HumanDivisor) {
			my $Result = sprintf("%.1f", $Size);
			my $Len = length($Result);
			my $LastTwo = substr($Result, $Len - 2);
			if ($LastTwo eq '.0') {
				return(substr($Result, 0, $Len - 2) . $_)
			} else {
				return($Result . $_)
			}
		}

		$Size = $Size / $HumanDivisor
	}
}

# Usage: Info(<STRING>)
sub Info($) {
	print("$_[0]\n") if $Verbose eq 'true'
}

# Usage: FileChk(<FILE>)
sub FileChk($) {
	my $Errs = 0;
	unless (-r $_[0]) {
		Err(0, "File '$_[0]' unreadable."); $Errs++
	} elsif (-B -s $_[0]) {
		Err(0, "File '$_[0]' is binary."); $Errs++
	}

	exit(1) if $Errs;
}

# Moving this here fixes bug when `AutoQuery` is on and a kernel parameter
# alert is shown. Not sure why; something about changing a read-only variable.
# This is usually not ideal, but at least when there are many alerts, the file
# won't constantly be opened and processed.
if (-f $Database) {
	FileChk($Database);

	if (open(my $FH, '<', $Database)) {
		@DBData = <$FH>;
		close($FH);
	} else {
		warn("$!")
	}
} else {
	# Only error out here if queries are NOT completely disabled.
	unless ($AutoQuery ne 'true' and $Query ne 'true') {
		Err(1, "File '$Database' not found.")
	}
}

# Usage: QueryAlert(<>, <ALERT_ID>)
sub QueryAlert($;$) {
	use Term::ReadKey 'GetTerminalSize';
	use Text::Wrap 'wrap';

	$HelpAlertID = $_[1] unless length($HelpAlertID);

	my @Body;
	my $Found = 0;
	foreach (@DBData) {
		chomp();

		if (/^:[[:digit:],]+$/) {
			last if $Found;

			my @CurIDs = split(',', substr($_, 1));
			foreach (@CurIDs) {
				next unless $_ == $HelpAlertID;

				$Found = 1;
				last
			}
		} elsif ($Found) {
			push(@Body, $_)
		}
	}

	$Found or Err(1, "Alert '$HelpAlertID' not found.");

	$Text::Wrap::columns = (GetTerminalSize())[0] - 2;

	print("Alert #$HelpAlertID:\n") unless length($_[1]);

	print("\n");
	foreach (@Body) {
		# Ensures paragraphing works properly. The database must have a
		# single period (`.`) on an otherwise empty line, for this to work.
		print(
			' ' x $QueryIndent .
			$ColorHash{'Color_QueryMargin'} . "$Syms{'Char_Margin'} " . color('reset') . "\n"
		) and next if $_ eq '.';

		print(
			wrap(
				' ' x $QueryIndent .
				$ColorHash{'Color_QueryMargin'} . "$Syms{'Char_Margin'} " . color('reset') .
				$ColorHash{'Color_QueryText'}, ' ' x $QueryIndent .
				$ColorHash{'Color_QueryMargin'} . "$Syms{'Char_Margin'} " . color('reset') .
				$ColorHash{'Color_QueryText'},
				$ColorHash{'Color_QueryText'} . "$_" . color('reset') . "\n"
			)
		);
	}

	exit($_[0]) unless $_[1];

	# Prevents a query from being persistent with `AutoQuery`.
	$HelpAlertID = ''
}

# Usage: Alert(<ALERT_ID>, <ALERT_STRING>, <RECOMMEND_STRING>)
sub Alert($;$;$) {
	unless (grep({$_ eq $_[0]} @SkipIDs)) {
		$AlertCount++;

		printf(
			$ColorHash{'Color_AlertBracket'} . "[" . color('reset') .
			$ColorHash{'Color_AlertID'} . "A%0.4d" . color('reset').
			$ColorHash{'Color_AlertBracket'} . "]" . color('reset') .
			$ColorHash{'Color_AlertText'} . " %s\n" . color('reset'),
			$_[0], $_[1]
		);

		printf(
			$ColorHash{'Color_AlertRecommend'} . ' ' x 8 .
			"%s\n" . color('reset'), $_[2] . color('reset')
		) if $Recommend eq 'true';

		if ($AutoQuery eq 'true') {
			# Don't want to keep showing the same query.
			unless (grep({$_ eq $_[0]} @ShownAlerts)) {
				QueryAlert(0, $_[0]);
				push(@ShownAlerts, $_[0]);
				print("\n")
			}
		}
	} else {
		Info("Skipping alert #$_[0], as requested.")
	}
}

# Usage: ParseDpkgStatus(<STATUS_STRING>)
sub ParseDpkgStatus($) {
	my $DpkgStatus = '/var/lib/dpkg/status';

	unless (-f $DpkgStatus) {
		Err(0, "File '$DpkgStatus' not found.")
	} else {
		FileChk($DpkgStatus);
		open(my $FH, '<', $DpkgStatus) or die("$!");

		my ($Package, $Arch, $Status, @Packages);
		while (<$FH>) {
			chomp();
			next unless length($_);

			my ($Key, $Value) = split(':');

			if ($Key eq 'Package') {
				$Package = $Value =~ tr/ //dr;
			} elsif ($Key eq 'Status') {
				$Status = $Value =~ tr/ //dr;
			} elsif ($Key eq 'Architecture') {
				$Arch = $Value =~ tr/ //dr;

				next unless $Status eq $_[0];

				push(@Packages, "$Package:$Arch")
			}
		}

		close($FH);

		Info("Finished with '$DpkgStatus' file.");

		return(sort(@Packages))
	}
}

#-----------------------List Keys and Gather Total Number of Alerts in Database

if ($ListKeys eq 'true') {
	my @Keys;
	while (<DATA>) {
		next if /^(#|$)/;
		my @Line = split('=');
		push(@Keys, $Line[0])
	}

	my $Old;
	foreach (sort(@Keys)) {
		print("$_\n") unless $Old eq $_;
		$Old = $_
	}

	exit(0)
} elsif ($ListDbAlerts eq 'true') {
	open(my $FH, '<', $Database) or die("$!");

	while (<$FH>) {
		chomp();
		next unless substr($_, 0, 1) eq ':';
		print("$_\n") foreach split(' ', tr/:,/ /r)
	}

	close($FH);

	exit(0)
}

#-------------------------------------Configuration File Parsing and Generation

# Look for old file no longer used as of UbuChk 2021-01-01 version. Ideally, -
# this would be taken care of by the installer, but just in-case, check. Might
# avoid any confusion by the user, plus it's just cleaner.
if ($Verbose eq 'true' and -f $DefaultConfigFile) {
	print("NOTE: Found '$DefaultConfigFile' -- see: man $Progrm\n");
}

unlink($ConfigFile) if $ForceReset eq 'true' and -f $ConfigFile;

sub Boolean {
	$_[0] =~ '^(true|false)$' or Err(1, "Invalid boolean '$_[0]' detected.")
}

if (-f -r -T $ConfigFile) {
	my $InvalidKeyCount;

	open(my $FH, '<', $ConfigFile) or die("$!");

	while (<$FH>) {
		chomp(my ($Key, $Value) = split('='));
		next if /^(#|$)/;

		# If the current key was provided to the `--key|-k` option, then
		# override the user's configuration file for this key.
		$Value = $KeyOpt{$Key} if grep({$_ eq $Key} keys(%KeyOpt));

		if ($Key =~ '^Color_.*') {
			colorvalid($Value) or Err(1, "Invalid color '$Value' detected.");

			next if $ANSIColors eq 'false';

			$ColorHash{$Key} = color($Value =~ tr/'"//dr)
		} elsif ($Key eq 'ANSIColors') {
			Boolean($Value);
			$ANSIColors = $Value
		} elsif ($Key =~ '^Char_.*') {
			if (length($Value) > 1) {
				Err(1, "Invalid 'Char_*' value detected.")
			} elsif (length($Value) == 0) {
				next
			} else {
				$Syms{$Key} = $Value =~ tr/'"//dr
			}
		} elsif ($Key eq 'KernParams') {
			Boolean($Value);
			$KernParams = $Value
		} elsif ($Key eq 'PathPerms') {
			Boolean($Value);
			$PathPerms = $Value
		} elsif ($Key eq 'SkipKP') {
			push(@SkipKP, $Value)
		} elsif ($Key eq 'SkipAPT') {
			push(@SkipAPT, $Value)
		} elsif ($Key eq 'PurgeChk') {
			Boolean($Value);
			$PurgeChk = $Value
		} elsif ($Key eq 'HardAPT') {
			$Value =~ '^([01]|true|false)$'
				or Err(1, "Invalid boolean '$Value' detected.");

			$HardAPT = $Value
		} elsif ($Key eq 'SSHDConfig') {
			$SSHDConfig = $Value
		} elsif ($Key eq 'SSHServer') {
			Boolean($Value);
			$SSHServer = $Value
		} elsif ($Key eq 'SSHClient') {
			Boolean($Value);
			$SSHClient = $Value
		} elsif ($Key eq 'UnwantedPKGs') {
			push(@UnwantedPKGs, $Value)
		} elsif ($Key eq 'Verbose') {
			Boolean($Value);
			$Verbose = $Value unless $Verbose eq 'true'
		} elsif ($Key eq 'UFW') {
			Boolean($Value);
			$UFW = $Value
		} elsif ($Key eq 'SystemD') {
			Boolean($Value);
			$SystemD = $Value
		} elsif ($Key eq 'KernMods') {
			Boolean($Value);
			$KernMods = $Value
		} elsif ($Key eq 'CustomKMs') {
			push(@CustomKMs, $Value)
		} elsif ($Key eq 'SkipKMs') {
			push(@SkipKMs, $Value)
		} elsif ($Key eq 'SkipIDs') {
			push(@SkipIDs, split(',', $Value))
		} elsif ($Key eq 'Recommend') {
			Boolean($Value);
			$Recommend = $Value
		} elsif ($Key eq 'DiskSpace') {
			Boolean($Value);
			$DiskSpace = $Value
		} elsif ($Key eq 'AutoQuery') {
			Boolean($Value);
			$AutoQuery = $Value
		} elsif ($Key eq 'QueryIndent') {
			if ($Value =~ /^[[:digit:]]+$/) {
				# Default value and its bounds are mentioned in the config.
				$Value > 0 and $Value <= 9 or Err(1, "Key '$Key' out of bounds.");

				$QueryIndent = $Value
			} else {
				Err(1, "Key '$Key' requires an integer.");
			}
		} elsif ($Key eq 'DSLimit') {
			if ($Value =~ /^[[:digit:]]+$/) {
				# Default value and its bounds are mentioned in the config.
				unless ($Value >= 10 and $Value <= 100) {
					Err(1, "Key '$Key' out of bounds.")
				}

				$DSLimit = $Value
			} else {
				Err(1, "Key '$Key' requires an integer.");
			}
		} elsif ($Key eq 'DirPerms') {
			Boolean($Value);
			$DirPerms = $Value
		} elsif ($Key eq 'SkipSysD') {
			push(@SkipSysD, $Value)
		} elsif ($Key eq 'Laptop') {
			Boolean($Value);
			$Laptop = $Value
		} elsif ($Key eq 'BatCrit') {
			if ($Value =~ /^[[:digit:]]+$/) {
				unless ($Value > 0 and $Value <= 99) {
					Err(1, "Key '$Key' out of bounds.")
				}

				$BatCrit = $Value
			} else {
				Err(1, "Key '$Key' requires an integer.");
			}
		} elsif ($Key eq 'BatLow') {
			if ($Value =~ /^[[:digit:]]+$/) {
				unless ($Value > 0 and $Value <= 99) {
					Err(1, "Key '$Key' out of bounds.")
				}

				$BatLow = $Value
			} else {
				Err(1, "Key '$Key' requires an integer.");
			}
		} elsif ($Key eq 'ProcVuln') {
			Boolean($Value);
			$ProcVuln = $Value
		} elsif ($Key eq 'MountHome') {
			Boolean($Value);
			$MountHome = $Value
		} elsif ($Key eq 'SkipMountOpts') {
			push(@SkipMountOpts, split(',', $Value))
		} elsif ($Key eq 'CPUTemp') {
			Boolean($Value);
			$CPUTemp = $Value
		} elsif ($Key eq 'CoreTempCrit') {
			if ($Value =~ /^[[:digit:]]+$/) {
				$CoreTempCrit = $Value
			} else {
				Err(1, "Key '$Key' requires an integer.");
			}
		} elsif ($Key eq 'TempScale') {
			if ($Value =~ /^[C|F]$/) {
				$TempScale = $Value
			} else {
				Err(1, "Key '$Key' must be either 'F' or 'C'.");
			}
		} elsif ($Key eq 'AptCache') {
			Boolean($Value);
			$AptCache = $Value
		} elsif ($Key eq 'AptCacheMBLimit') {
			if ($Value =~ /^[[:digit:]]+$/) {
				$AptCacheMBLimit = $Value
			} else {
				Err(1, "Key '$Key' requires an integer in MB.");
			}
		} elsif ($Key eq 'LightDM') {
			Boolean($Value);
			$LightDM = $Value
		} elsif ($Key eq 'RootKits') {
			Boolean($Value);
			$RootKits = $Value
		} elsif ($Key eq 'IgnoreFile') {
			push(@IgnoreFiles, $Value)
		} elsif ($Key eq 'HomeCache') {
			Boolean($Value);
			$HomeCache = $Value
		} elsif ($Key eq 'HomeCacheMBLimit') {
			if ($Value =~ /^[[:digit:]]+$/) {
				$HomeCacheMBLimit = $Value
			} else {
				Err(1, "Key '$Key' requires an integer.");
			}
		} elsif ($Key eq 'Thumbnails') {
			Boolean($Value);
			$Thumbnails = $Value
		} elsif ($Key eq 'ThumbsMBLimit') {
			if ($Value =~ /^[[:digit:]]+$/) {
				$ThumbsMBLimit = $Value
			} else {
				Err(1, "Key '$Key' requires an integer.");
			}
		} elsif ($Key eq 'DpkgConf') {
			Boolean($Value);
			$DpkgConf = $Value
		} elsif ($Key eq 'DpkgConf') {
			Boolean($Value);
			$DpkgConf = $Value
		} elsif ($Key eq 'SkipDpkgOpts') {
			push(@SkipDpkgOpts, $Value)
		} elsif ($Key eq 'Swaps') {
			Boolean($Value);
			$Swaps = $Value
		} elsif ($Key eq 'MBMaxSwap') {
			if ($Value =~ /^[[:digit:]]+$/) {
				$MBMaxSwap = $Value
			} else {
				Err(1, "Key '$Key' requires an integer.");
			}
		} elsif ($Key eq 'RAM') {
			Boolean($Value);
			$RAM = $Value
		} elsif ($Key eq 'MBMaxRAM') {
			if ($Value =~ /^[[:digit:]]+$/) {
				$MBMaxRAM = $Value
			} else {
				Err(1, "Key '$Key' requires an integer.");
			}
		} elsif ($Key eq 'CMOS') {
			Boolean($Value);
			$CMOS = $Value
		} elsif ($Key eq 'ChkPasswd') {
			Boolean($Value);
			$ChkPasswd = $Value
		} elsif ($Key eq 'ID0NonRoots') {
			Boolean($Value);
			$ID0NonRoots = $Value
		} elsif ($Key eq 'AppArmor') {
			Boolean($Value);
			$AppArmor = $Value
		} elsif ($Key eq 'FailedLogins') {
			Boolean($Value);
			$FailedLogins = $Value
		} elsif ($Key eq 'ShowTTL') {
			Boolean($Value);
			$ShowTTL = $Value
		} elsif ($Key eq 'SymsFileMode') {
			Boolean($Value);
			$SymsFileMode = $Value
		} elsif ($Key eq 'CPUGovernor') {
			if (length($CPUGovernor) > 0 and not grep($Value, @ValidGovs)) {
				Err(1, "CPU governor '$CPUGovernor' not recognised.")
			}

			$CPUGovernor = $Value
		} else {
			Err(0, "Key '$Key' unknown.");

			$InvalidKeyCount++
		}
	}

	close($FH);

	exit(1) if $InvalidKeyCount > 0;

	# Because this would otherwise make no sense.
	if ($Laptop eq 'true' and $BatCrit >= $BatLow) {
		Err(1, "Key conflict with 'BatCrit' and 'BatLow'.")
	}
} else {
	# Store contents into buffer, sans initial and now-unneeded Cito line.
	my @Buffer = <DATA>;
	my @Corrected = @Buffer[1..@Buffer];

	# Write to new user's-own config file.
	open(my $FH, '>', $ConfigFile);
	print($FH "# User configuration file for $ProgrmFancy (>= $CurVer)\n");
	print($FH "# Refer to $Progrm(8) to learn about these settings.\n\n");
	print($FH @Corrected);
	close($FH);

	print("Configuration file generated -- please reload $ProgrmFancy.\n");
	exit(0)
}

if (@SkipIDs > 0) {
	foreach (@SkipIDs) {
		/^[[:digit:]]{4}$/ or Err(1, "Invalid alert ID.")
	}
}

@Installed = sort(ParseDpkgStatus('installokinstalled'))
	if @UnwantedPKGs > 0;

@NotPurged = sort(ParseDpkgStatus('deinstallokconfig-files'))
	if $PurgeChk eq 'true';

#-------------------------------------------------------------Querying an Alert

QueryAlert(0) if $Query eq 'true';

#-------------------------------------------------------------Kernel Parameters

if ($KernParams eq 'true') {
	my ($Value, $AlertID, $GoodValue, $Path, $ShowKey);

	foreach ( # [ALERT_ID] [DESIRED_VALUE] [KEY_PATH]
		'0913:1:/proc/sys/kernel/ctrl-alt-del',
		'1090:5:/proc/sys/net/ipv4/tcp_syn_retries',
		'1211:0:/proc/sys/net/ipv4/conf/all/accept_redirects',
		'1291:0:/proc/sys/net/ipv6/conf/default/accept_source_route',
		'1443:1:/proc/sys/kernel/yama/ptrace_scope',
		'1491:10:/proc/sys/vm/swappiness',
		'1821:1:/proc/sys/net/ipv4/conf/default/rp_filter',
		'2125:2048:/proc/sys/net/ipv4/tcp_max_syn_backlog',
		'2529:0:/proc/sys/net/ipv4/conf/default/send_redirects',
		'2847:1:/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses',
		'2916:0:/proc/sys/net/ipv6/conf/all/accept_redirects',
		'5434:1:/proc/sys/net/ipv4/icmp_echo_ignore_all',
		'5668:2:/proc/sys/net/ipv4/tcp_synack_retries',
		'6279:0:/proc/sys/net/ipv4/conf/default/accept_source_route',
		'6576:0:/proc/sys/net/ipv4/conf/all/accept_source_route',
		'7512:1:/proc/sys/net/ipv4/conf/all/rp_filter',
		'7536:0:/proc/sys/kernel/sysrq',
		'8560:2:/proc/sys/kernel/kptr_restrict',
		'8852:1:/proc/sys/net/ipv4/conf/all/log_martians',
		'8963:0:/proc/sys/net/ipv6/conf/all/accept_source_route',
		'9191:0:/proc/sys/net/ipv4/conf/all/send_redirects',
		'9211:2:/proc/sys/kernel/randomize_va_space',
		'9222:1:/proc/sys/net/ipv4/tcp_syncookies',
		'9623:1:/proc/sys/kernel/dmesg_restrict',
		'9992:0:/proc/sys/net/ipv4/ip_forward',
		'9993:1:/proc/sys/kernel/unprivileged_bpf_disabled',
		'9998:1:/proc/sys/fs/protected_symlinks',
		'9999:1:/proc/sys/fs/protected_hardlinks'
	) {
		($AlertID, $GoodValue, $Path) = split(':');
		$ShowKey = $Path =~ tr/\//./r =~ s/\.proc\.sys\.//r;

		next if grep({$_ eq $ShowKey} @SkipKP);

		Info("Checking '$ShowKey' parameter.");

		if (-f $Path) {
			unless (-r $Path) {
				# Some parameters are more locked down than others.
				Err(0, "Denied access to '$ShowKey' parameter.");
				next
			} elsif (-B -s $Path) {
				Err(0, "Unable to determine '$ShowKey' parameter.");
				next
			}

			open(my $FH, '<', $Path);
			chomp($Value = <$FH>);
			close($FH)
		} else {
			Info("Parameter '$ShowKey' unavailable.");

			next
		}

		Info("Parameter '$ShowKey' is '$Value'.");

		Alert(
			$AlertID,
			"Key '$ShowKey' assigned '$Value'.",
			"Recommended value is '$GoodValue'."
		) if $Value != $GoodValue
	}
} else {
	Info("Ignoring kernel parameters.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------PATH Permissions & Ownership

if ($PathPerms eq 'true') {
	if (length($ENV{'PATH'}) > 0) {
		my @AlertPerms;
		foreach (split(':', $ENV{'PATH'})) {
			Info("Looking in '$_' directory.");

			# Ignore directories added to PATH which are in HOME. Added for
			# people who would otherwise get a LOT of unnecessary alerts.
			#
			# The downside, is that `next()` will not happen if the user's HOME
			# is not in '/home', but that's highly unlikely, especially in
			# Ubuntu.
			next() if $_ =~ m/^\/home/;

			foreach (glob("$_/*")) {
				my ($Mode, $Owner, $Group) = (stat($_))[2,4,5];
				$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

				Info("File '$_' is '$Mode' and '$Owner:$Group'.")
					if $Owner > 1 and $Owner < 1000
					or $Group > 1 and $Group < 1000
					or $Mode > 000 and $Mode < 755;

				Alert(
					7869,
					"File '$_' is mode '$Mode'.",
					"Recommended mode is '755'."
				) unless $Mode <= 755;

				# These executables should not be owned by a standard user, nor
				# should they be in such a group. <1000 is for system
				# users/groups. A stricter test (make optional?) would be to
				# flag all non-0s. There are exceptions, however, such as the
				# user having his or her own `bin` directory in their `/home`
				# directory.
				Alert(
					6005,
					"File '$_' is owned by '$Owner'.",
					"Recommended owner is '0' ('root')."
				) if $Owner >= 1000;

				Alert(
					3579,
					"File '$_' is in group '$Group'.",
					"Recommended group is '0' ('root')."
				) if $Group >= 1000
			}
		}
	} else {
		# This would have to be some seriously bizarre edge-case.
		Info("Missing prerequisites -- skipping 'PathPerms' key.")
	}
} else {
	Info("Ignoring PATH permissions & ownership.")
		unless $HushIgnored eq 'true'
}

#-----------------------------------------------------Packages Yet to Be Purged

if ($PurgeChk eq 'true') {
	Info("Looking for old package remains.");

	Alert(
		6712,
		"Package '$_' wasn't purged.",
		"Suggested action is to purge the package."
	) foreach @NotPurged;

	Info('No packages were found unpurged.') if @NotPurged == 0
} else {
	Info("Ignoring any unpurged packages.") unless $HushIgnored eq 'true'
}

#-----------------------------------------------------------APT Security Tweaks

if ($HardAPT eq 'true') {
	if (DepChk('apt-config') == 0) {
		my %Settings;
		foreach (`apt-config dump --format '%f=%v%n' 2> /dev/null`) {
			chomp();
			next if /^(#|$)/;

			my ($Key, $Value) = split('=');
			$Value = $Value =~ tr/"';//dr;

			# APT also accepts integer booleans.
			$Value = 'false' if $Value eq '0';
			$Value = 'true' if $Value eq '1';

			$Settings{$Key} = $Value
		}

		my ($Word, $Integer);
		foreach ( # [TARGET_VALUE] [KEY]
			'6135|6131|Recommended|false|APT::Get::AllowUnauthenticated',
			'6136|6132|Recommended|false|Acquire::http::AllowRedirect',
			'6137|6133|Recommended|false|APT::Install-Suggests',
			'6138|6134|Suggested|false|APT::Install-Recommends'
		) {
			my ($AlertID1, $AlertID2, $RecSug, $Target, $Key) = split('\|');

			next if grep({$_ eq $Key} @SkipAPT);

			$Word = 'enabled' if $Settings{$Key} eq 'true';
			$Word = 'disabled' if $Settings{$Key} eq 'false';
			$Integer = 0 if $Target eq 'false';
			$Integer = 1 if $Target eq 'true';

			unless (exists($Settings{$Key})) {
				Alert(
					$AlertID1,
					"APT key '$Key' is unassigned.",
					"$RecSug action is to assign it '$Target' or '$Integer'."
				)
			} elsif ($Settings{$Key} ne $Target) {
				Alert(
					$AlertID2,
					"APT key '$Key' is $Word.",
					"$RecSug value is '$Target' or '$Integer'."
				)
			} else {
				Info("Key '$Key' is $Word.");
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'HardAPT' key.")
	}
} else {
	Info("Ignoring APT configuration.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------------------SSH Client

if ($SSHClient eq 'true') {
	my $SSHDir = "$ENV{HOME}/.ssh";

	if (-d $SSHDir) {
		-r $SSHDir or Err(1, "Directory '$SSHDir' unreadable.");
		-x $SSHDir or Err(1, "Directory '$SSHDir' denies execution.");

		my ($Mode, $Owner, $Group) = (stat($SSHDir))[2,4,5];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		Alert(
			5431,
			"Directory '$SSHDir' is mode '$Mode'.",
			"Recommended mode is '700'."
		) unless $Mode == 700;

		Alert(
			5438,
			"Directory '$SSHDir' is owned by '$Owner'.",
			"Recommended UID is '$<'."
		) unless $Owner == $<;

		Alert(
			5439,
			"Directory '$SSHDir' is in group '$Group'.",
			"Recommended GID is '$GID'."
		) unless $Group == $GID;
	} else {
		Info("Missing prerequisites -- skipping 'SSHClient' key.")
	}
} else {
	Info("Ignoring SSH permissions & settings.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------------------SSH Server

if ($SSHServer eq 'true') {
	if (-f $SSHDConfig) {
		-r $SSHDConfig or Err(1, "File '$SSHDConfig' unreadable.");

		# Without the `-s` flag, zero-size files get flagged as binary.
		-B -s $SSHDConfig and Err(1, "File '$SSHDConfig' is binary.");

		FileChk($SSHDConfig);
		open(my $FH, '<', $SSHDConfig);

		my %Settings;
		while (<$FH>) {
			chomp();
			next if /(^#|^$)/;

			my ($Key, $Value) = split(' ');

			Info("Key '$Key' is '$Value'.");

			$Settings{$Key} = $Value
		}

		close($FH);

		foreach ( # [ALERT_ID_1] [ALERT_ID_2] [TARGET_VALUE] [KEY]
			'6990|6980|no|PermitRootLogin',
			'6991|6992|2|Protocol',
			'6996|6993|no|PermitEmptyPasswords',
			'6997|6994|no|PasswordAuthentication',
			'6998|6995|no|X11Forwarding'
		) {
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next if grep({$_ eq $Key} @SkipAPT);

			unless (exists($Settings{$Key})) {
				Alert(
					$AlertID1,
					"SSH daemon key '$Key' may not be assigned.",
					"Recommended action is to assign it '$Target'."
				)
			} elsif ($Settings{$Key} ne $Target) {
				Alert(
					$AlertID2,
					"SSH daemon key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}

		# Ordinarily, you shouldn't use the commonplace `22` port.
		unless (exists($Settings{'Port'})) {
			Alert(
				7541,
				"SSH daemon key 'Port' may not be assigned.",
				"Recommended action is NOT to assign it '22'."
			)
		} elsif ($Settings{'Port'} eq 22) {
			Alert(
				6542,
				"SSH daemon key 'Port' assigned '$Settings{Port}'.",
				"Recommended value is one other than '22'."
			)
		}
	} else {
		Info("Missing prerequisites -- skipping 'SSHServer' key.")
	}
} else {
	Info("Ignoring whether SSH server is present.")
		unless $HushIgnored eq 'true'
}

#---------------------------------------------------------Packages Best Avoided

if (@UnwantedPKGs > 0) {
	foreach my $CurPKG (@UnwantedPKGs) {
		Info("Looking for '$CurPKG' package.");

		Alert(
			5656,
			"Package(s) matching '$CurPKG' installed.",
			"Suggested consideration of uninstallation."
		) if grep({($_ =~ "(.*)(?::.*)")[0] eq $CurPKG} @Installed)
	}
} else {
	Info("Ignoring any unwanted packages.") unless $HushIgnored eq 'true'
}

#----------------------------------------------------------------SystemD Tweaks

if ($SystemD eq 'true') {
	my $SDConfig = '/etc/systemd/system.conf';

	if (-f $SDConfig) {
		FileChk($SDConfig);
		open(my $FH, '<', $SDConfig);

		my %Settings;
		while (<$FH>) {
			chomp();
			next if /(^#|^$|^\[Manager\]$)/;

			my ($Key, $Value) = split('=');

			Info("Key '$Key' is '$Value'.");

			$Settings{$Key} = $Value
		}

		close($FH);

		foreach ( # [TARGET_VALUE] [KEY]
			'1411|1415|1024|DefaultLimitNPROC',
			'1412|1416|1024|DefaultLimitNOFILE',
			'1413|1417|no|CrashShell',
			'1414|1418|no|DumpCore'
		) {
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next if grep({$_ eq $Key} @SkipSysD);

			unless (exists($Settings{$Key})) {
				Alert(
					$AlertID1,
					"SystemD key '$Key' may not be assigned.",
					"Recommended action is to assign it '$Target'."
				)
			} elsif ($Settings{$Key} ne $Target) {
				Alert(
					$AlertID2,
					"SystemD key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'SystemD' key.")
	}
} else {
	Info("Ignoring SystemD-related tweaks.") unless $HushIgnored eq 'true'
}

#----------------------------------------------------------------Kernel Modules

if ($KernMods eq 'true') {
	my $ProcMods = '/proc/modules';

	if (-f $ProcMods) {
		FileChk($ProcMods);
		open(my $FH, '<', $ProcMods);

		my @Modules;
		while (<$FH>) {
			chomp();

			my @Line = split(' ');

			push(@Modules, $Line[0])
		}

		close($FH);

		foreach (
			'1274|mei',
			'1275|mei_me',
			'1276|mei_wtk',
			'7416|joydev',
			'8471|psmouse'
		) {
			my ($AlertID, $Module) = split('\|');

			if (grep({$_ eq $Module} @Modules)) {
				unless (grep({$_ eq $Module} @SkipKMs)) {
					Info("Module '$Module' found but ignored.");
					next # <-- Skipping the below alert.
				}

				Alert(
					$AlertID,
					"Module '$Module' discovered and live.",
					"Recommended action is to blacklist the module."
				)
			} else {
				Info("Module '$Module' not found.")
			}
		}

		foreach my $Mod (@CustomKMs) {
			Alert(
				8189,
				"Module '$Mod' discovered and live.",
				"Recommended action is to blacklist the module."
			) if grep({$_ eq $Mod} @Modules)
		}
	} else {
		Info("Missing prerequisites -- skipping 'KernMods' key.")
	}
} else {
	Info("Ignoring kernel modules.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------Check Filesystem Sizes

if ($DiskSpace eq 'true') {
	my $MountFile = '/proc/mounts';

	if (-f $MountFile) {
		use Filesys::DiskSpace 'df';

		FileChk($MountFile);
		open(my $FH, '<', $MountFile);

		my (@MountPoints, $Base, $Used, $Free, $Size, $Mount, $Perc);
		while (<$FH>) {
			chomp(my @Arr = split(' '));

			# Using this REGEX over just '^/' avoids statfs errors.
			if ($Arr[0] =~ '^/dev/(sd|hd|fd)[[:alpha:]]+[[:digit:]]+$') {
				# Avoids `not a directory` error, for EFI setups.
				next if $Arr[1] eq '/boot/efi';

				# Avoids other `not a directory` error instances.
				next unless -d $Arr[0];

				Info("Looking at '$Arr[0]' partition.");

				$Mount = $Arr[1] =~ s/\\040/ /gr;
				($Used, $Free) = (df($Mount))[2,3] or next;
				$Used = $Used * 1024;
				$Free = $Free * 1024;
				$Size = $Free + $Used;
				$Perc = int(($Used / $Size) * 100);

				if ($Perc >= $DSLimit) {
					Alert(4612,
						"Partition '$Arr[0]' is $Perc% full.",
						"Recommended action is to clear out junk."
					)
				} else {
					Info("Partition '$Arr[0]' is using $Perc% of space.");
				}
			}
		}

		close($FH);
	} else {
		Info("Missing prerequisites -- skipping 'DiskSpace' key.")
	}
} else {
	Info("Ignoring disk space availability.") unless $HushIgnored eq 'true'
}

#----------------------Specific File & Directory Permissions, Group & Ownership

if ($DirPerms eq 'true') {
	foreach ( # [ALERTID] [MODE] [UID] [GID]
		"5440:700:$<:$GID:$ENV{HOME}",
		'5436:700:0:0:/boot',
		'5446:700:0:0:/root'
	) {
		my ($AlertID, $TargetMode, $TargetUID, $TargetGID, $Path) = split(':');

		next unless -d $Path;

		Info("Looking at '$Path' directory.");

		my ($Mode, $Owner, $Group) = (stat($Path))[2,4,5];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		Alert(
			$AlertID,
			"Directory '$Path' is mode '$Mode'.",
			"Recommended mode is '$TargetMode'."
		) unless $Mode == $TargetMode;

		Alert(
			$AlertID,
			"Directory '$Path' is owned by '$Owner'.",
			"Recommended UID is '$TargetUID'."
		) unless $Owner == $TargetUID;

		Alert(
			$AlertID,
			"Directory '$Path' is in group '$Group'.",
			"Recommended GID is '$TargetGID'."
		) unless $Group == $TargetGID;
	}
} else {
	Info("Ignoring special file permissions & ownership.")
		unless $HushIgnored eq 'true'
}

#-----------------------------------------------------------------Laptop Checks

if ($Laptop eq 'true') {
	my $BaseDir = '/sys/class/power_supply';
	my $AdapTypeFile = "$BaseDir/ADP1/type";
	my $AdapOnlineFile = "$BaseDir/ADP1/online";

	my $AdapOnline;
	if (-f $AdapTypeFile) {
		FileChk($AdapTypeFile);
		open(my $FH, '<', $AdapTypeFile);
		chomp(my $AdapType = <$FH>);
		close($FH);

		if ($AdapType eq 'Mains') {
			FileChk($AdapOnlineFile);
			open(my $FH, '<', $AdapOnlineFile);
			chomp($AdapOnline = <$FH>);
			close($FH);

			if ($AdapOnline == 0) {
				Info("Device is NOT plugged in.")
			} else {
				Info("Device is plugged in.")
			}
		}
	}

	if (-d "$BaseDir/BAT1") { # <-- Ensure at least one battery exists.
		foreach (glob("$BaseDir/BAT[1-9]")) {
			my $BatFile = "$_/capacity";
			my $KNowFile = "$_/charge_now";
			my $KMaxFile = "$_/charge_full_design";

			if (-f $BatFile) {
				FileChk($BatFile);
				open(my $FH, '<', $BatFile);
				chomp(my $BatPerc = <$FH>);
				close($FH);

				my $Battery = $BatFile =~ s/.*\/BAT([[:digit:]]+)\/capacity$/$1/r;

				my ($KNow, $KMax);
				if (-f $KNowFile and -f $KMaxFile) {
					FileChk($KNowFile);
					open(my $FH, '<', $KNowFile);
					chomp($KNow = substr(<$FH>, 0, length($KNow) - 4));
					close($FH);

					FileChk($KMaxFile);
					open($FH, '<', $KMaxFile);
					chomp($KMax = substr(<$FH>, 0, length($KMax) - 4));
					close($FH);
				}

				if ($BatPerc <= $BatCrit) {
					Alert(
						2850,
						"Battery #$Battery critical at $BatPerc% ($KNow mAh) capacity.",
						"Save your work and shut down the computer."
					) unless $AdapOnline == 1
				} elsif ($BatPerc <= $BatLow) {
					if (length($KMax) > 0 and length($KNow) > 0) {
						Alert(
							2849,
							"Battery #$Battery low at $BatPerc% ($KNow mAh) capacity.",
							"Suggested action is to charge the battery."
						) unless $AdapOnline == 1
					} else {
						Alert(
							2849,
							"Battery #$Battery low at $BatPerc% capacity.",
							"Suggested action is to charge the battery."
						) unless $AdapOnline == 1
					}
				} else {
					if (length($KMax) > 0 and length($KNow) > 0) {
						Info("Battery #$Battery still has $BatPerc% at $KNow mAh power.")
					} else {
						Info("Battery #$Battery still has $BatPerc% power left.")
					}
				}
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'Laptop' key.")
	}
} else {
	Info("Ignoring tweaks for a portable machine.")
		unless $HushIgnored eq 'true'
}

#------------------------------------------------------CPU Marked as Vulnerable

if ($ProcVuln eq 'true') {
	if (-d $VulnDir) {
		-r $VulnDir or Err(1, "Directory '$VulnDir' unreadable.");
		-x $VulnDir or Err(1, "Unable to open '$VulnDir' directory.");

		foreach (glob("$VulnDir/*")) {
			next unless -f;

			my $Vuln = ($_ =~ m{(?:.*/)(.*)})[0];

			Info("Checking CPU for vulnerability to $Vuln.");

			FileChk($_);
			open(my $FH, '<', $_);
			chomp(my $Data = <$FH>);
			close($FH);

			if ($Data =~ /Vulnerable/i) {
				Alert(
					4811,
					"CPU marked as vulnerable to $Vuln.",
					"Don't panic -- refer to: $Progrm -Q 4811"
				)
			} elsif ($Data =~ /Not affected/i) {
				Info("Unaffected by $Vuln vulnerability.")
			} elsif ($Data =~ /Mitigation/i) {
				Info("Vulnerability $Vuln mitigated.")
			} else {
				Alert(
					4812,
					"Unrecognised vulnerability status to $Vuln.",
					"Don't panic -- refer to: $Progrm -Q 4812"
				)
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'ProcVuln' key.")
	}
} else {
	Info("Ignoring any CPU vulnerabilities.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------Mount Options for HOME

if ($MountHome eq 'true') {
	my $MountFile = '/proc/mounts';

	if (-f $MountFile) {
		FileChk($MountFile);
		open(my $FH, '<', $MountFile);

		my ($Device, $Options);
		while (<$FH>) {
			chomp(my @Arr = split(' '));

			# Using this REGEX over just '^/' avoids statfs errors.
			if ($Arr[1] eq '/home') {
				($Device, $Options) = @Arr[0,3];
				last
			}
		}

		close($FH);

		if (length($Device) > 0) {
			Info("Mountpoint '/home' points to '$Device'.");

			my @OptArr = split(',', $Options);
				my ($AlertID, $Option) = split(',');

			foreach (
				'1356,noexec',
				'1357,nodev',
				'1358,nosuid'
			) {
				my ($AlertID, $Option) = split(',');

				if (grep({$_ eq $Option} @SkipMountOpts)) {
					Info("Module '$Option' found but ignored.");
					next # <-- Skipping the below alert.
				}

				if (grep({$_ eq $Option} @OptArr)) {
					Info("Mount option '$Option' for '/home' is set.")
				} else {
					Alert($AlertID,
						"Missing mount option '$Option' for '/home'.",
						"Please refer to: $Progrm -Q $AlertID"
					)
				}
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'MountHome' key.")
	}
} else {
	Info("Ignoring any HOME mount options.") unless $HushIgnored eq 'true'
}

#---------------------------------------------------------CPU Core Temperatures

# There are several ways to get the system's CPU temperature(s), without
# dragging in another program, but for now, I'll program for this particular
# method, adding additional ones as issues are reported.
if ($CPUTemp eq 'true') {
	my $Dir;
	if (-d '/sys/devices/platform/coretemp.0/hwmon/hwmon3') {
		$Dir = '/sys/devices/platform/coretemp.0/hwmon/hwmon3'
	} elsif (-d '/sys/class/hwmon/hwmon1') {
		$Dir = '/sys/class/hwmon/hwmon1'
	} else {
		Info("Missing prerequisites -- skipping 'CPUTemp' key.")
	}

	if (defined($Dir)) {
		-r $Dir or Err(1, "Directory '$Dir' unreadable.");
		-x $Dir or Err(1, "Directory '$Dir' denies execution.");

		# Gather a hash of (only) the core temperatures.
		my (%TempData, $Temp);
		foreach (glob("$Dir/temp*")) {
			next unless -f and m{/temp[[:digit:]]+_(input|label)$};

			FileChk($_);
			open(my $FH, '<', $_);
			chomp(my $Data = <$FH>);
			close($FH);

			# The files are ordered from input to label, so we need to process
			# it backwards, otherwise the output would be borked.
			if (/_input$/) {
				$Temp = $Data
			} elsif (/_label$/) {
				$TempData{$Data} = $Temp
			}
		}

		# Ensure we have the right suffix for 1'st', 2'nd', 3'rd', and N'th'.
		sub Suffix { # Usage: [INT]
			my $Num = $_[0] + 1;
			return("${Num}st") if $Num =~ '1$';
			return("${Num}nd") if $Num =~ '2$';
			return("${Num}rd") if $Num =~ '3$';
			return("${Num}th")
		}

		# Taken directly from the TFL module. (2020-02-29)
		sub CelsFahr {
			if ($_[0] eq 'F') {
				use POSIX 'ceil';

				return(ceil(($_[1] * 9/5) + 32))
			} elsif ($_[0] eq 'C') {
				return($_[1])
			}
		}

		# Begin checking on each of the core temperatures, per the above hash.
		foreach (sort(keys(%TempData))) {
			next unless /^Core [[:digit:]]+$/;

			# Initially, this value is in Celsius (unconfirmed).
			my $TempInt = CelsFahr(
				$TempScale, substr($TempData{$_}, 0, length($TempData{$_}) - 3)
			);

			my $TempStr = "$TempInt°$TempScale";
			my $CoreInt = (m{(?:.* )(.*)})[0];
			my $CoreStr = Suffix($CoreInt);
			if ($TempInt >= $CoreTempCrit) {
				Alert(
					6237,
					"CPU's $CoreStr core critical at $TempStr.",
					"Suggested action is to improve system cooling."
				)
			} else {
				Info("CPU core #$CoreInt stable at $TempStr.")
			}
		}
	}
} else {
	Info("Ignoring CPU temperatures.") unless $HushIgnored eq 'true'
}

#----------------------------------------------------------APT Cache Disk Usage

if ($AptCache eq 'true') {
	my $Dir = '/var/cache/apt/archives';

	if (-d $Dir) {
		# Ignoring `partial` directory, as it often needs root access to use.
		# The same goes for files like `lock`, as they're irrelevant here.
		my ($FileCount, $Size);
		foreach (glob("$Dir/*.deb")) {
			$Size += -s;
			$FileCount++;

			if ($Verbose eq 'true') {
				my $Human = Human($Size);
				my $BaseName = ($_ =~ m{(?:.*/)(.*)})[0];

				Info("Found '$BaseName', using $Human.");
			}
		}

		if ($Size > 0) {
			my $Human = Human($Size);
			if ($Size / 1024 / 1024 >= $AptCacheMBLimit) {
				if (DepChk('sudo') == 0) {
					Alert(
						9708,
						"Found $FileCount cached Debian packages, totalling $Human.",
						"Suggested action is to run: sudo apt-get clean"
					);
				} else {
					Alert(
						9708,
						"Found $FileCount cached Debian packages, totalling $Human.",
						"Suggested action is to, as root, run: apt-get clean"
					);
				}
			} else {
				Info("Cached Debian packages take up only $Human.");
			}
		} else {
			Info("Found no cached Debian packages.");
		}
	} else {
		Info("Missing prerequisites -- skipping 'AptCache' key.")
	}
} else {
	Info("Ignoring APT cache disk usage.") unless $HushIgnored eq 'true'
}

#-----------------------------------------------------------------------LightDM

if ($LightDM eq 'true') {
	my $Config = '/etc/lightdm/lightdm.conf.d/50-no-guest.conf';

	if (-f $Config) {
		FileChk($Config);
		open(my $FH, '<', $Config);

		my $AllowGuest;
		while (<$FH>) {
			chomp();

			# Correct, at least in Ubuntu 16.04.6 base. Ubuntu 18.04.4 seems to
			# not use this file by default, but it can still be found at:
			#
			#  /usr/share/lightdm/lightdm.conf.d/50-disable-guest.conf
			#
			if (/(^| )allow-guest=true( |$)/) {
				$AllowGuest = 'true'; last
			} elsif (/(^| )allow-guest=false( |$)/) {
				$AllowGuest = 'false'; last
			}
		}

		close($FH);

		if ($AllowGuest eq 'true') {
			Alert(
				9188,
				'Guest logins are allowed with LightDM.',
				'Recommended action is to disable guest logins.'
			);
		} elsif ($AllowGuest eq 'false') {
			Info('LightDM does not permit guest logins.')
		} else {
			Alert(
				9188,
				'Guest logins may be allowed with LightDM.',
				"Recommended action is to ensure it's disabled."
			);
		}
	} else {
		Info("Missing prerequisites -- skipping 'LightDM' key.")
	}
} else {
	Info("Ignoring any LightDM configurations.") unless $HushIgnored eq 'true'
}

#----------------------------------------------------------RootKits, Worms, etc

# This section is based on information from this GitHub repository:
#
#   https://github.com/ossec/ossec-hids
#
# Also inspired by various checks made by rkhunter(8).
if ($RootKits eq 'true') {
	-f $RKDatabase or Err(1, "File '$RKDatabase' not found.");
	-r $RKDatabase or Err(1, "File '$RKDatabase' unreadable.");

	open(my $FH, '<', $RKDatabase);
	my @DBData = <$FH>;
	close($FH);

	my ($AlertID, $Name);
	foreach my $Line (@DBData) {
		chomp($Line);

		next if $Line =~ '^#';
		if ($Line =~ '^:') {
			($AlertID, $Name) = (split(':', $Line))[1..2];
			Info("Searching: $Name");
		} elsif (length($Line) > 0) {
			next unless -e $Line =~ tr/_/ /r;

			Alert(
				$AlertID,
				"Found: $Line",
				"File associated with $Name."
			) unless grep({$_ eq $Line} @IgnoreFiles)
		}
	}
} else {
	Info("Ignoring rootkits, detected or not.") unless $HushIgnored eq 'true'
}

#------------------------------------------------------------------User's Cache

if ($HomeCache eq 'true') {
	my $CacheDir = "$ENV{HOME}/.cache";

	if (-d $CacheDir) {
		my $Size = GetDirSize($CacheDir);
		if ($Size > 0) {
			use POSIX 'ceil';

			my $SizeMB = ceil($Size / (1024 * 1024));
			my $Human = Human($Size);
			if ($SizeMB >= $HomeCacheMBLimit) {
				Alert(
					7619,
					"User '$ENV{USER}' has a cache total of $Human.",
					"Suggested action is to remove unneeded files."
				)
			} else {
				Info("User '$ENV{USER}' caches only $Human.")
			}
		} else {
			Info("User '$ENV{USER}' directory '~/.cache' is empty.")
		}
	} else {
		Info("Missing prerequisites -- skipping 'HomeCache' key.")
	}
} else {
	Info("Ignoring user's own general cache.") unless $HushIgnored eq 'true'
}

#-------------------------------------------------------------User's Thumbnails

if ($Thumbnails eq 'true') {
	my $ThumbDir = "$ENV{HOME}/.thumbnails";

	if (-d $ThumbDir) {
		my $Size = GetDirSize($ThumbDir);
		if ($Size > 0) {
			use POSIX 'ceil';

			my $SizeMB = ceil($Size / 1024 / 1024);
			my $Human = Human($Size);
			if ($SizeMB >= $ThumbsMBLimit) {
				Alert(
					7620,
					"User '$ENV{USER}' has a thumbnails total of $Human.",
					"Suggested action is to remove unneeded files."
				)
			} else {
				Info("User '$ENV{USER}' thumbnails take up only $Human.")
			}
		} else {
			Info("User '$ENV{USER}' directory '~/.thumbnails' is empty.")
		}
	} else {
		Info("Missing prerequisites -- skipping 'Thumbnails' key.")
	}
} else {
	Info("Ignoring user's own thumbnail cache.") unless $HushIgnored eq 'true'
}

#------------------------------------------------------------DPKG Configuration

if ($DpkgConf eq 'true') {
	my $DpkgConfFile = '/etc/dpkg/dpkg.cfg';

	if (-f $DpkgConfFile) {
		FileChk($DpkgConfFile);
		open(my $FH, '<', $DpkgConfFile);

		my ($FoundNoDebSig, $FoundLog);
		while (<$FH>) {
			chomp();
			next if /^(#|$)/;

			$FoundNoDebSig = 'true' if /^no-debsig($|[[:space:]]+.*)/;
			$FoundLog = 'true' if /^log /;
		}

		close($FH);

		my $ChkStatus = grep({$_ eq 'no-debsig'} @SkipDpkgOpts);
		unless ($FoundNoDebSig eq 'true' and not $ChkStatus) {
			Alert(
				3790,
				"Potentially-unsupported 'debsig' not disabled.",
				"Recommended action is to verify it's supported."
			)
		} else {
				Info("Configuration value 'no-debsig' found.");
		}

		$ChkStatus = grep({$_ eq 'log'} @SkipDpkgOpts);
		unless ($FoundLog eq 'true' and not $ChkStatus) {
			Alert(
				3791,
				"Status changes and actions not being logged by DPKG.",
				"Recommended action is to enable this feature."
			)
		} else {
				Info("Configuration value 'log' found.");
		}
	} else {
		Info("Missing prerequisites -- skipping 'DpkgConf' key.")
	}
} else {
	Info("Ignoring any DPKG configurations.") unless $HushIgnored eq 'true'
}

#-------------------------------------------------------------------------Swaps

if ($Swaps eq 'true') {
	my $SwapFile = '/proc/swaps';

	if (-f $SwapFile) {
		use POSIX 'ceil';

		FileChk($SwapFile);
		open(my $FH, '<', $SwapFile);

		my (@Swaps, $SwapCount);
		while (<$FH>) {
			chomp();

			# Skip header.
			next if $. == 1;

			my ($File, $Type, $Size, $Used, $Priority) = split(' ');
			my $HumSize = Human($Size * 1024);
			my $HumUsed = Human($Used * 1024);
			my $MRemains = ceil(($Size - $Used) / 1024);

			if ($Type eq 'file') {
				my ($Mode, $Owner, $Group) = (stat($File))[2,4,5];
				$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

				Alert(
					6232,
					"File '$File' is mode '$Mode'.",
					"Recommended mode is '600'."
				) unless $Mode == 600;

				Alert(
					6233,
					"File '$File' is owned by '$Owner'.",
					"Recommended UID is '0'."
				) unless $Owner == 0;

				Alert(
					6234,
					"File '$File' is in group '$Group'.",
					"Recommended GID is '0'."
				) unless $Group == 0;
			}

			# Just in-case the file is in the user's HOME.
			$File = $File =~ s/$ENV{HOME}/~/r;

			if ($MRemains >= $MBMaxSwap) {
				Info("Swap $Type '$File' using $HumUsed/$HumSize.");
			} else {
				my $HumRemains = Human(($Size - $Used) * 1024);

				Alert(
					8759,
					"Only $HumRemains left on '$File' $Type.",
					"Suggested action is to increase swap size."
				)
			}

			$SwapCount++
		}

		if ($SwapCount > 1) {
			Info("System has $SwapCount active swap areas.")
		} elsif ($SwapCount == 0) {
			Alert(
				8760,
				"Detected no assigned swap space on the system.",
				"Suggested action is to add a swap file or partition."
			)
		}

		close($FH)
	} else {
		Info("Missing prerequisites -- skipping 'Swaps' key.")
	}
} else {
	Info("Ignoring any Swap configurations.") unless $HushIgnored eq 'true'
}

#---------------------------------------------------------------------------RAM

if ($RAM eq 'true') {
	my $MemFile = '/proc/meminfo';

	if (-f $MemFile) {
		use POSIX 'ceil';

		FileChk($MemFile);
		open(my $FH, '<', $MemFile);

		my (
			$BShared, $BSwap, $BTotal, $BFree,
			$BCache, $HumFree, $BSRec, $BBuf
		);

		while (<$FH>) {
			chomp(my @Line = split(' '));

			if ($Line[0] eq 'MemTotal:') {
				$BTotal = $Line[1] * 1024
			} elsif ($Line[0] eq 'MemFree:') {
				$BFree = $Line[1] * 1024
			} elsif ($Line[0] eq 'Buffers:') {
				$BBuf = $Line[1] * 1024
			} elsif ($Line[0] eq 'Cached:') {
				$BCache = $Line[1] * 1024
			} elsif ($Line[0] eq 'Shmem:') {
				$BShared = $Line[1] * 1024
			} elsif ($Line[0] eq 'SwapTotal:') {
				$BSwap = $Line[1] * 1024
			} elsif ($Line[0] eq 'SReclaimable:') {
				$BSRec = $Line[1] * 1024
			}
		}

		close($FH);

		my $HumTotal = Human($BTotal);

		# Ignore shared memory, buffers, and cache, similar to htop(1).
		my $BUsed = ($BTotal - $BFree) - ($BBuf + $BCache + $BSRec);

		# As the free(1) utility shows by default.
		my $MUsed = ceil($BUsed / (1024 * 1024));
		my $HumUsed = Human($BUsed);

		if ($MUsed <= $MBMaxRAM) {
			Info("Using only $HumUsed of $HumTotal available RAM.")
		} else {
			Alert(
				8971,
				"Using $HumUsed of $HumTotal available RAM.",
				"Please refer to: $Progrm -Q 8971"
			)
		}
	} else {
		Info("Missing prerequisites -- skipping 'RAM' key.")
	}
} else {
	Info("Ignoring RAM availability.") unless $HushIgnored eq 'true'
}

#------------------------------------------------------------------CMOS Battery

if ($CMOS eq 'true') {
	my $RTCFile = '/proc/driver/rtc';

	if (-f $RTCFile) {
		open(my $FH, '<', $RTCFile);

		my $BatStatus;
		while (<$FH>) {
			chomp();
			my @Line = split(': ');
			$BatStatus = $Line[1]
		}

		close($FH);

		if ($BatStatus eq 'okay') {
			Info("CMOS battery appears to be okay.")
		} else {
			Alert(
				1118,
				"Detected a non-'okay' CMOS battery status.",
				"Recommended action is to physically check it."
			)
		}
	} else {
		Info("Missing prerequisites -- skipping 'CMOS' key.")
	}
} else {
	Info("Ignoring any CMOS battery.") unless $HushIgnored eq 'true'
}

#-------------------------------------------------------------------/etc/passwd

if ($ChkPasswd eq 'true') {
	my $PasswdFile = '/etc/passwd';

	if (-f $PasswdFile) {
		open(my $FH, '<', $PasswdFile);

		my ($WormFound, @Roots);
		while (<$FH>) {
			$WormFound = $. if /w0rm/;

			if ($ID0NonRoots eq 'true') {
				chomp(my @Line = split(':'));

				if ($Line[2] == 0 or $Line[3] == 0) {
					push(@Roots, $Line[0]) unless grep({$_ eq $Line[0]} @Roots);
				}
			}
		}

		close($FH);

		unless (length($WormFound) > 0) {
			Info("Cannot see 'w0rm' in '$PasswdFile' file.")
		} else {
			Alert(
				1428,
				"Found 'w0rm' on line #$WormFound in '$PasswdFile' file.",
				"Please refer to a search engine."
			)
		}

		if ($ID0NonRoots eq 'true') {
			unless (@Roots > 1) {
				Info("Just 'root' with '0:0' found in '$PasswdFile' file.")
			} else {
				if (@Roots > 1) {
					my ($Wording1, $Wording2);
					if (@Roots == 2) {
						$Wording1 = 'user';
						$Wording2 = 'this user is'
					} else {
						$Wording1 = 'users';
						$Wording2 = 'these users are'
					}

					Alert(
						9848,
						"Non-root $Wording1 with '0' UID/GID in '$PasswdFile' file.",
						"Recommended action is to confirm $Wording2 legitimate."
					);

					foreach (@Roots) {
						Info("User '$_' has '0' UID/GID.") unless $_ eq 'root'
					}
				}
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'ChkPasswd' key.");

		Info("Missing prerequisites -- skipping 'ID0NonRoots' key.")
			if $ID0NonRoots eq 'true'
	}
} else {
	Info("Ignoring system's passwd file.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------SystemD Units/Services

if ($UFW eq 'true') {
	if (DepChk('systemctl') == 0) {
		chomp(my $Active = `systemctl is-active ufw 2> /dev/null`);
		unless ($Active eq 'active') {
			Alert(
				5541,
				"UFW is installed but its service inactive.",
				"Recommended action is to start the UFW service."
			)
		} else {
			Info('The UFW service is active.')
		}

		chomp(my $Enabled = `systemctl is-enabled ufw 2> /dev/null`);
		unless ($Enabled eq 'enabled') {
			Alert(
				5542,
				"UFW is installed but its service disabled.",
				"Recommended action is to enable the UFW service."
			)
		} else {
			Info('The UFW service is enabled.')
		}
	} else {
		Info("Missing prerequisites -- skipping 'UFW' key.")
	}
} else {
	Info("Ignoring any installations of UFW.") unless $HushIgnored eq 'true'
}

if ($AppArmor eq 'true') {
	if (DepChk('systemctl') == 0) {
		chomp(my $Active = `systemctl is-active apparmor 2> /dev/null`);
		unless ($Active eq 'active') {
			Alert(
				1298,
				"AppArmor is installed but its service inactive.",
				"Recommended action is to start the AppArmor service."
			)
		} else {
			Info('The AppArmor service is active.')
		}

		chomp(my $Enabled = `systemctl is-enabled apparmor 2> /dev/null`);
		unless ($Enabled eq 'enabled') {
			Alert(
				1299,
				"AppArmor is installed but its service disabled.",
				"Recommended action is to enable the AppArmor service."
			)
		} else {
			Info('The AppArmor service is enabled.')
		}
	} else {
		Info("Missing prerequisites -- skipping 'AppArmor' key.")
	}
} else {
	Info("Ignoring any installations of AppArmor.")
		unless $HushIgnored eq 'true'
}

#---------------------------------------------------------Failed Login Attempts

if ($FailedLogins eq 'true') {
	my $FailFile = '/var/log/faillog';

	if (-f $FailFile) {
		unless (-s $FailFile) {
			Alert(
				2223,
				'Detected possible failed login attempts.',
				'Please execute the faillog(8) command.'
			)
		} else {
			Info('No failed login attempts detected.')
		}
	} else {
		Info("Missing prerequisites -- skipping 'FailedLogins' key.")
	}
} else {
	Info("Ignoring any failed login attempts.") unless $HushIgnored eq 'true'
}

#-----------------------------------------------Check for '/proc/kallsyms' Mode

if ($SymsFileMode eq 'true') {
	if (-f $SymsFile) {
		my $Mode = (stat($SymsFile))[2];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		if ($Mode == 400) {
			Info("Mode '400' set for '$SymsFile'.")
		} else {
			Alert(
				8128,
				"Mode for '$SymsFile' file found.",
				"Recommended mode is '400'."
			)
		}
	} else {
		Info("Missing prerequisites -- skipping 'SymsFileMode' key.")
	}
} else {
	Info("Ignoring mode of '$SymsFile' file.") unless $HushIgnored eq 'true'
}

#----------------------------------------------Check CPU Governor Is As Desired

if (length($CPUGovernor) > 0) {
	my $GovDir = '/sys/devices/system/cpu/cpufreq';

	my (%Governors, $FoundFile);
	foreach my $Dir (glob("$GovDir/*")) {
		-d $Dir or next;

		foreach my $File ("$Dir/scaling_governor") {
			$FoundFile = 'true';

			open(my $FH, '<', $File);

			chomp(my $Data = <$FH>);
			my $Core = ($Dir =~ m{.*/policy([[:digit:]]+)})[0] + 1;
			$Governors{$Core} = $Data;

			close($FH)
		}
	}

	if ($FoundFile eq 'true') {
		foreach (sort({$a > $b} keys(%Governors))) {
			Info("CPU Core #$_ using '$Governors{$_}' governor.");

			unless ($Governors{$_} eq $CPUGovernor) {
				Alert(
					2623,
					"CPU Core #$_ using '$Governors{$_}' governor.",
					"Configured to prefer '$CPUGovernor'."
				)
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'CPUGovernor' key.")
	}
} else {
	Info("Ignoring CPU governors.") unless $HushIgnored eq 'true'
}

#------------------------------------------------------------------------Finish

if ($ShowTTL eq 'true') {
	print(
		$ColorHash{'Color_AlertTTLText'} . "Alerted " . color('reset') .
		$ColorHash{'Color_AlertTTL'} . "$AlertCount" . color('reset') .
		$ColorHash{'Color_AlertTTLText'} . " time(s).\n" . color('reset')
	) if $AlertCount > 0;
} else {
	Info("Omitting display of total number of alerts.")
		unless $HushIgnored eq 'true'
}

#-------------------Default Configuration (Formerly '/usr/share/ubuchk/config')

__DATA__

# Core Settings
ANSIColors=true
AutoQuery=false
QueryIndent=6
Recommend=true
ShowTTL=true
SkipIDs=
Verbose=false

# Characters
Char_Margin=+

# ANSI Colors
Color_AlertBracket=red
Color_AlertID=bright_red
Color_AlertTTL=bright_white
Color_AlertTTLText=white
Color_AlertText=bright_white
Color_AlertRecommend=bright_green
Color_QueryText=white
Color_QueryMargin=bright_black

# Disk Usage
AptCache=true
AptCacheMBLimit=100
DSLimit=90
DiskSpace=true
HomeCache=true
HomeCacheMBLimit=100
Thumbnails=true
ThumbsMBLimit=40

# Packaging Configurations
DpkgConf=true
HardAPT=true
PurgeChk=true
SkipAPT=APT::Install-Recommends
SkipDpkgOpts=

# Potentially Unwanted Packages
UnwantedPKGs=atftpd
UnwantedPKGs=kerneloops
UnwantedPKGs=kerneloops-applet
UnwantedPKGs=kerneloops-daemon
UnwantedPKGs=nis
UnwantedPKGs=popularity-contest
UnwantedPKGs=rsh-client
UnwantedPKGs=rsh-redone-client
UnwantedPKGs=rsh-redone-server
UnwantedPKGs=rsh-server
UnwantedPKGs=telnet
UnwantedPKGs=telnet-ssl
UnwantedPKGs=telnetd
UnwantedPKGs=telnetd-ssl
UnwantedPKGs=tftpd
UnwantedPKGs=tftpd-hpa
UnwantedPKGs=time
UnwantedPKGs=virtualbox-guest-additions-iso
UnwantedPKGs=virtualbox-guest-dkms
UnwantedPKGs=virtualbox-guest-dkms-hwe
UnwantedPKGs=virtualbox-guest-source
UnwantedPKGs=virtualbox-guest-source-hwe
UnwantedPKGs=virtualbox-guest-utils
UnwantedPKGs=virtualbox-guest-utils-hwe
UnwantedPKGs=virtualbox-guest-x11
UnwantedPKGs=virtualbox-guest-x11-hwe
UnwantedPKGs=whoopsie
#UnwantedPKGs=whoopsie-preferences
UnwantedPKGs=xinetd
UnwantedPKGs=xul-ext-ubufox
UnwantedPKGs=yp-tools

# Kernel
CustomKMs=
KernMods=true
KernParams=true
SkipKMs=joydev
SkipKP=fs.protected_hardlinks
SkipKP=fs.protected_symlinks

# Mode, Owner, and Group
DirPerms=true
PathPerms=true

# SSH
SSHClient=true
SSHDConfig=/etc/ssh/sshd_config
SSHServer=true

# SystemD
SkipSysD=
SystemD=true

# Portable Machine
BatCrit=10
BatLow=20
Laptop=true

# Mount Options
MountHome=true
SkipMountOpts=

# Sensors
CPUTemp=true
CoreTempCrit=70
TempScale=C

# RootKits, Worms, etc
RootKits=true
IgnoreFile=

# RAM & Swap
MBMaxRAM=2048
MBMaxSwap=512
RAM=false
Swaps=false

# `/etc/passwd`
ChkPasswd=true
ID0NonRoots=true

# Units/Services
AppArmor=true
UFW=true

# Miscellaneous
CMOS=false
CPUGovernor=
FailedLogins=true
LightDM=true
ProcVuln=true
SymsFileMode=true
