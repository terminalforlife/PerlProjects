#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/ubuchk
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/ubuchk/ubuchk
# Started On        - Mon  3 Feb 18:22:57 GMT 2020
# Last Change       - Fri  6 Mar 21:39:26 GMT 2020
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# An ever-growing Perl rewrite and vast overhaul of `ubuntu-syschk`.
#
# Features:
#
#TODO: Add ANSI color support and configuration items for it.
#TODO: Add SSH permission and ownership checks for contents of ~/.ssh.
#TODO: Add `kernel.exec-shield` parameter; recommend value of `1`.
#TODO: Add `kernel.randomize_va_space` parameter; recommend value of `1`.
#TODO: Add a voltage check for the CMOS battery.
#TODO: Add check for CPU governor when using a laptop and regular PC.
#TODO: Add check for X amount of space taken up in Trash.
#TODO: Add check for fan speeds; alert when low/off.
#TODO: Add check for listening TCP ports, via netstat(8) or ss(8).
#TODO: Add check for using something other than `UUID=` in `fstab`.
#TODO: Add checks for unsecure network-related packages. (RSH, for example)
#TODO: Add keys for block size 1000 and 1024, and for SI toggling.
#TODO: Add update feature, because it's important to keep this updated.
#TODO: Alert of all SUID (+4000) and SGID (+2000) files in PATH.
#TODO: Check (almost) entire system for non-group & non-user files.
#TODO: Check for APT options without the use of `apt-config` executable.
#TODO: Check for Flash & Java (OpenJDK & Oracle Java) to suggest removal.
#TODO: Check for UFW service without the use of `systemctl` executable.
#TODO: Check for Wine packages and (separately) Mono packages; suggest removal.
#TODO: Check for installation of fonts unrelated to the user's region/language.
#TODO: Check for periodic filesystem check. (EXT2/3/4)
#TODO: Check if the Secure Boot is enabled; suggest disabling it, if so.
#TODO: Check it's not possible to log in as the `root` user.
#TODO: Check most of the system for files writeable by anybody.
#TODO: Check the `/etc/shadow` file for empty user passwords.
#TODO: Parse `/etc/{logrotate.conf,logrotate.d/*}` to suggest reducing logs.
#TODO: Parse files, like `sources.list`, for abnormals, like 'Proposed' & PPAs.
#TODO: Re-do the `Rootkits` section, regarding the checks; use a database!
#TODO: Somehow check for reduction in SystemD log file, via journalctl(1).
#TODO: Somehow handle the first digit in `stat()` mode.
#
# Bugs:
#
#TODO: Alerts and/or `Info()` calls are repeated for duplicate keys.
#TODO: Queries, when auto-shown, showing duplicates. (correct, but unintended)
#TODO: The undocumented `--os-override` flag doesn't work at all.
#
# Dependencies:
#
#   libfilesys-diskspace-perl (>= 0.05-16)
#   libnumber-bytes-human-perl (>= 0.09-1)
#   libterm-readkey-perl (>= 2.33-1build1)
#   libtext-wrapi18n-perl (>= 0.06-7.1)
#   libtfl-perl (>= 2020-02-20)
#   perl (>= 5.22.1-9)
#------------------------------------------------------------------------------

use strict;
use warnings;
use autodie;
use TFL qw{FErr Boolean DepChk CelsFahr GetDirSize};

no warnings 'uninitialized';

my $CurVer = '2020-03-06';

my $Domain = 'https://github.com/terminalforlife/PerlProjects';

sub Usage{
	print(qq{Usage: $TFL::PROGNAME [OPTS]

		  -h, --help               - Display this help information.
		  -v, --version            - Output the version datestamp.
		  --force-reset            - Force generation of config file.
		  --is-ubuntu              - Execute as though in Ubuntu.
		  --list-dbalerts          - List alerts found within the database.
		  --list-keys              - List available configuration keys.
		  --skip=N[,N ...]         - Skip one or more N alerts, by ID.
		  -Q, --query N            - Read about alert ID number N.
		  -V, --verbose            - Execute checks verbosely.
		  -k, --key K=V            - Override key K with value V.
	} =~ tr/\t//dr)
}

my (
	$ForceReset, $KernParams, $PathPerms, @SkipKP, $Query, $HelpAlertID,
	@UnwantedPKGs, $IsUbuntu, $PurgeChk, $HardAPT, @SkipAPT, $SSHServer,
	$SSHDConfig, $Verbose, $UFW, $SystemD, $KernMods, @CustomKMs,
	@SkipKMs, @SkipIDs, $AlertCount, $Recommend, $SSHClient, $ProcVuln,
	$DiskSpace, @ShownAlerts, $AutoQuery, $QueryIndent, $DSLimit, @DBData,
	$DirPerms, @SkipSysD, $Laptop, @Installed, @NotPurged, $BatCrit, $BatLow,
	$OSOverride, $MountHome, @SkipMountOpts, $CPUTemp, $CoreTempCrit,
	$TempScale, $AptCache, $AptCacheMBLimit, $LightDM, $RootKits, @SkipRKs,
	$HomeCache, $HomeCacheMBLimit, $Thumbnails, $ThumbsMBLimit, $DpkgConf,
	@SkipDpkgOpts, $Swaps, $MBMaxSwap, $RAM, $MBMaxRAM, $CMOS, $ListKeys,
	$ListDbAlerts, $ChkPasswd, %KeyOpt, $ID0NonRoots, $AppArmor, $FailedLogins,
);

my $MainDir = "$ENV{HOME}/.config/$TFL::PROGNAME";
my $ConfigFile = "$MainDir/config";
my $Database = '/usr/share/ubuchk/database';
my $DefaultConfigFile = "/usr/share/$TFL::PROGNAME/config";

my $GID = (split(' ', $())[0];

mkdir($MainDir) unless -d $MainDir;

foreach (@ARGV){
	if (/^(--help|-h|-\?)$/){
		Usage(); exit(0)
	}elsif (/^(--version|-v)$/){
		print("$CurVer\n"); exit(0)
	}elsif(/^(--config|-c)$/){
		shift();

		unless (length($ARGV[0]) > 0){
			FErr(1, __LINE__, "Option '--config|-c' requires a PATH.")
		}elsif (not -f -r $ARGV[0]){
			FErr(1, __LINE__, "Alternative configuration file missing or inaccessible.")
		}

		$ConfigFile = $ARGV[0]
	}elsif(/^(--force-reset|-F)$/){
		$ForceReset = 'true'
	}elsif(/^(--query|-Q)$/){
		shift();

		FErr(1, __LINE__, "Option '--query|-Q' requires an alert ID.")
			unless length($ARGV[0]) > 0;

		FErr(1, __LINE__, "Invalid alert ID -- see: $TFL::PROGNAME -h")
			unless $ARGV[0] =~ '^[0-9]{4}$';

		$Query = 'true';
		$HelpAlertID = $ARGV[0]
	}elsif(/^--skip=/){
		@SkipIDs = split(',', $ARGV[0] =~ s/^--skip=//r);

		FErr(1, __LINE__, "Option '--skip=' requires at least one alert ID.")
			unless @SkipIDs > 0;

		foreach (@SkipIDs){
			FErr(1, __LINE__, "Invalid alert ID -- see: $TFL::PROGNAME -h")
				unless /^[0-9]{4}$/;
		}
	}elsif(/^(--is-ubuntu|-U)$/){
		$IsUbuntu = 'true'
	}elsif(/^(--verbose|-V)$/){
		$Verbose = 'true'
	}elsif($ARGV[0] eq '--os-override'){
		$OSOverride = 'true'
	}elsif($ARGV[0] eq '--list-keys'){
		$ListKeys = 'true'
	}elsif($ARGV[0] eq '--list-dbalerts'){
		$ListDbAlerts = 'true'
	}elsif(/--key|-k/){
		shift();

		my ($Key, $Value) = split('=', $ARGV[0]);
		$KeyOpt{$Key} = $Value
	}elsif (/^-/){
		FErr(1, __LINE__, "Incorrect option(s) specified.")
	}else{
		last
	}

	shift()
}

unless ($OSOverride eq 'true'){
	if (-f -r '/proc/version'){
		open(my $FH, '<', '/proc/version');
		my $OS = (split(' ', <$FH>))[0];
		close($FH);

		FErr(1, __LINE__, "Sorry, $OS is not supported by UbuChk.")
			unless $OS eq 'Linux'
	}else{
		FErr(1, __LINE__, 'Unable to determine OS -- refer to ubuchk(8).')
	}
}

# Needs to be here, for the FileChk() function.
my $VulnDir = '/sys/devices/system/cpu/vulnerabilities';

#-----------------------------------------------------Miscellaneous Subroutines

sub Human{
	use Number::Bytes::Human 'format_bytes';

	return(
		format_bytes($_[0], 'bs' => 1024, 'si' => 1, 'round_style' => 'round')
	)
}

sub Info{ # Usage: [STRING]
	print("$_[0]\n") if $Verbose eq 'true'
}

sub FileChk{ # Usage: [FILE]
	my $Errs;
	unless (-r $_[0]){
		FErr(0, __LINE__, "File '$_[0]' unreadable."); $Errs++
	}elsif (-B -s $_[0]){
		FErr(0, __LINE__, "File '$_[0]' is binary."); $Errs++
	}

	exit(1) if $Errs > 0;

	my $BaseName = ($_[0] =~ m{(?:.*/)(.*)})[0];
}

# Moving this here fixes bug when `AutoQuery` is on and a kernel parameter
# alert is shown. Not sure why; something about changing a read-only variable.
# This is usually not ideal, but at least when there are many alerts, the file
# won't constantly be opened and processed.
if (-f $Database){
	FErr(1, __LINE__, "File '$Database' unreadable.") unless -r $Database;

	open(my $FH, '<', $Database);
	@DBData = <$FH>;
	close($FH);
}else{
	unless ($AutoQuery ne 'true' and $Query ne 'true'){
		if (DepChk(':', 'cito') == 0){
			FErr(0, __LINE__, "File '$Database' not found -- run:")
				unless -f $Database;

			print(
				STDERR "cito -r terminalforlife PerlProjects " .
				"master source/ubuchk/database\n"
			);

			exit(1)
		}

		# Only error out here if queries are NOT completely disabled.
		FErr(1, __LINE__, "File '$Database' not found.")
	}
}

sub QueryAlert{
	use Term::ReadKey 'GetTerminalSize';
	use Text::Wrap 'wrap';

	$HelpAlertID = $_[1] if length($HelpAlertID) == 0;

	my ($Found, @Body);
	foreach (@DBData){
		chomp();

		if (/^:[0-9,]+$/){
			last if $Found eq 'true';

			my @CurIDs = split(',', substr($_, 1));
			foreach (@CurIDs){
				next unless $_ == $HelpAlertID;

				$Found = 'true';
				last
			}
		}elsif ($Found eq 'true'){
			push(@Body, $_)
		}
	}

	FErr(1, __LINE__, "Alert '$HelpAlertID' not found -- are we up-to-date?")
		unless $Found eq 'true';

	$Text::Wrap::columns = (GetTerminalSize())[0] - 2;

	print("Alert #$HelpAlertID:\n") unless length($_[1]) > 0;

	print("\n");
	foreach (@Body){
		# Ensures paragraphing works properly. The database must have a
		# single period (`.`) on an otherwise empty line, for this to work.
		print(' ' x $QueryIndent . '| ' . "\n") and next if $_ eq '.';

		print(wrap(' ' x $QueryIndent . '| ', ' ' x $QueryIndent . '| ', "$_\n"));
	}

	exit($_[0]) unless $_[1] > 0;

	# Prevents a query from being persistent with `AutoQuery`.
	$HelpAlertID = ''
}

sub Alert{ # Usage: [ALERT_ID] [STRING]
	unless (grep({$_ eq $_[0]} @SkipIDs)){
		$AlertCount++;

		printf("[A%0.4d] %s\n", $_[0], $_[1]);
		printf("        %s\n", $_[2]) if $Recommend eq 'true';

		if ($AutoQuery eq 'true'){
			# Don't want to keep showing the same query.
			unless (grep({$_ eq $_[0]} @ShownAlerts)){
				QueryAlert(0, $_[0]);
				push(@ShownAlerts, $_[0]);
				print("\n")
			}
		}
	}
}

sub ParseDpkgStatus{ # Usage: [STATUS_STRING]
	my $DpkgStatus = '/var/lib/dpkg/status';

	unless (-f $DpkgStatus){
		FErr(0, __LINE__, "File '$DpkgStatus' not found.")
	}else{
		FileChk($DpkgStatus);
		open(my $FH, '<', $DpkgStatus);

		my ($Package, $Arch, $Status, @Packages);
		while (<$FH>){
			chomp();
			next if $_ eq '';

			my ($Key, $Value) = split(':');

			if ($Key eq 'Package'){
				$Package = $Value =~ tr/ //dr;
			}elsif ($Key eq 'Status'){
				$Status = $Value =~ tr/ //dr;
			}elsif ($Key eq 'Architecture'){
				$Arch = $Value =~ tr/ //dr;

				next unless $Status eq $_[0];

				push(@Packages, "$Package:$Arch")
			}
		}

		close($FH);

		Info("Finished with '$DpkgStatus' file.");

		return(sort(@Packages))
	}
}

#-----------------------List Keys and Gather Total Number of Alerts in Database

if ($ListKeys eq 'true'){
	open(my $FH, '<', $DefaultConfigFile);

	my @Keys;
	while (<$FH>){
		next if /^(#|$)/;
		my @Line = split('=');
		push(@Keys, $Line[0])
	}

	close($FH);

	my $Old;
	foreach (sort(@Keys)){
		print("$_\n") unless $Old eq $_;
		$Old = $_
	}

	exit(0)
}elsif ($ListDbAlerts eq 'true'){
	open(my $FH, '<', $Database);

	while (<$FH>){
		chomp();
		next unless substr($_, 0, 1) eq ':';
		print("$_\n") foreach split(' ', tr/:,/ /r)
	}

	close($FH);

	exit(0)
}

#-------------------------------------Configuration File Parsing and Generation

unlink($ConfigFile) if $ForceReset eq 'true' and -f $ConfigFile;

if (-f -r -T $ConfigFile){
	my $InvalidKeyCount;

	open(my $FH, '<', $ConfigFile);

	while (<$FH>){
		chomp(my ($Key, $Value) = split('='));
		next if /^(#|$)/;

		# If the current key was provided to the `--key|-k` option, then
		# override the user's configuration file for this key.
		$Value = $KeyOpt{$Key} if grep({$_ eq $Key} keys(%KeyOpt));

		if ($Key eq 'KernParams'){
			Boolean($Value);
			$KernParams = $Value
		}elsif ($Key eq 'PathPerms'){
			Boolean($Value);
			$PathPerms = $Value
		}elsif ($Key eq 'SkipKP'){
			push(@SkipKP, $Value)
		}elsif ($Key eq 'SkipAPT'){
			push(@SkipAPT, $Value)
		}elsif ($Key eq 'PurgeChk'){
			Boolean($Value);
			$PurgeChk = $Value
		}elsif ($Key eq 'IsUbuntu'){
			Boolean($Value);
			$IsUbuntu = $Value unless $IsUbuntu eq 'true'
		}elsif ($Key eq 'HardAPT'){
			Boolean($Value);
			$HardAPT = $Value
		}elsif ($Key eq 'SSHDConfig'){
			$SSHDConfig = $Value
		}elsif ($Key eq 'SSHServer'){
			Boolean($Value);
			$SSHServer = $Value
		}elsif ($Key eq 'SSHClient'){
			Boolean($Value);
			$SSHClient = $Value
		}elsif ($Key eq 'UnwantedPKGs'){
			push(@UnwantedPKGs, $Value)
		}elsif ($Key eq 'Verbose'){
			Boolean($Value);
			$Verbose = $Value unless $Verbose eq 'true'
		}elsif ($Key eq 'UFW'){
			Boolean($Value);
			$UFW = $Value
		}elsif ($Key eq 'SystemD'){
			Boolean($Value);
			$SystemD = $Value
		}elsif ($Key eq 'KernMods'){
			Boolean($Value);
			$KernMods = $Value
		}elsif ($Key eq 'CustomKMs'){
			push(@CustomKMs, $Value)
		}elsif ($Key eq 'SkipKMs'){
			push(@SkipKMs, $Value)
		}elsif ($Key eq 'SkipIDs'){
			push(@SkipIDs, split(',', $Value))
		}elsif ($Key eq 'Recommend'){
			Boolean($Value);
			$Recommend = $Value
		}elsif ($Key eq 'DiskSpace'){
			Boolean($Value);
			$DiskSpace = $Value
		}elsif ($Key eq 'AutoQuery'){
			Boolean($Value);
			$AutoQuery = $Value
		}elsif ($Key eq 'QueryIndent'){
			if ($Value =~ /^[0-9]+$/){
				# Default value and its bounds are mentioned in the config.
				FErr(1, __LINE__, "Key '$Key' out of bounds.")
					unless $Value > 0 and $Value <= 9;

				$QueryIndent = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'DSLimit'){
			if ($Value =~ /^[0-9]+$/){
				# Default value and its bounds are mentioned in the config.
				FErr(1, __LINE__, "Key '$Key' out of bounds.")
					unless $Value >= 10 and $Value <= 100;

				$DSLimit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'DirPerms'){
			Boolean($Value);
			$DirPerms = $Value
		}elsif ($Key eq 'SkipSysD'){
			push(@SkipSysD, $Value)
		}elsif ($Key eq 'Laptop'){
			Boolean($Value);
			$Laptop = $Value
		}elsif ($Key eq 'BatCrit'){
			if ($Value =~ /^[0-9]+$/){
				FErr(1, __LINE__, "Key '$Key' out of bounds.")
					unless $Value > 0 and $Value <= 99;

				$BatCrit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'BatLow'){
			if ($Value =~ /^[0-9]+$/){
				FErr(1, __LINE__, "Key '$Key' out of bounds.")
					unless $Value > 0 and $Value <= 99;

				$BatLow = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'ProcVuln'){
			Boolean($Value);
			$ProcVuln = $Value
		}elsif ($Key eq 'MountHome'){
			Boolean($Value);
			$MountHome = $Value
		}elsif ($Key eq 'SkipMountOpts'){
			push(@SkipMountOpts, split(',', $Value))
		}elsif ($Key eq 'CPUTemp'){
			Boolean($Value);
			$CPUTemp = $Value
		}elsif ($Key eq 'CoreTempCrit'){
			if ($Value =~ /^[0-9]+$/){
				$CoreTempCrit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'TempScale'){
			if ($Value =~ /^[C|F]$/){
				$TempScale = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' must be either 'F' or 'C'.");
			}
		}elsif ($Key eq 'AptCache'){
			Boolean($Value);
			$AptCache = $Value
		}elsif ($Key eq 'AptCacheMBLimit'){
			if ($Value =~ /^[0-9]+$/){
				$AptCacheMBLimit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer in MB.");
			}
		}elsif ($Key eq 'LightDM'){
			Boolean($Value);
			$LightDM = $Value
		}elsif ($Key eq 'RootKits'){
			Boolean($Value);
			$RootKits = $Value
		}elsif ($Key eq 'SkipRKs'){
			push(@SkipRKs, $Value)
		}elsif ($Key eq 'HomeCache'){
			Boolean($Value);
			$HomeCache = $Value
		}elsif ($Key eq 'HomeCacheMBLimit'){
			if ($Value =~ /^[0-9]+$/){
				$HomeCacheMBLimit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'Thumbnails'){
			Boolean($Value);
			$Thumbnails = $Value
		}elsif ($Key eq 'ThumbsMBLimit'){
			if ($Value =~ /^[0-9]+$/){
				$ThumbsMBLimit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'DpkgConf'){
			Boolean($Value);
			$DpkgConf = $Value
		}elsif ($Key eq 'DpkgConf'){
			Boolean($Value);
			$DpkgConf = $Value
		}elsif ($Key eq 'SkipDpkgOpts'){
			push(@SkipDpkgOpts, $Value)
		}elsif ($Key eq 'Swaps'){
			Boolean($Value);
			$Swaps = $Value
		}elsif ($Key eq 'MBMaxSwap'){
			if ($Value =~ /^[0-9]+$/){
				$MBMaxSwap = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'RAM'){
			Boolean($Value);
			$RAM = $Value
		}elsif ($Key eq 'MBMaxRAM'){
			if ($Value =~ /^[0-9]+$/){
				$MBMaxRAM = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'CMOS'){
			Boolean($Value);
			$CMOS = $Value
		}elsif ($Key eq 'ChkPasswd'){
			Boolean($Value);
			$ChkPasswd = $Value
		}elsif ($Key eq 'ID0NonRoots'){
			Boolean($Value);
			$ID0NonRoots = $Value
		}elsif ($Key eq 'AppArmor'){
			Boolean($Value);
			$AppArmor = $Value
		}elsif ($Key eq 'FailedLogins'){
			Boolean($Value);
			$FailedLogins = $Value
		}else{
			FErr(0, __LINE__, "Key '$Key' unrecognised.");

			$InvalidKeyCount++
		}
	}

	close($FH);

	exit(1) if $InvalidKeyCount > 0;

	# Because this would otherwise make no sense.
	FErr(1, __LINE__, "Key conflict with 'BatCrit' and 'BatLow'.")
		if $Laptop eq 'true' and $BatCrit >= $BatLow
}else{
	use File::Copy 'copy';

	if (-f $DefaultConfigFile){
		FileChk($DefaultConfigFile);
		copy($DefaultConfigFile, $ConfigFile)
			or FErr(1, __LINE__, "Failed to generate a configuration file.");

		printf("File '~/.config/$TFL::PROGNAME/config' generated -- reload me.\n");
		exit(0)
	}else{
		FErr(1, __LINE__, "File '/usr/share/$TFL::PROGNAME/config' not found.")
	}
}

if (@SkipIDs > 0){
	foreach (@SkipIDs){
		FErr(1, __LINE__, "Invalid alert ID -- see: $TFL::PROGNAME -h")
			unless /^[0-9]{4}$/
	}
}

@Installed = sort(ParseDpkgStatus('installokinstalled'))
	if @UnwantedPKGs > 0;

@NotPurged = sort(ParseDpkgStatus('deinstallokconfig-files'))
	if $PurgeChk eq 'true';

#---------------------------------------------------------------------LSB Check

unless ($IsUbuntu eq 'true'){
	my $OSRelease = '/etc/os-release';

	FileChk($OSRelease);
	open(my $FH, '<', $OSRelease);

	my ($LSB, $Found);
	while (<$FH>){
		chomp();
		next if /^(#|$)/;
		next unless $_ eq 'ID=ubuntu';

		$Found = 'true';

		last
	}

	close($FH);

	FErr(1, __LINE__, "Your distribution is not supported.")
		unless $Found eq 'true'
}

#-------------------------------------------------------------Querying an Alert

QueryAlert(0) if $Query eq 'true';

#-------------------------------------------------------------Kernel Parameters

# Developer line.
#if (0){

if ($KernParams eq 'true'){
	my ($Value, $AlertID, $GoodValue, $Path, $ShowKey);

	foreach ( # [ALERT_ID] [DESIRED_VALUE] [KEY_PATH]
		'0913:1:/proc/sys/kernel/ctrl-alt-del',
		'1090:5:/proc/sys/net/ipv4/tcp_syn_retries',
		'1211:0:/proc/sys/net/ipv4/conf/all/accept_redirects',
		'1291:0:/proc/sys/net/ipv6/conf/default/accept_source_route',
		'1443:1:/proc/sys/kernel/yama/ptrace_scope',
		'1491:10:/proc/sys/vm/swappiness',
		'1821:1:/proc/sys/net/ipv4/conf/default/rp_filter',
		'2125:2048:/proc/sys/net/ipv4/tcp_max_syn_backlog',
		'2529:0:/proc/sys/net/ipv4/conf/default/send_redirects',
		'2847:1:/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses',
		'2916:0:/proc/sys/net/ipv6/conf/all/accept_redirects',
		'5434:1:/proc/sys/net/ipv4/icmp_echo_ignore_all',
		'5668:2:/proc/sys/net/ipv4/tcp_synack_retries',
		'6279:0:/proc/sys/net/ipv4/conf/default/accept_source_route',
		'6576:0:/proc/sys/net/ipv4/conf/all/accept_source_route',
		'7512:1:/proc/sys/net/ipv4/conf/all/rp_filter',
		'7536:0:/proc/sys/kernel/sysrq',
		'8560:2:/proc/sys/kernel/kptr_restrict',
		'8852:1:/proc/sys/net/ipv4/conf/all/log_martians',
		'8963:0:/proc/sys/net/ipv6/conf/all/accept_source_route',
		'9191:0:/proc/sys/net/ipv4/conf/all/send_redirects',
		'9222:1:/proc/sys/net/ipv4/tcp_syncookies',
		'9623:1:/proc/sys/kernel/dmesg_restrict',
		'9998:1:/proc/sys/fs/protected_symlinks',
		'9999:1:/proc/sys/fs/protected_hardlinks'
	){
		($AlertID, $GoodValue, $Path) = split(':');
		$ShowKey = $Path =~ tr/\//./r =~ s/\.proc\.sys\.//r;

		next if grep({$_ eq $ShowKey} @SkipKP);

		Info("Checking '$ShowKey' parameter.");

		if (-f $Path){
			unless (-r $Path){
				# Some parameters are more locked down than others.
				FErr(0, __LINE__, "Denied access to '$ShowKey' parameter.");
				next
			}elsif (-B -s $Path){
				FErr(0, __LINE__, "Unable to determine '$ShowKey' parameter.");
				next
			}

			open(my $FH, '<', $Path);
			chomp($Value = <$FH>);
			close($FH)
		}else{
			Info("Parameter '$ShowKey' unavailable.");

			next
		}

		Info("Parameter '$ShowKey' is '$Value'.");

		Alert(
			$AlertID,
			"Key '$ShowKey' assigned '$Value'.",
			"Recommended value is '$GoodValue'."
		) if $Value != $GoodValue
	}
}

#--------------------------------------------------PATH Permissions & Ownership

if ($PathPerms eq 'true'){
	if (length($ENV{'PATH'}) > 0){
		my @AlertPerms;
		foreach (split(':', $ENV{'PATH'})){
			Info("Looking in '$_' directory.");

			foreach (glob("$_/*")){
				my ($Mode, $Owner, $Group) = (stat($_))[2,4,5];
				$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

				Info("File '$_' is '$Mode' and '$Owner:$Group'.")
					if $Owner > 1 and $Owner < 1000
					or $Group > 1 and $Group < 1000
					or $Mode > 000 and $Mode < 755;

				Alert(
					7869,
					"File '$_' is mode '$Mode'.",
					"Recommended mode is '755'."
				) unless $Mode <= 755;

				# These executables should not be owned by a standard user, nor
				# should they be in such a group. <1000 is for system
				# users/groups. A stricter test (make optional?) would be to
				# flag all non-0s. There are exceptions, however, such as the
				# user having his or her own `bin` directory in their `/home`
				# directory.
				Alert(
					6005,
					"File '$_' is owned by '$Owner'.",
					"Recommended owner is '0' ('root')."
				) if $Owner >= 1000;

				Alert(
					3597,
					"File '$_' is in group '$Group'.",
					"Recommended group is '0' ('root')."
				) if $Group >= 1000
			}
		}
	}else{
		# This would have to be some seriously bizarre edge-case.
		Info("Missing prerequisites -- skipping 'PathPerms' key.")
	}
}

#-----------------------------------------------------Packages Yet to Be Purged

if ($PurgeChk eq 'true'){
	Info("Looking for old package remains.");

	Alert(
		6712,
		"Package '$_' wasn't purged.",
		"Suggested action is to purge the package."
	) foreach @NotPurged;

	Info('No packages were found unpurged.') if @NotPurged == 0
}

#-----------------------------------------------------------APT Security Tweaks

if ($HardAPT eq 'true'){
	if (DepChk(':', 'apt-config') == 0){
		my %Settings;
		foreach (`apt-config dump --format '%f=%v%n' 2> /dev/null`){
			chomp();
			next if /^(#|$)/;

			my ($Key, $Value) = split('=');
			$Value = $Value =~ tr/"';//dr;

			$Settings{$Key} = $Value
		}

		foreach ( # [TARGET_VALUE] [KEY]
			'6135|6131|false|APT::Get::AllowUnauthenticated',
			'6136|6132|false|Acquire::http::AllowRedirect',
			'6137|6133|false|APT::Install-Suggests',
			'6138|6134|false|APT::Install-Recommends'
		){
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next if grep({$_ eq $Key} @SkipAPT);

			unless (exists($Settings{$Key})){
				Alert(
					$AlertID1,
					"APT key '$Key' not assigned.",
					"Recommended action is to assign it '$Target'."
				)
			}elsif ($Settings{$Key} ne $Target){
				Alert(
					$AlertID2,
					"APT key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}else{
				Info("Key '$Key' is '$Settings{$Key}'.");
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'HardAPT' key.")
	}
}

#--------------------------------------------------------------------SSH Client

if ($SSHClient eq 'true'){
	my $SSHDir = "$ENV{HOME}/.ssh";

	if (-d $SSHDir){
		FErr(1, __LINE__, "Directory '$SSHDir' unreadable.") unless -r $SSHDir;
		FErr(1, __LINE__, "Directory '$SSHDir' denies execution.") unless -x $SSHDir;

		my ($Mode, $Owner, $Group) = (stat($SSHDir))[2,4,5];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		Alert(
			5431,
			"Directory '$SSHDir' is mode '$Mode'.",
			"Recommended mode is '700'."
		) unless $Mode == 700;

		Alert(
			5438,
			"Directory '$SSHDir' is owned by '$Owner'.",
			"Recommended UID is '$<'."
		) unless $Owner == $<;

		Alert(
			5439,
			"Directory '$SSHDir' is in group '$Group'.",
			"Recommended GID is '$GID'."
		) unless $Group == $GID;
	}else{
		Info("Missing prerequisites -- skipping 'SSHClient' key.")
	}
}

#--------------------------------------------------------------------SSH Server

if ($SSHServer eq 'true'){
	if (-f $SSHDConfig){
		FErr(1, __LINE__, "File '$SSHDConfig' unreadable.")
			unless -r $SSHDConfig;

		# Without the `-s` flag, zero-size files get flagged as binary.
		FErr(1, __LINE__, "File '$SSHDConfig' is binary.")
			if -B -s $SSHDConfig;

		FileChk($SSHDConfig);
		open(my $FH, '<', $SSHDConfig);

		my %Settings;
		while (<$FH>){
			chomp();
			next if /(^#|^$)/;

			my ($Key, $Value) = split(' ');

			Info("Key '$Key' is '$Value'.");

			$Settings{$Key} = $Value
		}

		close($FH);

		foreach ( # [ALERT_ID_1] [ALERT_ID_2] [TARGET_VALUE] [KEY]
			'6990|6980|no|PermitRootLogin',
			'6991|6992|2|Protocol',
			'6996|6993|no|PermitEmptyPasswords',
			'6997|6994|no|PasswordAuthentication',
			'6998|6995|no|X11Forwarding'
		){
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next if grep({$_ eq $Key} @SkipAPT);

			unless (exists($Settings{$Key})){
				Alert(
					$AlertID1,
					"SSH daemon key '$Key' not assigned.",
					"Recommended action is to assign it '$Target'."
				)
			}elsif ($Settings{$Key} ne $Target){
				Alert(
					$AlertID1,
					"SSH daemon key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}

		# Ordinarily, you shouldn't use the commonplace `22` port.
		unless (exists($Settings{'Port'})){
			Alert(
				7541,
				"SSH daemon key 'Port' not assigned.",
				"Recommended action is NOT to assign it '22'."
			)
		}elsif ($Settings{'Port'} eq 22){
			Alert(
				6542,
				"SSH daemon key 'Port' assigned '$Settings{Port}'.",
				"Recommended value is one other than '22'."
			)
		}
	}else{
		Info("Missing prerequisites -- skipping 'SSHServer' key.")
	}
}

#---------------------------------------------------------Packages Best Avoided

if (@UnwantedPKGs > 0){
	foreach my $CurPKG (@UnwantedPKGs){
		Info("Looking for '$CurPKG' package.");

		Alert(
			5656,
			"Package(s) matching '$CurPKG' installed.",
			"Suggested action is to uninstall the package(s)."
		) if grep(/$CurPKG/, @Installed)
	}
}

#----------------------------------------------------------------SystemD Tweaks

if ($SystemD eq 'true'){
	my $SDConfig = '/etc/systemd/system.conf';

	if (-f $SDConfig){
		FileChk($SDConfig);
		open(my $FH, '<', $SDConfig);

		my %Settings;
		while (<$FH>){
			chomp();
			next if /(^#|^$|^\[Manager\]$)/;

			my ($Key, $Value) = split('=');

			Info("Key '$Key' is '$Value'.");

			$Settings{$Key} = $Value
		}

		close($FH);

		foreach ( # [TARGET_VALUE] [KEY]
			'1411|1415|1024|DefaultLimitNPROC',
			'1412|1416|1024|DefaultLimitNOFILE',
			'1413|1417|no|CrashShell',
			'1414|1418|no|DumpCore'
		){
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next if grep({$_ eq $Key} @SkipSysD);

			unless (exists($Settings{$Key})){
				Alert(
					$AlertID1,
					"SystemD key '$Key' not assigned.",
					"Recommended action is to assign it '$Target'."
				)
			}elsif ($Settings{$Key} ne $Target){
				Alert(
					$AlertID2,
					"SystemD key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'SystemD' key.")
	}
}

#----------------------------------------------------------------Kernel Modules

if ($KernMods eq 'true'){
	my $ProcMods = '/proc/modules';

	if (-f $ProcMods){
		FileChk($ProcMods);
		open(my $FH, '<', $ProcMods);

		my @Modules;
		while (<$FH>){
			chomp();

			my @Line = split(' ');

			push(@Modules, $Line[0])
		}

		close($FH);

		foreach (
			'1274|mei',
			'1275|mei_me',
			'1276|mei_wtk',
			'7416|joydev',
			'8471|psmouse'
		){
			my ($AlertID, $Module) = split('\|');

			if (grep({$_ eq $Module} @Modules)){
				unless (grep({$_ eq $Module} @SkipKMs)){
					Info("Module '$Module' found but ignored.");
					next # <-- Skipping the below alert.
				}

				Alert(
					$AlertID,
					"Module '$Module' discovered and live.",
					"Recommended action is to blacklist the module."
				)
			}else{
				Info("Module '$Module' not found.")
			}
		}

		foreach my $Mod (@CustomKMs){
			Alert(
				8189,
				"Module '$Mod' discovered and live.",
				"Recommended action is to blacklist the module."
			) if grep({$_ eq $Mod} @Modules)
		}
	}else{
		Info("Missing prerequisites -- skipping 'KernMods' key.")
	}
}

#--------------------------------------------------------Check Filesystem Sizes

if ($DiskSpace eq 'true'){
	my $MountFile = '/proc/mounts';

	if (-f $MountFile){
		use Filesys::DiskSpace 'df';

		FileChk($MountFile);
		open(my $FH, '<', $MountFile);

		my (@MountPoints, $Base, $Used, $Free, $Size, $Mount, $Perc);
		while (<$FH>){
			chomp(my @Arr = split(' '));

			# Using this REGEX over just '^/' avoids statfs errors.
			if ($Arr[0] =~ '^/dev/(sd|hd|fd)[[:alpha:]]+[0-9]+$'){
				# Avoids `not a directory` error, for EFI setups.
				next if $Arr[1] eq '/boot/efi';

				Info("Looking at '$Arr[0]' partition.");

				$Mount = $Arr[1] =~ s/\\040/ /gr;
				($Used, $Free) = (df($Mount))[2,3] or next;
				$Used = $Used * 1024;
				$Free = $Free * 1024;
				$Size = $Free + $Used;
				$Perc = int(($Used / $Size) * 100);

				if ($Perc >= $DSLimit){
					Alert(4612,
						"Partition '$Arr[0]' is $Perc% full.",
						"Recommended action is to clear out junk."
					)
				}else{
					Info("Partition '$Arr[0]' is using $Perc% of space.");
				}
			}
		}

		close($FH);
	}else{
		Info("Missing prerequisites -- skipping 'DiskSpace' key.")
	}
}

#----------------------Specific File & Directory Permissions, Group & Ownership

if ($DirPerms eq 'true'){
	foreach ( # [ALERTID] [MODE] [UID] [GID]
		"5440:700:$<:$GID:$ENV{HOME}",
		'5436:700:0:0:/boot',
		'5446:700:0:0:/root'
	){
		my ($AlertID, $TargetMode, $TargetUID, $TargetGID, $Path) = split(':');

		next unless -d $Path;

		Info("Looking at '$Path' directory.");

		my ($Mode, $Owner, $Group) = (stat($Path))[2,4,5];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		Alert(
			$AlertID,
			"Directory '$Path' is mode '$Mode'.",
			"Recommended mode is '$TargetMode'."
		) unless $Mode == $TargetMode;

		Alert(
			$AlertID,
			"Directory '$Path' is owned by '$Owner'.",
			"Recommended UID is '$TargetUID'."
		) unless $Owner == $TargetUID;

		Alert(
			$AlertID,
			"Directory '$Path' is in group '$Group'.",
			"Recommended GID is '$TargetGID'."
		) unless $Group == $TargetGID;
	}
}

#-----------------------------------------------------------------Laptop Checks

if ($Laptop eq 'true'){
	my $BaseDir = '/sys/class/power_supply';
	my $AdapTypeFile = "$BaseDir/ADP1/type";
	my $AdapOnlineFile = "$BaseDir/ADP1/online";

	my $AdapOnline;
	if (-f $AdapTypeFile){
		FileChk($AdapTypeFile);
		open(my $FH, '<', $AdapTypeFile);
		chomp(my $AdapType = <$FH>);
		close($FH);

		if ($AdapType eq 'Mains'){
			FileChk($AdapOnlineFile);
			open(my $FH, '<', $AdapOnlineFile);
			chomp($AdapOnline = <$FH>);
			close($FH);

			if ($AdapOnline == 0){
				Info("Device is NOT plugged in.")
			}else{
				Info("Device is plugged in.")
			}
		}
	}

	if (-d "$BaseDir/BAT1"){ # <-- Ensure at least one battery exists.
		foreach (glob("$BaseDir/BAT[1-9]")){
			my $BatFile = "$_/capacity";
			my $KNowFile = "$_/charge_now";
			my $KMaxFile = "$_/charge_full_design";

			if (-f $BatFile){
				FileChk($BatFile);
				open(my $FH, '<', $BatFile);
				chomp(my $BatPerc = <$FH>);
				close($FH);

				my $Battery = $BatFile =~ s/.*\/BAT([0-9]+)\/capacity$/$1/r;

				my ($KNow, $KMax);
				if (-f $KNowFile and -f $KMaxFile){
					FileChk($KNowFile);
					open(my $FH, '<', $KNowFile);
					chomp($KNow = substr(<$FH>, 0, length($KNow) - 4));
					close($FH);

					FileChk($KMaxFile);
					open($FH, '<', $KMaxFile);
					chomp($KMax = substr(<$FH>, 0, length($KMax) - 4));
					close($FH);
				}

				if ($BatPerc <= $BatCrit){
					Alert(
						2850,
						"Battery #$Battery critical at $BatPerc% ($KNow mAh) capacity.",
						"Save your work and shut down the computer."
					) unless $AdapOnline == 1
				}elsif ($BatPerc <= $BatLow){
					if (length($KMax) > 0 and length($KNow) > 0){
						Alert(
							2849,
							"Battery #$Battery low at $BatPerc% ($KNow mAh) capacity.",
							"Suggested action is to charge the battery."
						) unless $AdapOnline == 1
					}else{
						Alert(
							2849,
							"Battery #$Battery low at $BatPerc% capacity.",
							"Suggested action is to charge the battery."
						) unless $AdapOnline == 1
					}
				}else{
					if (length($KMax) > 0 and length($KNow) > 0){
						Info("Battery #$Battery still has $BatPerc% at $KNow mAh power.")
					}else{
						Info("Battery #$Battery still has $BatPerc% power left.")
					}
				}
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'Laptop' key.")
	}
}

#------------------------------------------------------CPU Marked as Vulnerable

if ($ProcVuln eq 'true'){
	if (-d $VulnDir){
		FErr(1, __LINE__, "Directory '$VulnDir' unreadable.")
			unless -r $VulnDir;

		FErr(1, __LINE__, "Unable to open '$VulnDir' directory.")
			unless -x $VulnDir;

		foreach (glob("$VulnDir/*")){
			next unless -f;

			my $Vuln = ($_ =~ m{(?:.*/)(.*)})[0];

			Info("Checking CPU for vulnerability to $Vuln.");

			FileChk($_);
			open(my $FH, '<', $_);
			chomp(my $Data = <$FH>);
			close($FH);

			if ($Data =~ /Vulnerable/i){
				Alert(
					4811,
					"CPU marked as vulnerable to $Vuln.",
					"Don't panic -- refer to: $TFL::PROGNAME -Q 4811"
				)
			}elsif ($Data =~ /Not affected/i){
				Info("Unaffected by $Vuln vulnerability.")
			}elsif ($Data =~ /Mitigation/i){
				Info("Vulnerability $Vuln mitigated.")
			}else{
				Alert(
					4812,
					"Unrecognised vulnerability status to $Vuln.",
					"Don't panic -- refer to: $TFL::PROGNAME -Q 4812"
				)
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'ProcVuln' key.")
	}
}

#--------------------------------------------------------Mount Options for HOME

if ($MountHome eq 'true'){
	my $MountFile = '/proc/mounts';

	if (-f $MountFile){
		FileChk($MountFile);
		open(my $FH, '<', $MountFile);

		my ($Device, $Options);
		while (<$FH>){
			chomp(my @Arr = split(' '));

			# Using this REGEX over just '^/' avoids statfs errors.
			if ($Arr[1] eq '/home'){
				($Device, $Options) = @Arr[0,3];
				last
			}
		}

		close($FH);

		if (length($Device) > 0){
			Info("Mountpoint '/home' points to '$Device'.");

			my @OptArr = split(',', $Options);
				my ($AlertID, $Option) = split(',');

			foreach (
				'1356,noexec',
				'1357,nodev',
				'1358,nosuid'
			){
				my ($AlertID, $Option) = split(',');

				if (grep({$_ eq $Option} @SkipMountOpts)){
					Info("Module '$Option' found but ignored.");
					next # <-- Skipping the below alert.
				}

				if (grep({$_ eq $Option} @OptArr)){
					Info("Mount option '$Option' for '/home' is set.")
				}else{
					Alert($AlertID,
						"Missing mount option '$Option' for '/home'.",
						"Please refer to: $TFL::PROGNAME -Q $AlertID"
					)
				}
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'MountHome' key.")
	}
}

#---------------------------------------------------------CPU Core Temperatures

# There are several ways to get the system's CPU temperature(s), without
# dragging in another program, but for now, I'll program for this particular
# method, adding additional ones as issues are reported.
if ($CPUTemp eq 'true'){
	my $Dir;
	if (-d '/sys/devices/platform/coretemp.0/hwmon/hwmon3'){
		$Dir = '/sys/devices/platform/coretemp.0/hwmon/hwmon3'
	}elsif (-d '/sys/class/hwmon/hwmon1'){
		$Dir = '/sys/class/hwmon/hwmon1'
	}else{
		Info("Missing prerequisites -- skipping 'CPUTemp' key.")
	}

	FErr(1, __LINE__, "Directory '$Dir' unreadable.") unless -r $Dir;
	FErr(1, __LINE__, "Directory '$Dir' denies execution.") unless -x $Dir;

	# Gather a hash of (only) the core temperatures.
	my (%TempData, $Temp);
	foreach (glob("$Dir/temp*")){
		next unless -f and m{/temp[0-9]+_(input|label)$};

		FileChk($_);
		open(my $FH, '<', $_);
		chomp(my $Data = <$FH>);
		close($FH);

		# The files are ordered from input to label, so we need to process
		# it backwards, otherwise the output would be borked.
		if (/_input$/){
			$Temp = $Data
		}elsif (/_label$/){
			$TempData{$Data} = $Temp
		}
	}

	# Ensure we have the right suffix for 1'st', 2'nd', 3'rd', and N'th'.
	sub Suffix{ # Usage: [INT]
		my $Num = $_[0] + 1;
		return("${Num}st") if $Num =~ '1$';
		return("${Num}nd") if $Num =~ '2$';
		return("${Num}rd") if $Num =~ '3$';
		return("${Num}th")
	}

	# Begin checking on each of the core temperatures, per the above hash.
	foreach (sort(keys(%TempData))){
		next unless /^Core [0-9]+$/;

		# Initially, this value is in Celsius (unconfirmed).
		my $TempInt = CelsFahr(
			$TempScale, substr($TempData{$_}, 0, length($TempData{$_}) - 3)
		);

		my $TempStr = "$TempIntÂ°$TempScale";
		my $CoreInt = (m{(?:.* )(.*)})[0];
		my $CoreStr = Suffix($CoreInt);
		if ($TempInt >= $CoreTempCrit){
			Alert(
				6237,
				"CPU's $CoreStr core critical at $TempStr.",
				"Suggested action is to improve system cooling."
			)
		}else{
			Info("CPU core #$CoreInt stable at $TempStr.")
		}
	}
}

#----------------------------------------------------------APT Cache Disk Usage

if ($AptCache eq 'true'){
	my $Dir = '/var/cache/apt/archives';

	if (-d $Dir){
		# Ignoring `partial` directory, as it often needs root access to use.
		# The same goes for files like `lock`, as they're irrelevant here.
		my ($FileCount, $Size);
		foreach (glob("$Dir/*.deb")){
			$Size += -s;
			$FileCount++;

			if ($Verbose eq 'true'){
				my $Human = Human($Size);
				my $BaseName = ($_ =~ m{(?:.*/)(.*)})[0];

				Info("Found '$BaseName', using $Human.");
			}
		}

		if ($Size > 0){
			my $Human = Human($Size);
			if ($Size / 1024 / 1024 >= $AptCacheMBLimit){
				if (DepChk(':', 'sudo') == 0){
					Alert(
						9708,
						"Found $FileCount cached Debian packages, totalling $Human.",
						"Suggested action is to run: sudo apt-get clean"
					);
				}else{
					Alert(
						9708,
						"Found $FileCount cached Debian packages, totalling $Human.",
						"Suggested action is to, as root, run: apt-get clean"
					);
				}
			}else{
				Info("Cached Debian packages take up only $Human.");
			}
		}else{
			Info("Found no cached Debian packages.");
		}
	}else{
		Info("Missing prerequisites -- skipping 'AptCache' key.")
	}
}

#-----------------------------------------------------------------------LightDM

if ($LightDM eq 'true'){
	my $Config = '/etc/lightdm/lightdm.conf.d/50-no-guest.conf';

	if (-f $Config){
		FileChk($Config);
		open(my $FH, '<', $Config);

		my $AllowGuest;
		while (<$FH>){
			chomp();

			# Correct, at least in Ubuntu 16.04.6 base. Ubuntu 18.04.4 seems to
			# not use this file by default, but it can still be found at:
			#
			#  /usr/share/lightdm/lightdm.conf.d/50-disable-guest.conf
			#
			if (/(^| )allow-guest=true( |$)/){
				$AllowGuest = 'true'; last
			}elsif (/(^| )allow-guest=false( |$)/){
				$AllowGuest = 'false'; last
			}
		}

		close($FH);

		if ($AllowGuest eq 'true'){
			Alert(
				9188,
				'Guest logins are allowed with LightDM.',
				'Recommended action is to disable guest logins.'
			);
		}elsif ($AllowGuest eq 'false'){
			Info('LightDM does not permit guest logins.')
		}else{
			Alert(
				9188,
				'Guest logins may be allowed with LightDM.',
				"Recommended action is to ensure it's disabled."
			);
		}
	}else{
		Info("Missing prerequisites -- skipping 'LightDM' key.")
	}
}

#----------------------------------------------------------RootKits, Worms, etc

if ($RootKits eq 'true'){
	# Based on information from this GitHub repository:
	#
	#   https://github.com/ossec/ossec-hids
	#
	# Also inspired by various checks made by rkhunter(8).
	my (@BadFiles, @FoundInfs);
	foreach (
		'7125|/tmp/{mcliZokhb,mclzaKmfa}|Bash door',
		'7126|/dev/.shit/red.tgz,/usr/{lib/libt,bin/adore}|Adore Worm',
		'7127|/usr/bin/{soucemask,sourcemask}|TRK Rootkit',
		'7128|/tmp/.../{a,r}|55808.A Worm',
		'7129|/usr/{lib,bin}/volc|Volc Rootkit',
		'7129|/{lib/security/.config,usr/bin/sia,etc/ld.so.hash}|Illogic Rootkit',
		'7130|/{usr/src/.puta,usr/info/.t0rn,lib/ldlib.tk,etc/ttyhash,sbin/xlogin}|t0rn Rootkit',
		'7131|/{bin/{rtty,squit},sbin/pback,proc/kset,usr/src/linux/modules/{autod.o,soundx.o}}|RK17',
		'7132|/usr/{lib/ldlib{[pn]s,login}.so,src/.poop,tmp/ramen.tgz,etc/xinetd.d/asp}|Ramen Worm',
		'7133|/dev/cuc|Sadmind/IIS Worm',
		'7134|/{lib/defs,usr/lib/libpikapp.a}|Monkit',
		'7134|/{usr/bin/{kr4p,n3tstat,chsh2,slice2},etc/rc.d/rsha}|RSHA',
		'7135|/{bin/home,sbin/home,usr/sbin/in.slogind}|ShitC',
		'7136|/dev/chr|Omega Worm',
		"7137|/{bin/{.lpstree,.ps,ldu,lkillall,lnetstat},usr/bin/{cleaner,slice,vadim,.ps,.lpstree,ldu,lkillall,lnetstat}}|RH-Sharpe's Rootkit",
		'7138|/usr/bin/mailrc|Maniac RK',
		'7139|/usr/{sbin/{initdl,xntps},lib/{.{egcs,wormie,kinetic},liblog.o},include/{addr,file,proc,syslogs}.h}|Showtee / Romanian',
		'7140|/usr/bin/{xchk,xsf}|Optickit',
		'7141|/{dev/.kork,bin/.{login,ps}}|LDP Worm',
		'7142|/{dev/hda06,usr/info/libc1.so}|Telekit',
		'7143|/dev/wd4|Tribe bot',
		'7144|/dev/ida/.inet|LRK',
		'7145|/{usr/{doc/sys/{qrt,run,crond,kern/{var,string.o,ava,adore.o}},sbin/kfd,secure},etc/{bin,sbin}/ava,var/log/ssh/old}|Adore Rootkit',
		'7146|/{tmp/{.bugtraq{,.c},.cinik,.b,httpd,.unlock,.font-unix/.cinik},tmp./update}|Slapper',
		'7147|/tmp/{.uua,.a}|Scalper',
		'7148|/{proc/knark{,/pids},dev/.{pizda,pula}}|Knark Rootkit',
		'7149|/{dev/.lib{,/1iOn.sh},bin/{mjt,in.telnetd},usr/info/torn}|Lion Worm',
		'7150|/{usr/{include/.../,lib/{.../,.bkit-},sbin/.../,bin/ntpsx},tmp/.bkp}|Bobkit',
		'7151|/var/lib/games/.k|Hid Rootkit',
		'7152|/dev/ptyxx|Ark',
		"7153|/usr/lib/locale/uboot|Mithra's Rootkit",
		'7154|/tmp/{xp,kidd0.c,kidd0}|LOC Rootkit',
		'7155|/usr/{info/.tc2k,bin/util,sbin/{initcheck,ldb}}|TC2 Worm',
		'7156|/usr/sbin/{mech,kswapd}|Anonoiyng Rootkit',
		'7157|/lib/{.x,sk}|SuckIt',
		'7158|/usr/{local/bin/bin,man/.man10,sbin/arobia,lib/elm/arobia,local/bin/.../bktd}|Beastkit',
		'7159|/{dev/tux,usr/bin/{xsf,xchk}}|Tuxkit',
		'7160|/usr/{doc/{.sl,.sp,.statnet,.logdsys,.dpct,.gifnocfi,.dnif,.nigol},include/rpc/_../{kit{,2}}}|Old Rootkits',
		'7161|/usr/include/._.|Kenga3 Rootkit',
		'7162|/lib/tcl5.3|ESRK Rootkit',
		'7163|/{sbin/xc,usr/include/ivtype.h,bin/.lib}|Fu Rootkit',
		'7164|/{lib/security/.config,etc/ld.so.hash}|ShKit Rootkit',
		'7165|/{lib/.li{gh.gh,bgh.gh,bgh-gh},dev/{tux,tux/.{proc,file}}}|AjaKit Rootkit',
		'7166|/bin/{imin,imout}|zaRwT Rootkit',
		'7167|/usr/include/ice{key.h,conf.h,seed.h}|Madalin Rootkit',
		'7168|/{lib/libsh.so,usr/lib/libsh}|shv5 Rootkit',
		'7169|/etc/.bmbl{,/sk}|BMBL Rootkit',
		'7170|/tmp/{cback,derfiq}|Cback Linux Worm',
		'7171|/usr/share/.aPa|aPa Kit',
		'7172|/etc/.enyelkm{HIDE^IT,OCULTAR}.ko|ENYE LKM v1.1, v1.2',
		'7173|/dev/grid-{hide-pid-,unhide-pid-,show-pids,hide-port-,unhide-port-}|Override Rootkit',
		'7174|/{uNFuNF,{usr/share/.home.ph1/{tty,kebab,cb,phalanx},etc/host.ph1,bin/host.ph1}}|Phalanx Rootkit',
		'7193|/{etc/{cron.d/zupzzplaceholder,lolzz.p2/.{p2rc,phalanx2,sniff},khubd.p2/{.p2rc,.phalanx2,.sniff,sshgrab.py}},usr/lib/zupzz.p2/{.p-2.3d,.p2rc}}|Phalanx2 Rootkit',
		'7175|/{usr/share/.zk{,/zk},etc/1ssue.net,usr/X11R6/.{zk,zk/xfs,zk/echo},etc/sysconfig/console/load.zk}|ZK Rootkit',
		'7176|/var/{adm/{.profile,sa/.adm},spool/lp/{.profile,admins/.lp}}|Solaris Worm',
		'7178|/usr/bin/duarawkz{,/loginpass}|Duarawkz Rootkit',
		'7179|/{dev/..0{,/backup},etc/ld.so.hash,lib/security/.config/ssh/{sshd_config,ssh_host_key,ssh_host_key.pub,ssh_random_seed},usr/{lib/ldlib{ns,ps,pst,du,ct}.so,bin/ssh2d}}|Flea Linux Rootkit',
		'7180|/{dev/{pty{q,r,s,t},fd/.{88/freeshb-bsd,freesht,zxsniff,zxsniff.log,99/{.tty{f00,p00,q00,s00},.pwsx00}}},etc/.acid,usr/lib/.fx/{sched_host.2,random_d.2,set_pid.2,setrgrp.2,TOHIDE,cons.saver,adore/{ava/ava,adore/adore.ko}},bin/sysback,usr/local/bin/sysback}|FreeBSD Rootkit',
		'7181|/{dev/proc/{toolz,{.bash_profile,.bashrc,.cshrc},fuckit/{hax0r,hax0rshell,config/{lports,rports,rkconf,password,progs},system-bins/init}},usr/lib/lib{cps,tty}.a}|Fuckit Rootkit',
		'7182|/dev/dev/gaskit/sshd/sshdd|GasKit Rootkit',
		'7183|/dev/.hijackerz|HjC Kit Rootkit',
		'7184|/{lib/defs/{p,q,r,s,t},usr/lib/{defs/{p,q,r,s,t},.libigno/{pkunsec,.igno/psybnc/psybnc}}}|ignoKit Rootkit',
		'7185|/Users/{w0rm-support.tgz,InqTest.class,comm.openbundle.plist,com.pwned.plist,libavetanaBT.jnilib,de,javax}|OSX Inqtana (Variant A)',
		'7186|/Users/{w0rms.love.apples.tgz,InqTest.{java,class},InqTanaHandler{,/.bundle},libavetanaBT.jnilib,de,javax}|OSX Inqtana (Variant B)',
		'7187|/Users/{applec0re.tgz,InqTest.{java,class},libavetanaBT.jnilib,environment.plist,pwned.c,pwned.dylib,de,javax}|OSX Inqtana (Variant C)',
		'7188|/dev/pts/01/{backup,etc,tmp}|Irix Rootkit',
		'7189|/usr/_h4x_/{ipsecs-kbeast-v1.ko,_h4x_bd,acctlog}|KBeast (Kernel Beast) Rootkit',
		'7190|/usr/src/redhat/SRPMS/...|Kitko Rootkit',
		'7191|/{sbin/init__mood-nt-_-_cthulhu,_cthulhu/mood-nt.{init,conf,sniff}}|Mood-NT Rootkit',
		'7192|/dev/.oz/.nap/rkit/terror|Oz Rootkit',
		'7177|/{dev/{.{arctic,golf,rd,xman},hd7,hdx1,hx2,ptyp,ptyr,ptyzg,ptyzx,rd/cdb,srd0,ttyof,ttyop,xdf1,xdf2},etc/rc.d/init.d/rc.modules,lib/{.fx,.so,lblip.tk,ldd.so},proc/kset,sbin/{pback,vobiscum},tmp/.{cheese,dump},usr/{X11R6/include/pain,bin/{.etc,atm,ddc,gib,ishit,jdc,kfl,ras2xm,snick,sourcemask,xstat},lib/{.fx,pt07},man/{man1/lib/.lib,man2/.man8,man3/psid,muie},sbin/{atd2,in.telnet,jcd}},var/{.x{,/psotnic},local/.lpd,run/.{pid,tmp}}}|Suspicious Files',
	){
		my ($AlertID, $Infection, $Name) = split('\|');

		Info("Searching: $Name");

		my $Alert = '';
		foreach (glob($Infection)){
			next if grep({$_ eq $Name} @SkipRKs);

			if (-e $_ =~ tr/_/ /r){
				push(@BadFiles, $_);

				push(@FoundInfs, "$AlertID|$Name")
					unless grep(/^$AlertID\|/, @FoundInfs);

				$Alert = 'true'
			}
		}
	}

	foreach (sort(@FoundInfs)){
		my ($AlertID, $Name) = split('\|');

		Alert(
			$AlertID,
			"Potential '$Name' infection detected!",
			'Please seek immediate medical attention.'
		)
	}

	Info("File '$_' discovered.") foreach sort(@BadFiles)
}

#------------------------------------------------------------------User's Cache

if ($HomeCache eq 'true'){
	my $CacheDir = "$ENV{HOME}/.cache";

	if (-d $CacheDir){
		my $Size = GetDirSize($CacheDir);
		if ($Size > 0){
			use POSIX 'ceil';

			my $SizeMB = ceil($Size / (1024 * 1024));
			my $Human = Human($Size);
			if ($SizeMB >= $HomeCacheMBLimit){
				Alert(
					7619,
					"User '$ENV{USER}' has a cache total of $Human.",
					"Suggested action is to remove unneeded files."
				)
			}else{
				Info("User '$ENV{USER}' caches only $Human.")
			}
		}else{
			Info("User '$ENV{USER}' directory '~/.cache' is empty.")
		}
	}else{
		Info("Missing prerequisites -- skipping 'HomeCache' key.")
	}
}

#-------------------------------------------------------------User's Thumbnails

if ($Thumbnails eq 'true'){
	my $ThumbDir = "$ENV{HOME}/.thumbnails";

	if (-d $ThumbDir){
		my $Size = GetDirSize($ThumbDir);
		if ($Size > 0){
			use POSIX 'ceil';

			my $SizeMB = ceil($Size / 1024 / 1024);
			my $Human = Human($Size);
			if ($SizeMB >= $ThumbsMBLimit){
				Alert(
					7620,
					"User '$ENV{USER}' has a cache total of $Human.",
					"Suggested action is to remove unneeded files."
				)
			}else{
				Info("User '$ENV{USER}' thumbnails take up only $Human.")
			}
		}else{
			Info("User '$ENV{USER}' directory '~/.thumbnails' is empty.")
		}
	}else{
		Info("Missing prerequisites -- skipping 'Thumbnails' key.")
	}
}

#------------------------------------------------------------DPKG Configuration

if ($DpkgConf eq 'true'){
	my $DpkgConfFile = '/etc/dpkg/dpkg.cfg';

	if (-f $DpkgConfFile){
		FileChk($DpkgConfFile);
		open(my $FH, '<', $DpkgConfFile);

		my ($FoundNoDebSig, $FoundLog);
		while (<$FH>){
			chomp();
			next if /^(#|$)/;

			$FoundNoDebSig = 'true' if /^no-debsig($|[[:space:]]+.*)/;
			$FoundLog = 'true' if /^log /;
		}

		close($FH);

		my $ChkStatus = grep({$_ eq 'no-debsig'} @SkipDpkgOpts);
		unless ($FoundNoDebSig eq 'true' and not $ChkStatus){
			Alert(
				3790,
				"Potentially-unsupported 'debsig' not disabled.",
				"Recommended action is to verify it's supported."
			)
		}else{
				Info("Configuration value 'no-debsig' found.");
		}

		$ChkStatus = grep({$_ eq 'log'} @SkipDpkgOpts);
		unless ($FoundLog eq 'true' and not $ChkStatus){
			Alert(
				3791,
				"Status changes and actions not being logged by DPKG.",
				"Recommended action is to enable this feature."
			)
		}else{
				Info("Configuration value 'log' found.");
		}
	}else{
		Info("Missing prerequisites -- skipping 'DpkgConf' key.")
	}
}

#-------------------------------------------------------------------------Swaps

if ($Swaps eq 'true'){
	my $SwapFile = '/proc/swaps';

	if (-f $SwapFile){
		use POSIX 'ceil';

		FileChk($SwapFile);
		open(my $FH, '<', $SwapFile);

		my (@Swaps, $SwapCount);
		while (<$FH>){
			chomp();

			# Skip header.
			next if $. == 1;

			my ($File, $Type, $Size, $Used, $Priority) = split(' ');
			my $HumSize = Human($Size * 1024);
			my $HumUsed = Human($Used * 1024);
			my $MRemains = ceil(($Size - $Used) / 1024);

			if ($Type eq 'file'){
				my ($Mode, $Owner, $Group) = (stat($File))[2,4,5];
				$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

				Alert(
					6232,
					"File '$File' is mode '$Mode'.",
					"Recommended mode is '600'."
				) unless $Mode == 600;

				Alert(
					6233,
					"File '$File' is owned by '$Owner'.",
					"Recommended UID is '0'."
				) unless $Owner == 0;

				Alert(
					6234,
					"File '$File' is in group '$Group'.",
					"Recommended GID is '0'."
				) unless $Group == 0;
			}

			# Just in-case the file is in the user's HOME.
			$File = $File =~ s/$ENV{HOME}/~/r;

			if ($MRemains >= $MBMaxSwap){
				Info("Swap $Type '$File' using $HumUsed/$HumSize.");
			}else{
				my $HumRemains = Human(($Size - $Used) * 1024);

				Alert(
					8759,
					"Only $HumRemains left on '$File' $Type.",
					"Suggested action is to increase swap size."
				)
			}

			$SwapCount++
		}

		Info("System has $SwapCount active swap areas.") if $SwapCount > 1;

		close($FH)
	}else{
		Info("Missing prerequisites -- skipping 'Swaps' key.")
	}
}

#---------------------------------------------------------------------------RAM

if ($RAM eq 'true'){
	my $MemFile = '/proc/meminfo';

	if (-f $MemFile){
		use POSIX 'ceil';

		FileChk($MemFile);
		open(my $FH, '<', $MemFile);

		my (
			$BShared, $BSwap, $BTotal, $BFree,
			$BCache, $HumFree, $BSRec, $BBuf
		);

		while (<$FH>){
			chomp(my @Line = split(' '));

			if ($Line[0] eq 'MemTotal:'){
				$BTotal = $Line[1] * 1024
			}elsif ($Line[0] eq 'MemFree:'){
				$BFree = $Line[1] * 1024
			}elsif ($Line[0] eq 'Buffers:'){
				$BBuf = $Line[1] * 1024
			}elsif ($Line[0] eq 'Cached:'){
				$BCache = $Line[1] * 1024
			}elsif ($Line[0] eq 'Shmem:'){
				$BShared = $Line[1] * 1024
			}elsif ($Line[0] eq 'SwapTotal:'){
				$BSwap = $Line[1] * 1024
			}elsif ($Line[0] eq 'SReclaimable:'){
				$BSRec = $Line[1] * 1024
			}
		}

		close($FH);

		my $HumTotal = Human($BTotal);

		# Ignore shared memory, buffers, and cache, similar to htop(1).
		my $BUsed = ($BTotal - $BFree) - ($BBuf + $BCache + $BSRec);

		# As the free(1) utility shows by default.
		my $MUsed = ceil($BUsed / (1024 * 1024));
		my $HumUsed = Human($BUsed);

		if ($MUsed <= $MBMaxRAM){
			Info("Using only $HumUsed of $HumTotal available RAM.")
		}else{
			Alert(
				8971,
				"Using $HumUsed of $HumTotal available RAM.",
				"Please refer to: $TFL::PROGNAME -Q 8971"
			)
		}
	}else{
		Info("Missing prerequisites -- skipping 'RAM' key.")
	}
}

#------------------------------------------------------------------CMOS Battery

if ($CMOS eq 'true'){
	my $RTCFile = '/proc/driver/rtc';

	if (-f $RTCFile){
		open(my $FH, '<', $RTCFile);

		my $BatStatus;
		while (<$FH>){
			chomp();
			my @Line = split(': ');
			$BatStatus = $Line[1]
		}

		close($FH);

		if ($BatStatus eq 'okay'){
			Info("CMOS battery appears to be okay.")
		}else{
			Alert(
				1118,
				"Detected a non-'okay' CMOS battery status.",
				"Recommended action is to physically check it."
			)
		}
	}else{
		Info("Missing prerequisites -- skipping 'CMOS' key.")
	}
}

#-------------------------------------------------------------------/etc/passwd

if ($ChkPasswd eq 'true'){
	my $PasswdFile = '/etc/passwd';

	if (-f $PasswdFile){
		open(my $FH, '<', $PasswdFile);

		my ($WormFound, @Roots);
		while (<$FH>){
			$WormFound = $. if /w0rm/;

			if ($ID0NonRoots eq 'true'){
				chomp(my @Line = split(':'));

				if ($Line[2] == 0 or $Line[3] == 0){
					push(@Roots, $Line[0]) unless grep({$_ eq $Line[0]} @Roots);
				}
			}
		}

		close($FH);

		unless (length($WormFound) > 0){
			Info("Cannot see 'w0rm' in '$PasswdFile' file.")
		}else{
			Alert(
				1428,
				"Found 'w0rm' on line #$WormFound in '$PasswdFile' file.",
				"Please refer to a search engine."
			)
		}

		if ($ID0NonRoots eq 'true'){
			unless (@Roots > 1){
				Info("Just 'root' with '0:0' found in '$PasswdFile' file.")
			}else{
				if (@Roots > 1){
					my ($Wording1, $Wording2);
					if (@Roots == 2){
						$Wording1 = 'user';
						$Wording2 = 'this user is'
					}else{
						$Wording1 = 'users';
						$Wording2 = 'these users are'
					}

					Alert(
						9848,
						"Non-root $Wording1 with '0' UID/GID in '$PasswdFile' file.",
						"Recommended action is to confirm $Wording2 legitimate."
					);

					foreach (@Roots){
						Info("User '$_' has '0' UID/GID.") unless $_ eq 'root'
					}
				}
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'ChkPasswd' key.");

		Info("Missing prerequisites -- skipping 'ID0NonRoots' key.")
			if $ID0NonRoots eq 'true'
	}
}

#--------------------------------------------------------SystemD Units/Services

if ($UFW eq 'true'){
	if (DepChk(':', 'systemctl') == 0){
		chomp(my $Active = `systemctl is-active ufw 2> /dev/null`);
		unless ($Active eq 'active'){
			Alert(
				5541,
				"UFW is installed but its service inactive.",
				"Recommended action is to start the UFW service."
			)
		}else{
			Info('The UFW service is active.')
		}

		chomp(my $Enabled = `systemctl is-enabled ufw 2> /dev/null`);
		unless ($Enabled eq 'enabled'){
			Alert(
				5542,
				"UFW is installed but its service disabled.",
				"Recommended action is to enable the UFW service."
			)
		}else{
			Info('The UFW service is enabled.')
		}
	}else{
		Info("Missing prerequisites -- skipping 'UFW' key.")
	}
}

if ($AppArmor eq 'true'){
	if (DepChk(':', 'systemctl') == 0){
		chomp(my $Active = `systemctl is-active apparmor 2> /dev/null`);
		unless ($Active eq 'active'){
			Alert(
				1298,
				"AppArmor is installed but its service inactive.",
				"Recommended action is to start the AppArmor service."
			)
		}else{
			Info('The AppArmor service active.')
		}

		chomp(my $Enabled = `systemctl is-enabled apparmor 2> /dev/null`);
		unless ($Enabled eq 'enabled'){
			Alert(
				1299,
				"AppArmor is installed but its service disabled.",
				"Recommended action is to enable the AppArmor service."
			)
		}else{
			Info('The AppArmor service is enabled.')
		}
	}else{
		Info("Missing prerequisites -- skipping 'AppArmor' key.")
	}
}

#---------------------------------------------------------Failed Login Attempts

if ($FailedLogins eq 'true'){
	my $FailFile = '/var/log/faillog';

	if (-f $FailFile){
		unless (-s $FailFile){
			Alert(
				2223,
				'Detected possible failed login attempts.',
				'Please execute the faillog(8) command.'
			)
		}else{
			Info('')
		}
	}else{
		Info("Missing prerequisites -- skipping 'FailedLogins' key.")
	}
}

#------------------------------------------------------------------------Finish

# Developer line.
#}

print("Alerted $AlertCount time(s).\n") if $AlertCount > 0;
