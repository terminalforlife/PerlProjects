#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/ubuchk
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/ubuchk/ubuchk
# Started On        - Mon  3 Feb 18:22:57 GMT 2020
# Last Change       - Wed 17 May 11:43:18 BST 2023
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# An ever-growing Perl rewrite and vast overhaul of `ubuntu-syschk`.
#
# Features:
#
#TODO: Check for CVE-2021-3156. Local exploit.
#
#      Can be done with: sudoedit -s '\' `perl -e 'print "A" x 65536'`
#      This has been fixed. Apparently the '/etc/passwd' last modified time
#      needs to be newer than when the system was booted. A segmentation error
#      indicates you are vulnerable to this exploit.
#
#TODO: Check for Firefox parameters, whether to optimize or make more secure.
#
#      https://forums.linuxmint.com/viewtopic.php?p=1962270#p1962270
#      https://forums.linuxmint.com/viewtopic.php?p=1962675#p1962675
#
#TODO: Search for files without a user and/or group assigned to them.
#
#      For example, in Shell: find / -xdev \( -nouser -o -nogroup \)
#
#TODO: Check for module `pam_namespace` for user's own `/tmp` and `/var/tmp`.
#TODO: Add SSH permission and ownership checks for contents of ~/.ssh.
#TODO: Add `AllowUsers` check to `SSHServer` key.
#TODO: Add `kernel.exec-shield` parameter; recommend value of `1`.
#TODO: Add check for CPU governor when using a laptop and regular PC.
#TODO: Add check for X amount of space taken up in Trash.
#TODO: Add check for fan speeds; alert when low/off.
#TODO: Add check for listening TCP/UDP ports, via netstat(8) or ss(8).
#TODO: Add check for using something other than `UUID=` in `fstab`.
#TODO: Add checks for unsecure network-related packages. (RSH, for example)
#TODO: Add keys for block size 1000 and 1024, and for SI toggling.
#TODO: Add netstat(8) and ss(8) port and/or address security checks.
#TODO: Alert of all SUID (+4000) and SGID (+2000) files in PATH.
#TODO: Check (almost) entire system for non-group & non-user files.
#TODO: Check `/etc/inetd.conf` for malicious lines. (IE: Ramen Worm; '^asp')
#TODO: Check `/proc/kallsyms` file for malicious lines. ('(adore|sebek)')
#TODO: Check chklastlog(1) & chkwtmp(1) executables.
#TODO: Check for APT options without the use of `apt-config` executable.
#TODO: Check for Flash & Java (OpenJDK & Oracle Java) to suggest removal.
#TODO: Check for SSH scanners, via `/{var/tmp,tmp}/{vuln.txt,ssh-scan,pscan2}`.
#TODO: Check for UFW service without the use of `systemctl` executable.
#TODO: Check for Wine packages and (separately) Mono packages; suggest removal.
#TODO: Check for `apparmor=1` and `security=apparmor` in GRUB command line.
#TODO: Check for `apparmor=1` and `security=apparmor` in LILO command line.
#TODO: Check for installation of fonts unrelated to the user's region/language.
#TODO: Check for periodic filesystem check. (EXT2/3/4)
#TODO: Check if the Secure Boot is enabled; suggest disabling it, if so.
#TODO: Check it's not possible to log in as the `root` user.
#TODO: Check most of the system for files writeable by anybody.
#TODO: Check the `/etc/shadow` file for empty user passwords.
#TODO: Have `postinst` shell script check for appropriate default settings.
#TODO: Parse `/etc/{logrotate.conf,logrotate.d/*}` to suggest reducing logs.
#TODO: Parse files, like `sources.list`, for abnormals, like 'Proposed' & PPAs.
#TODO: Somehow check for reduction in SystemD log file, via journalctl(1).
#TODO: Somehow handle the first digit in `stat()` mode.
#TODO: Use integer booleans instead of string booleans, except in config file.
#
# Ports for which to add a check:
#
#   114,   145,   465,   511,   600,  1008,  1524,  1978,  1999,  2881,  3049,
#  3133,  3879,  4000,  4369,  5190,  5665,  6667,  7222, 10008, 12321, 23132,
# 27374, 29364, 30999, 31336, 31337, 37998, 45454, 47017, 47889, 60001
#
# Those ports can be found via the REGEX '[0-9:]443', with `netstat -tunla` or
# `ss -tunla`), and for which are also searched in chkrootkit(1).
#
# Bugs:
#
#TODO: Key overriding using OPT is ignored if key not found in config.
#
#      Simply assigning a default set of values (default config) would fix
#      this, but it would be easier (not really, but more dynamic) to have
#      UbuChk programmatically resort to the existing default config.
#
#      This bug and its potential resolution will likely be present and
#      applicable in some similarly-written programs of mine, like TuDu.
#
#TODO: Alerts and/or `Info()` calls are repeated for duplicate keys.
#TODO: Mismatch between temperatures shown from UbuChk and sensors(1).
#TODO: Not checking for invalid keys specified with `--key|-k` option.
#TODO: Not checking for valid `Color_*` and `Char_*` keys.
#TODO: Queries, when auto-shown, showing duplicates. (correct, but unintended)
#
#      Not sure if this is still applicable, as I've yet to notice this since.
#
# Dependencies:
#
#   libfilesys-diskspace-perl (>= 0.05-16)
#   libterm-readkey-perl (>= 2.33-1build1)
#   libtext-wrapi18n-perl (>= 0.06-7.1)
#   perl (>= 5.26.1)
#   perl-modules-5.26 (>= 5.26.1-6)
#------------------------------------------------------------------------------

use feature 'say';
use strict;
use warnings;
use autodie;
use Term::ANSIColor 'color', 'colorvalid';
use Term::ReadKey 'GetTerminalSize';
use Filesys::DiskSpace 'df';
use Text::Wrap 'wrap';

no warnings 'uninitialized';

use constant VERSION => '2022-04-16';
use constant PROGRAM => 'ubuchk';
use constant PROGRAM_FANCY => 'UbuChk';

sub Usage() {
	print(qq{Usage: ${\PROGRAM} [OPTS]

		  -h, --help               - Display this help information.
		  -v, --version            - Output the version datestamp.
		  --force-reset            - Force generation of config file.
		  --force-run              - Execute as though in Ubuntu Linux.
		  --hush-ignored           - When verbose, omit 'Ignoring' messages.
		  --list-dbalerts          - List alerts found within the database.
		  --list-keys              - List available configuration keys.
		  --skip=N[,N ...]         - Skip one or more N alerts, by ID.
		  -Q, --query N            - Read about alert ID number N.
		  -V, --verbose            - Execute checks verbosely.
		  -c, --config FILE        - Use alternative configuration file.
		  -k, --key K=V            - Override key K with value V.
	} =~ tr/\t//dr)
}

use constant SYMS_FILE => '/proc/kallsyms';
use constant USER_ID => $<;
use constant GROUP_ID => (split(' ', $())[0];
use constant DATABASE => '/usr/share/ubuchk/database';
use constant RK_DATABASE => '/usr/share/ubuchk/database-rk';
use constant DEFAULT_CONFIG_FILE => '/usr/share/' . PROGRAM . '/config';
use constant PS_BASE_DIR => '/sys/class/power_supply';
use constant PS_TYPE_FILE => PS_BASE_DIR . '/ADP1/type';
use constant PS_ONLINE_FILE => PS_BASE_DIR . '/ADP1/online';
use constant MOUNT_FILE => '/proc/mounts';
use constant APT_ARCHIVES_DIR => '/var/cache/apt/archives';
use constant LDM_CONFIG_FILE => '/etc/lightdm/lightdm.conf.d/50-no-guest.conf';
use constant USER_CACHE_DIR => "$ENV{HOME}/.cache";
use constant USER_THUMB_DIR => "$ENV{HOME}/.thumbnails";
use constant DPKG_CONFIG_FILE => '/etc/dpkg/dpkg.cfg';
use constant SWAPS_FILE => '/proc/swaps';
use constant MEMINFO_FILE => '/proc/meminfo';
use constant RTC_FILE => '/proc/driver/rtc';
use constant PASSWD_FILE => '/etc/passwd';
use constant FAILLOG_FILE => '/var/log/faillog';
use constant CPU_GOV_DIR => '/sys/devices/system/cpu';
use constant OS_REL_FILE => '/etc/os-release';
use constant CPU_VULN_DIR => '/sys/devices/system/cpu/vulnerabilities';
use constant DPKG_STATUS_FILE => '/var/lib/dpkg/status';
use constant PROC_MODS_FILE => '/proc/modules';

my (
	$ForceReset, $KernParams, $PathPerms, @SkipKP, $Query, $HelpAlertID,
	@UnwantedPKGs, $ForceRun, $PurgeChk, $HardAPT, @SkipAPT, $SSHServer,
	$SSHDConfig, $Verbose, $UFW, $SystemD, $KernMods, @CustomKMs,
	@SkipKMs, @SkipIDs, $AlertCount, $Recommend, $SSHClient, $ProcVuln,
	$DiskSpace, @ShownAlerts, $AutoQuery, $QueryIndent, $DSLimit, $DirPerms,
	@SkipSysD, $Laptop, @Installed, @NotPurged, $BatCrit, $BatLow, $MountHome,
	@SkipMountOpts, $CPUTemp, $CoreTempCrit, $FailedLogins, $TempScale,
	$AptCache, $AptCacheMBLimit, $LightDM, $RootKits, @IgnoreFiles,
	$HomeCache, $HomeCacheMBLimit, $Thumbnails, $ThumbsMBLimit, $DpkgConf,
	@SkipDpkgOpts, $Swaps, $MBMaxSwap, $RAM, $MBMaxRAM, $CMOS, $ListKeys,
	$ListDbAlerts, $ChkPasswd, %KeyOpt, $ID0NonRoots, $AppArmor, %ColorHash,
	$ANSIColors, $Char_Margin, %Syms, $ShowTTL, $HushIgnored, $SymsFileMode,
	$CPUGovernor
);

# Let me know if I missed any.
my @ValidGovs = (
	'performance', 'schedutil', 'powersave',
	'conservative', 'userspace', 'ondemand'
);

# These distributions are deemed supported and these strings are the value to
# the 'ID' key in the '/etc/os-release' file.
my @SupportedLSBs = ('ubuntu', 'pop');

my $MainDir = "$ENV{HOME}/.config/" . PROGRAM;
my $ConfigFile = "$MainDir/config";

# Used with human-readable sizes.
my $HumanDivisor = 1024;

unless (-d $MainDir) {
	mkdir($MainDir) or die("$!")
}

while (defined($ARGV[0])) {
	if ($ARGV[0] =~ /^(--help|-h)$/) {
		Usage(); exit(0)
	} elsif ($ARGV[0] =~ '^(--version|-v)$') {
		say(VERSION); exit(0)
	} elsif ($ARGV[0] =~ '^(--config|-c)$') {
		shift();

		die("Err: OPT '$1' requires a file.\n")
			unless defined($ARGV[0]);

		# Not checking for a valid file, because UbuChk can generate its own.
		my $DirName = ($ARGV[0] =~ m{(.*[^/])?(?:/.*)})[0];
		die("Err: Directory '$DirName' not found.\n")
			unless -d $DirName;

		$ConfigFile = $ARGV[0]
	} elsif ($ARGV[0] =~ '^(--force-reset|-F)$') {
		$ForceReset = 'true'
	} elsif ($ARGV[0] eq '--force-run') {
		$ForceRun = 'true'
	} elsif ($ARGV[0] eq '--hush-ignored') {
		$HushIgnored = 'true'
	} elsif ($ARGV[0] =~ '^(--query|-Q)$') {
		shift();

		die("Err: OPT '$1' requires an alert ID.\n")
			unless defined($ARGV[0]);

		die("Err: Invalid alert ID.\n")
			unless $ARGV[0] =~ '^[[:digit:]]{4}$';

		$Query = 'true';
		$HelpAlertID = $ARGV[0]
	} elsif ($ARGV[0] =~ /^(--skip=)(.*)$/) {
		@SkipIDs = split(',', $2);

		die("Err: OPT '$1' requires at least one ID.\n")
			unless @SkipIDs;

		my $Failed = 0;
		foreach my $ID (@SkipIDs) {
			unless (/^[[:digit:]]{4}$/) {
				warn("Err: Alert ID '$ID' invalid.\n");
				$Failed++
			}
		}

		exit(1) if $Failed
	} elsif ($ARGV[0] =~ '^(--verbose|-V)$') {
		$Verbose = 'true'
	} elsif ($ARGV[0] eq '--list-keys') {
		$ListKeys = 'true'
	} elsif ($ARGV[0] eq '--list-dbalerts') {
		$ListDbAlerts = 'true'
	} elsif ($ARGV[0] =~ '^(--key|-k)$') {
		shift();

		die("Err: OPT '$1' requires a key.\n")
			unless defined($ARGV[0]);

		my ($Key, $Value) = split('=', $ARGV[0]);
		$KeyOpt{$Key} = $Value
	} elsif ($ARGV[0] =~ '^-') {
		die("Err: Incorrect option(s) specified.\n")
	} else {
		last()
	}

	shift()
}

die("Err: Directory '$MainDir' unwritable.\n")
	unless -w $MainDir;

die("Err: Directory '$MainDir' unexectuable.\n")
	unless -x $MainDir;

#-----------------------------------------------------------Primary Subroutines

# Usage: Info(<STRING>)
sub Info($) {
	say($_[0]) if $Verbose eq 'true'
}

# Usage: Human(<BYTES>)
sub Human($) {
	my $Size = $_[0];
	foreach ('', qw{K M G T P E Z Y}) {
		if ($Size < $HumanDivisor) {
			my $Result = sprintf("%.1f", $Size);
			my $Len = length($Result);
			my $LastTwo = substr($Result, $Len - 2);
			if ($LastTwo eq '.0') {
				return(substr($Result, 0, $Len - 2) . $_)
			} else {
				return($Result . $_)
			}
		}

		$Size = $Size / $HumanDivisor
	}
}

# Usage: FileChk(<FILE>)
sub FileChk($) {
	my $Errs = 0;
	unless (-r $_[0]) {
		$Errs++; warn("Err: File '$_[0]' unreadable.\n")
	} elsif (-B -s $_[0]) {
		$Errs++; warn("Err: File '$_[0]' is binary.\n")
	}

	exit(1) if $Errs
}

sub SlurpFile($) {
	FileChk($_[0]);

	open(my $FH, '<', $_[0]) or die("$!");

	my $Buffer;
	{
		local $/ = undef();
		$Buffer = <$FH>
	}
	chomp($Buffer);

	close($FH) or die("$!");
	return($Buffer)
}

sub DepChk {
	my @Files;
	foreach my $Dir (split(':', $ENV{'PATH'})) {
		-d -r -x $Dir or next();

		foreach my $File (glob("$Dir/*")) {
			-f -r -x $File or next();

			my $Base = ($File =~ m{(?:.*/)([^/].*)})[0];
			push(@Files, $Base)
		}
	}

	foreach my $CurDep (@_) {
		grep({$_ eq $CurDep} @Files) or return(0)
	}

	return(1)
}

# Taken directly from the TFL module. (2020-02-29)
sub GetDirSize($) {
	my $Dir = $_[0];
	my (@Dirs, $Size);
	foreach (glob("$Dir/{*,.*}")) {
		next() if m{/(\.\.|\.)$};
		next() if -l; # <-- Avoid link recursion.

		push(@Dirs, $_) if -d -r -x;
		$Size += -s if -f
	}

	foreach (@Dirs) {
		foreach (glob("$_/{*,.*}")) {
			next if m{/(\.\.|\.)$};
			next if -l; # <-- Avoid link recursion.

			push(@Dirs, $_) if -d -x;
			$Size += -s if -f
		}
	}

	return($Size)
}

sub Boolean($) {
	die("Err: Invalid boolean '$_[0]' detected.\n")
		unless $_[0] =~ '^(true|false)$'
}

sub Suffix($) { # Usage: [INT]
	my $Num = $_[0] + 1;
	return("${Num}st") if $Num =~ '1$';
	return("${Num}nd") if $Num =~ '2$';
	return("${Num}rd") if $Num =~ '3$';
	return("${Num}th")
}

# Taken directly from the TFL module. (2020-02-29)
sub CelsFahr($;$) {
	if ($_[0] eq 'F') {
		return(int(($_[1] * 9/5) + 32))
	} elsif ($_[0] eq 'C') {
		return($_[1])
	}
}

#---------------------------------------------------------------OS & LSB Checks

unless ($ForceRun eq 'true') {
	die("Err: Unrecognised OS.\n")
		unless $^O eq 'linux';

	if (-f -r OS_REL_FILE) {
		open(my $FH, '<', OS_REL_FILE) or die("$!");

		my $Found = 0;
		while (my $Line = <$FH>) {
			chomp(my ($Key, $Value) = split('=', $Line));

			if ($Key eq 'ID') {
				grep({$_ eq 'ubuntu'} @SupportedLSBs);
				$Found = 1
			}
		}

		close($FH) or die("$!");

		$Found or die("Err: Unsupported LSB.\n")
	} else {
		die("Err: Unrecognised LSB.\n")
	}
}

#-----------------------------------------------------------Read Query Database

# Needs to be here; it fixes bug when `AutoQuery` is on and a kernel parameter
# alert is shown. Not sure why; something about changing a read-only variable.
my @DBData;
if (-f -r DATABASE) {
	open(my $FH, '<', DATABASE) or die("$!");
	@DBData = <$FH>;
	close($FH) or die("$!")
} else {
	# Only error out here if queries are NOT completely disabled.
	die("Err: File '${\DATABASE}' missing or unreadable.\n")
		unless $AutoQuery ne 'true' and $Query ne 'true'
}

#-----------------------------------------------------Miscellaneous Subroutines

# Usage: QueryAlert(<>, <ALERT_ID>)
sub QueryAlert($;$) {
	$HelpAlertID = $_[1] unless length($HelpAlertID);

	my @Body;
	my $Found = 0;
	foreach (@DBData) {
		chomp();

		if (/^:[[:digit:],]+$/) {
			last() if $Found;

			my @CurIDs = split(',', substr($_, 1));
			foreach (@CurIDs) {
				next() unless $_ == $HelpAlertID;

				$Found = 1;
				last()
			}
		} elsif ($Found) {
			push(@Body, $_)
		}
	}

	die("Err: Alert '$HelpAlertID' not found.\n")
		unless $Found;

	$Text::Wrap::columns = (GetTerminalSize())[0] - 2;

	say("Alert #$HelpAlertID:")
		unless length($_[1]);

	print("\n");
	foreach (@Body) {
		# Ensures paragraphing works properly. The database must have a
		# single period (`.`) on an otherwise empty line, for this to work.
		if ($_ eq '.') {
			say(
				' ' x $QueryIndent . $ColorHash{'Color_QueryMargin'} .
				"$Syms{'Char_Margin'} " . color('reset')
			);

			next()
		}

		say(
			wrap(
				' ' x $QueryIndent . $ColorHash{'Color_QueryMargin'} .
				"$Syms{'Char_Margin'} " . color('reset') .
				$ColorHash{'Color_QueryText'}, ' ' x $QueryIndent .
				$ColorHash{'Color_QueryMargin'} . "$Syms{'Char_Margin'} " .
				color('reset') . $ColorHash{'Color_QueryText'},
				$ColorHash{'Color_QueryText'} . $_ . color('reset')
			)
		);
	}

	exit($_[0]) unless $_[1];

	# Prevents a query from being persistent with `AutoQuery`.
	$HelpAlertID = ''
}

# Usage: Alert(<ALERT_ID>, <ALERT_STRING>, <RECOMMEND_STRING>)
sub Alert($;$;$) {
	unless (grep({$_ eq $_[0]} @SkipIDs)) {
		$AlertCount++;

		printf(
			$ColorHash{'Color_AlertBracket'} . "[" . color('reset') .
			$ColorHash{'Color_AlertID'} . "A%0.4d" . color('reset').
			$ColorHash{'Color_AlertBracket'} . "]" . color('reset') .
			$ColorHash{'Color_AlertText'} . " %s\n" . color('reset'),
			$_[0], $_[1]
		);

		say(
			$ColorHash{'Color_AlertRecommend'} .
			' ' x 8 . $_[2] . color('reset')
		) if $Recommend eq 'true';

		# Don't want to keep showing the same query.
		if ($AutoQuery eq 'true') {
			unless (grep({$_ eq $_[0]} @ShownAlerts)) {
				QueryAlert(0, $_[0]);
				push(@ShownAlerts, $_[0]);
				print("\n")
			}
		}
	} else {
		Info("Skipping alert #$_[0], as requested.")
	}
}

# Usage: ParseDpkgStatus(<STATUS_STRING>)
sub ParseDpkgStatus($) {
	unless (-f DPKG_STATUS_FILE) {
		warn("Err: File '${\DPKG_STATUS_FILE}' not found.\n")
	} else {
		FileChk(DPKG_STATUS_FILE);
		open(my $FH, '<', DPKG_STATUS_FILE) or die("$!");

		my ($Package, $Arch, $Status, @Packages);
		while (<$FH>) {
			chomp();
			next() unless length($_);

			my ($Key, $Value) = split(':');

			# Need to `if`, else out of string errors.
			$Value = substr($Value, 1)
				if length($Value);

			if ($Key eq 'Package') {
				$Package = $Value
			} elsif ($Key eq 'Status') {
				$Status = $Value
			} elsif ($Key eq 'Architecture') {
				$Arch = $Value;

				next() unless $Status eq $_[0];

				push(@Packages, "$Package:$Arch")
			}
		}

		close($FH) or die("$!");

		Info("Finished with '${\DPKG_STATUS_FILE}' file.");

		return(sort(@Packages))
	}
}

#-----------------------List Keys and Gather Total Number of Alerts in Database

if ($ListKeys eq 'true') {
	my @Keys;
	while (<DATA>) {
		next() if substr($_, 0, 1) eq '#';
		next() unless length();

		my @Line = split('=');
		push(@Keys, $Line[0])
	}

	foreach (sort(@Keys)) {
		say($_) unless our $Old eq $_;
		$Old = $_
	}

	exit(0)
} elsif ($ListDbAlerts eq 'true') {
	open(my $FH, '<', DATABASE) or die("$!");

	# Fetch IDs from ':' lines.
	my @IDs;
	while (<$FH>) {
		chomp();

		next() unless substr($_, 0, 1) eq ':';

		push(@IDs, split(',', substr($_, 1)));
	}

	close($FH) or die("$!");

	# Display unique IDs.
	foreach my $ID (sort({$a <=> $b} @IDs)) {
		say($ID) unless our $Old eq $ID;
		$Old = $ID
	}

	exit(0)
}

#-------------------------------------Configuration File Parsing and Generation

# Look for old file no longer used as of UbuChk 2021-01-01 version. Ideally, -
# this would be taken care of by the installer, but just in-case, check. Might
# avoid any confusion by the user, plus it's just cleaner.
if ($Verbose eq 'true' and -f DEFAULT_CONFIG_FILE) {
	say("NOTE: Found '${\DEFAULT_CONFIG_FILE}' -- see: man ${\PROGRAM}");
}

if ($ForceReset eq 'true' and -f $ConfigFile) {
	unlink($ConfigFile) or die("$!")
}

if (-f -r -T $ConfigFile) {
	my $InvalidKeyCount;

	open(my $FH, '<', $ConfigFile) or die("$!");

	while (<$FH>) {
		chomp();

		next() if substr($_, 0, 1) eq '#';
		next() unless length();

		my ($Key, $Value) = split('=');

		# If the current key was provided to the `--key|-k` option, then
		# override the user's configuration file for this key.
		$Value = $KeyOpt{$Key} if grep({$_ eq $Key} keys(%KeyOpt));

		if ($Key =~ '^Color_.*') {
			die("Err: Invalid color '$Value' detected.\n")
				unless colorvalid($Value);

			next() if $ANSIColors eq 'false';

			$ColorHash{$Key} = color($Value =~ tr/'"//dr)
		} elsif ($Key eq 'ANSIColors') {
			Boolean($Value);
			$ANSIColors = $Value
		} elsif ($Key =~ '^Char_.*') {
			if (length($Value) > 1) {
				die("Err: Invalid 'Char_*' value detected.\n")
			} elsif (not length($Value)) {
				next()
			} else {
				$Syms{$Key} = $Value =~ tr/'"//dr
			}
		} elsif ($Key eq 'KernParams') {
			Boolean($Value);
			$KernParams = $Value
		} elsif ($Key eq 'PathPerms') {
			Boolean($Value);
			$PathPerms = $Value
		} elsif ($Key eq 'SkipKP') {
			push(@SkipKP, $Value)
		} elsif ($Key eq 'SkipAPT') {
			push(@SkipAPT, $Value)
		} elsif ($Key eq 'PurgeChk') {
			Boolean($Value);
			$PurgeChk = $Value
		} elsif ($Key eq 'HardAPT') {
			die("Err: Invalid boolean '$Value' detected.\n")
				unless $Value =~ '^([01]|true|false)$';

			$HardAPT = $Value
		} elsif ($Key eq 'SSHDConfig') {
			$SSHDConfig = $Value
		} elsif ($Key eq 'SSHServer') {
			Boolean($Value);
			$SSHServer = $Value
		} elsif ($Key eq 'SSHClient') {
			Boolean($Value);
			$SSHClient = $Value
		} elsif ($Key eq 'UnwantedPKGs') {
			push(@UnwantedPKGs, $Value)
		} elsif ($Key eq 'Verbose') {
			Boolean($Value);
			$Verbose = $Value unless $Verbose eq 'true'
		} elsif ($Key eq 'UFW') {
			Boolean($Value);
			$UFW = $Value
		} elsif ($Key eq 'SystemD') {
			Boolean($Value);
			$SystemD = $Value
		} elsif ($Key eq 'KernMods') {
			Boolean($Value);
			$KernMods = $Value
		} elsif ($Key eq 'CustomKMs') {
			push(@CustomKMs, $Value)
		} elsif ($Key eq 'SkipKMs') {
			push(@SkipKMs, $Value)
		} elsif ($Key eq 'SkipIDs') {
			push(@SkipIDs, split(',', $Value))
		} elsif ($Key eq 'Recommend') {
			Boolean($Value);
			$Recommend = $Value
		} elsif ($Key eq 'DiskSpace') {
			Boolean($Value);
			$DiskSpace = $Value
		} elsif ($Key eq 'AutoQuery') {
			Boolean($Value);
			$AutoQuery = $Value
		} elsif ($Key eq 'QueryIndent') {
			if ($Value =~ /^\d+$/) {
				# Default value and its bounds are mentioned in the config.
				die("Err: Key '$Key' out of bounds.\n")
					unless $Value > 0 and $Value <= 9;

				$QueryIndent = $Value
			} else {
				die("Err: Key '$Key' requires an integer.\n");
			}
		} elsif ($Key eq 'DSLimit') {
			if ($Value =~ /^\d+$/) {
				# Default value and its bounds are mentioned in the config.
				die("Err: Key '$Key' out of bounds.\n")
					unless $Value >= 10 and $Value <= 100;

				$DSLimit = $Value
			} else {
				die("Err: Key '$Key' requires an integer.\n");
			}
		} elsif ($Key eq 'DirPerms') {
			Boolean($Value);
			$DirPerms = $Value
		} elsif ($Key eq 'SkipSysD') {
			push(@SkipSysD, $Value)
		} elsif ($Key eq 'Laptop') {
			Boolean($Value);
			$Laptop = $Value
		} elsif ($Key eq 'BatCrit') {
			if ($Value =~ /^\d+$/) {
				die("Err: Key '$Key' out of bounds.\n")
					unless $Value > 0 and $Value <= 99;

				$BatCrit = $Value
			} else {
				die("Err: Key '$Key' requires an integer.\n");
			}
		} elsif ($Key eq 'BatLow') {
			if ($Value =~ /^\d+$/) {
				die("Err: Key '$Key' out of bounds.\n")
					unless $Value > 0 and $Value <= 99;

				$BatLow = $Value
			} else {
				die("Err: Key '$Key' requires an integer.\n");
			}
		} elsif ($Key eq 'ProcVuln') {
			Boolean($Value);
			$ProcVuln = $Value
		} elsif ($Key eq 'MountHome') {
			Boolean($Value);
			$MountHome = $Value
		} elsif ($Key eq 'SkipMountOpts') {
			push(@SkipMountOpts, split(',', $Value))
		} elsif ($Key eq 'CPUTemp') {
			Boolean($Value);
			$CPUTemp = $Value
		} elsif ($Key eq 'CoreTempCrit') {
			if ($Value =~ /^\d+$/) {
				$CoreTempCrit = $Value
			} else {
				die("Err: Key '$Key' requires an integer.\n");
			}
		} elsif ($Key eq 'TempScale') {
			if ($Value eq 'C' or $Value eq 'F') {
				$TempScale = $Value
			} else {
				die("Err: Key '$Key' must be either 'F' or 'C'.\n");
			}
		} elsif ($Key eq 'AptCache') {
			Boolean($Value);
			$AptCache = $Value
		} elsif ($Key eq 'AptCacheMBLimit') {
			if ($Value =~ /^\d+$/) {
				$AptCacheMBLimit = $Value
			} else {
				die("Err: Key '$Key' requires an integer in MB.\n");
			}
		} elsif ($Key eq 'LightDM') {
			Boolean($Value);
			$LightDM = $Value
		} elsif ($Key eq 'RootKits') {
			Boolean($Value);
			$RootKits = $Value
		} elsif ($Key eq 'IgnoreFile') {
			push(@IgnoreFiles, $Value)
		} elsif ($Key eq 'HomeCache') {
			Boolean($Value);
			$HomeCache = $Value
		} elsif ($Key eq 'HomeCacheMBLimit') {
			if ($Value =~ /^\d+$/) {
				$HomeCacheMBLimit = $Value
			} else {
				die("Err: Key '$Key' requires an integer.\n");
			}
		} elsif ($Key eq 'Thumbnails') {
			Boolean($Value);
			$Thumbnails = $Value
		} elsif ($Key eq 'ThumbsMBLimit') {
			if ($Value =~ /^\d+$/) {
				$ThumbsMBLimit = $Value
			} else {
				die("Err: Key '$Key' requires an integer.\n");
			}
		} elsif ($Key eq 'DpkgConf') {
			Boolean($Value);
			$DpkgConf = $Value
		} elsif ($Key eq 'DpkgConf') {
			Boolean($Value);
			$DpkgConf = $Value
		} elsif ($Key eq 'SkipDpkgOpts') {
			push(@SkipDpkgOpts, $Value)
		} elsif ($Key eq 'Swaps') {
			Boolean($Value);
			$Swaps = $Value
		} elsif ($Key eq 'MBMaxSwap') {
			if ($Value =~ /^\d+$/) {
				$MBMaxSwap = $Value
			} else {
				die("Err: Key '$Key' requires an integer.\n");
			}
		} elsif ($Key eq 'RAM') {
			Boolean($Value);
			$RAM = $Value
		} elsif ($Key eq 'MBMaxRAM') {
			if ($Value =~ /^\d+$/) {
				$MBMaxRAM = $Value
			} else {
				die("Err: Key '$Key' requires an integer.\n");
			}
		} elsif ($Key eq 'CMOS') {
			Boolean($Value);
			$CMOS = $Value
		} elsif ($Key eq 'ChkPasswd') {
			Boolean($Value);
			$ChkPasswd = $Value
		} elsif ($Key eq 'ID0NonRoots') {
			Boolean($Value);
			$ID0NonRoots = $Value
		} elsif ($Key eq 'AppArmor') {
			Boolean($Value);
			$AppArmor = $Value
		} elsif ($Key eq 'FailedLogins') {
			Boolean($Value);
			$FailedLogins = $Value
		} elsif ($Key eq 'ShowTTL') {
			Boolean($Value);
			$ShowTTL = $Value
		} elsif ($Key eq 'SymsFileMode') {
			Boolean($Value);
			$SymsFileMode = $Value
		} elsif ($Key eq 'CPUGovernor') {
			if (length($CPUGovernor) and not grep($Value, @ValidGovs)) {
				die("Err: CPU governor '$CPUGovernor' not recognised.\n")
			}

			$CPUGovernor = $Value
		} else {
			warn("Err: Key '$Key' unknown.\n");

			$InvalidKeyCount++
		}
	}

	close($FH) or die("$!");

	exit(1) if $InvalidKeyCount > 0;

	# Because this would otherwise make no sense.
	die("Err: Key conflict with 'BatCrit' and 'BatLow'.\n")
		if $Laptop eq 'true' and $BatCrit >= $BatLow
} else {
	# Store contents into buffer, sans initial and now-unneeded Cito line.
	my @Buffer = <DATA>;
	my @Corrected = @Buffer[1..@Buffer];

	# Write to new user's-own config file.
	open(my $FH, '>', $ConfigFile) or die("$!");

	say($FH "# User configuration file for ${\PROGRAM_FANCY} (>= ${\VERSION})");
	say($FH "# Refer to ${\PROGRAM}(8) to learn about these settings.\n");
	print($FH @Corrected);

	close($FH) or die("$!");

	say("Configuration file generated -- please reload ${\PROGRAM_FANCY}.");

	exit(0)
}

if (@SkipIDs) {
	foreach (@SkipIDs) {
		die("Err: Invalid alert ID.\n")
			unless /^[[:digit:]]{4}$/
	}
}

@Installed = sort(ParseDpkgStatus('install ok installed'))
	if @UnwantedPKGs;

@NotPurged = sort(ParseDpkgStatus('deinstallokconfig-files'))
	if $PurgeChk eq 'true';

#-------------------------------------------------------------Querying an Alert

QueryAlert(0) if $Query eq 'true';

#-------------------------------------------------------------Kernel Parameters

if ($KernParams eq 'true') {
	my ($Value, $AlertID, $GoodValue, $Path, $ShowKey);

	foreach ( # [ALERT_ID] [DESIRED_VALUE] [KEY_PATH]
		'0913:1:/proc/sys/kernel/ctrl-alt-del',
		'1090:5:/proc/sys/net/ipv4/tcp_syn_retries',
		'1211:0:/proc/sys/net/ipv4/conf/all/accept_redirects',
		'1291:0:/proc/sys/net/ipv6/conf/default/accept_source_route',
		'1443:1:/proc/sys/kernel/yama/ptrace_scope',
		'1491:10:/proc/sys/vm/swappiness',
		'1821:1:/proc/sys/net/ipv4/conf/default/rp_filter',
		'2125:2048:/proc/sys/net/ipv4/tcp_max_syn_backlog',
		'2529:0:/proc/sys/net/ipv4/conf/default/send_redirects',
		'2847:1:/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses',
		'2916:0:/proc/sys/net/ipv6/conf/all/accept_redirects',
		'5434:1:/proc/sys/net/ipv4/icmp_echo_ignore_all',
		'5668:2:/proc/sys/net/ipv4/tcp_synack_retries',
		'6279:0:/proc/sys/net/ipv4/conf/default/accept_source_route',
		'6576:0:/proc/sys/net/ipv4/conf/all/accept_source_route',
		'7512:1:/proc/sys/net/ipv4/conf/all/rp_filter',
		'7536:0:/proc/sys/kernel/sysrq',
		'8560:2:/proc/sys/kernel/kptr_restrict',
		'8852:1:/proc/sys/net/ipv4/conf/all/log_martians',
		'8963:0:/proc/sys/net/ipv6/conf/all/accept_source_route',
		'9191:0:/proc/sys/net/ipv4/conf/all/send_redirects',
		'9211:2:/proc/sys/kernel/randomize_va_space',
		'9222:1:/proc/sys/net/ipv4/tcp_syncookies',
		'9623:1:/proc/sys/kernel/dmesg_restrict',
		'9992:0:/proc/sys/net/ipv4/ip_forward',
		'9993:1:/proc/sys/kernel/unprivileged_bpf_disabled',
		'9998:1:/proc/sys/fs/protected_symlinks',
		'9999:1:/proc/sys/fs/protected_hardlinks'
	) {
		($AlertID, $GoodValue, $Path) = split(':');
		$ShowKey = $Path =~ tr/\//./r =~ s/\.proc\.sys\.//r;

		next() if grep({$_ eq $ShowKey} @SkipKP);

		Info("Checking '$ShowKey' parameter.");

		if (-f $Path) {
			unless (-r $Path) {
				# Some parameters are more locked down than others.
				warn("Err: Denied access to '$ShowKey' parameter.\n");
				next()
			} elsif (-B -s $Path) {
				warn("Err: Unable to determine '$ShowKey' parameter.\n");
				next()
			}

			open(my $FH, '<', $Path) or die("$!");
			chomp($Value = <$FH>);
			close($FH) or die("$!")
		} else {
			Info("Parameter '$ShowKey' unavailable.");

			next()
		}

		Info("Parameter '$ShowKey' is '$Value'.");

		Alert(
			$AlertID,
			"Key '$ShowKey' assigned '$Value'.",
			"Recommended value is '$GoodValue'."
		) if $Value != $GoodValue
	}
} else {
	Info("Ignoring kernel parameters.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------PATH Permissions & Ownership

if ($PathPerms eq 'true') {
	if (length($ENV{'PATH'})) {
		my @AlertPerms;
		foreach (split(':', $ENV{'PATH'})) {
			Info("Looking in '$_' directory.");

			# Ignore directories added to PATH which are in HOME. Added for
			# people who would otherwise get a LOT of unnecessary alerts.
			#
			# The downside, is that `next()` will not happen if the user's HOME
			# is not in '/home', but that's highly unlikely, especially in
			# Ubuntu.
			next() if $_ =~ m/^\/home/;

			foreach (glob("$_/*")) {
				my ($Mode, $Owner, $Group) = (stat($_))[2,4,5];
				$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

				Info("File '$_' is '$Mode' and '$Owner:$Group'.")
					if $Owner > 1 and $Owner < 1000
					or $Group > 1 and $Group < 1000
					or $Mode > 000 and $Mode < 755;

				Alert(
					7869,
					"File '$_' is mode '$Mode'.",
					"Recommended mode is '755'."
				) unless $Mode <= 755;

				# These executables should not be owned by a standard user, nor
				# should they be in such a group. <1000 is for system
				# users/groups. A stricter test (make optional?) would be to
				# flag all non-0s. There are exceptions, however, such as the
				# user having his or her own `bin` directory in their `/home`
				# directory.
				Alert(
					6005,
					"File '$_' is owned by '$Owner'.",
					"Recommended owner is '0' ('root')."
				) if $Owner >= 1000;

				Alert(
					3579,
					"File '$_' is in group '$Group'.",
					"Recommended group is '0' ('root')."
				) if $Group >= 1000
			}
		}
	} else {
		# This would have to be some seriously bizarre edge-case.
		Info("Missing prerequisites -- skipping 'PathPerms' key.")
	}
} else {
	Info("Ignoring PATH permissions & ownership.")
		unless $HushIgnored eq 'true'
}

#-----------------------------------------------------Packages Yet to Be Purged

if ($PurgeChk eq 'true') {
	Info("Looking for old package remains.");

	Alert(
		6712,
		"Package '$_' wasn't purged.",
		"Suggested action is to purge the package."
	) foreach @NotPurged;

	Info('No packages were found unpurged.')
		unless @NotPurged
} else {
	Info("Ignoring any unpurged packages.")
		unless $HushIgnored eq 'true'
}

#-----------------------------------------------------------APT Security Tweaks

if ($HardAPT eq 'true') {
	if (DepChk('apt-config') == 0) {
		my %Settings;
		foreach (`apt-config dump --format '%f=%v%n' 2> /dev/null`) {
			chomp();

			next() if substr($_, 0, 1) eq '#';
			next() unless length();

			my ($Key, $Value) = split('=');
			$Value = $Value =~ tr/"';//dr;

			# APT also accepts integer booleans.
			$Value = 'false' if $Value eq '0';
			$Value = 'true' if $Value eq '1';

			$Settings{$Key} = $Value
		}

		foreach ( # [TARGET_VALUE] [KEY]
			'6135|6131|Recommended|false|APT::Get::AllowUnauthenticated',
			'6136|6132|Recommended|false|Acquire::http::AllowRedirect',
			'6137|6133|Recommended|false|APT::Install-Suggests',
			'6138|6134|Suggested|false|APT::Install-Recommends'
		) {
			my ($AlertID1, $AlertID2, $RecSug, $Target, $Key) = split('\|');

			next() if grep({$_ eq $Key} @SkipAPT);

			my $Word = 'enabled' if $Settings{$Key} eq 'true';
			$Word = 'disabled' if $Settings{$Key} eq 'false';

			my $Integer = 0 if $Target eq 'false';
			$Integer = 1 if $Target eq 'true';

			unless (exists($Settings{$Key})) {
				Alert(
					$AlertID1,
					"APT key '$Key' is unassigned.",
					"$RecSug action is to assign it '$Target' or '$Integer'."
				)
			} elsif ($Settings{$Key} ne $Target) {
				Alert(
					$AlertID2,
					"APT key '$Key' is $Word.",
					"$RecSug value is '$Target' or '$Integer'."
				)
			} else {
				Info("Key '$Key' is $Word.");
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'HardAPT' key.")
	}
} else {
	Info("Ignoring APT configuration.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------------------SSH Client

if ($SSHClient eq 'true') {
	my $SSHDir = "$ENV{HOME}/.ssh";

	if (-d $SSHDir) {
		die("Err: Directory '$SSHDir' unreadable.\n")
			unless -r $SSHDir;

		die("Err: Directory '$SSHDir' unexecutable.\n")
			unless -x $SSHDir;

		my ($Mode, $Owner, $Group) = (stat($SSHDir))[2,4,5];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		Alert(
			5431,
			"Directory '$SSHDir' is mode '$Mode'.",
			"Recommended mode is '700'."
		) unless $Mode == 700;

		Alert(
			5438,
			"Directory '$SSHDir' is owned by '$Owner'.",
			"Recommended UID is '${\USER_ID}'."
		) unless $Owner == USER_ID;

		Alert(
			5439,
			"Directory '$SSHDir' is in group '$Group'.",
			"Recommended GID is '${\GROUP_ID}'."
		) unless $Group == GROUP_ID;
	} else {
		Info("Missing prerequisites -- skipping 'SSHClient' key.")
	}
} else {
	Info("Ignoring SSH permissions & settings.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------------------SSH Server

if ($SSHServer eq 'true') {
	if (-f $SSHDConfig) {
		die("Err: File '$SSHDConfig' unreadable.\n")
			unless -r $SSHDConfig;

		# Without the `-s` flag, zero-size files get flagged as binary.
		die("Err: File '$SSHDConfig' is binary.\n") if -B -s $SSHDConfig;

		FileChk($SSHDConfig);
		open(my $FH, '<', $SSHDConfig) or die("$!");

		my %Settings;
		while (<$FH>) {
			chomp();

			next() if substr($_, 0, 1) eq '#';
			next() unless length();

			my ($Key, $Value) = split(' ');

			Info("Key '$Key' is '$Value'.");

			$Settings{$Key} = $Value
		}

		close($FH) or die("$!");

		foreach ( # [ALERT_ID_1] [ALERT_ID_2] [TARGET_VALUE] [KEY]
			'6990|6980|no|PermitRootLogin',
			'6991|6992|2|Protocol',
			'6996|6993|no|PermitEmptyPasswords',
			'6997|6994|no|PasswordAuthentication',
			'6998|6995|no|X11Forwarding'
		) {
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next() if grep({$_ eq $Key} @SkipAPT);

			unless (exists($Settings{$Key})) {
				Alert(
					$AlertID1,
					"SSH daemon key '$Key' may not be assigned.",
					"Recommended action is to assign it '$Target'."
				)
			} elsif ($Settings{$Key} ne $Target) {
				Alert(
					$AlertID2,
					"SSH daemon key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}

		# Ordinarily, you shouldn't use the commonplace `22` port.
		unless (exists($Settings{'Port'})) {
			Alert(
				7541,
				"SSH daemon key 'Port' may not be assigned.",
				"Recommended action is NOT to assign it '22'."
			)
		} elsif ($Settings{'Port'} == 22) {
			Alert(
				6542,
				"SSH daemon key 'Port' assigned '$Settings{Port}'.",
				"Recommended value is one other than '22'."
			)
		}
	} else {
		Info("Missing prerequisites -- skipping 'SSHServer' key.")
	}
} else {
	Info("Ignoring whether SSH server is present.")
		unless $HushIgnored eq 'true'
}

#---------------------------------------------------------Packages Best Avoided

if (@UnwantedPKGs) {
	foreach my $CurPKG (@UnwantedPKGs) {
		Info("Looking for '$CurPKG' package.");

		Alert(
			5656,
			"Package(s) matching '$CurPKG' installed.",
			"Suggested consideration of uninstallation."
		) if grep({($_ =~ m{(.*)(?::.*)})[0] eq $CurPKG} @Installed)
	}
} else {
	Info("Ignoring any unwanted packages.") unless $HushIgnored eq 'true'
}

#----------------------------------------------------------------SystemD Tweaks

if ($SystemD eq 'true') {
	my $SDConfig = '/etc/systemd/system.conf';

	if (-f $SDConfig) {
		FileChk($SDConfig);
		open(my $FH, '<', $SDConfig) or die("$!");

		my %Settings;
		while (<$FH>) {
			chomp();

			next() if substr($_, 0, 1) eq '#';
			next() if $_ eq '[Manager]';
			next() unless length();

			my ($Key, $Value) = split('=');

			Info("Key '$Key' is '$Value'.");

			$Settings{$Key} = $Value
		}

		close($FH) or die("$!");

		foreach ( # [TARGET_VALUE] [KEY]
			'1411|1415|1024|DefaultLimitNPROC',
			'1412|1416|1024|DefaultLimitNOFILE',
			'1413|1417|no|CrashShell',
			'1414|1418|no|DumpCore'
		) {
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next() if grep({$_ eq $Key} @SkipSysD);

			unless (exists($Settings{$Key})) {
				Alert(
					$AlertID1,
					"SystemD key '$Key' may not be assigned.",
					"Recommended action is to assign it '$Target'."
				)
			} elsif ($Settings{$Key} ne $Target) {
				Alert(
					$AlertID2,
					"SystemD key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'SystemD' key.")
	}
} else {
	Info("Ignoring SystemD-related tweaks.") unless $HushIgnored eq 'true'
}

#----------------------------------------------------------------Kernel Modules

if ($KernMods eq 'true') {
	if (-f PROC_MODS_FILE) {
		FileChk(PROC_MODS_FILE);
		open(my $FH, '<', PROC_MODS_FILE) or die("$!");

		my @Modules;
		while (<$FH>) {
			chomp();

			my @Line = split(' ');

			push(@Modules, $Line[0])
		}

		close($FH) or die("$!");

		foreach (
			'1274|mei',
			'1275|mei_me',
			'1276|mei_wtk',
			'7416|joydev',
			'8471|psmouse'
		) {
			my ($AlertID, $Module) = split('\|');

			if (grep({$_ eq $Module} @Modules)) {
				unless (grep({$_ eq $Module} @SkipKMs)) {
					Info("Module '$Module' found but ignored.");
					next # <-- Skipping the below alert.
				}

				Alert(
					$AlertID,
					"Module '$Module' discovered and live.",
					"Recommended action is to blacklist the module."
				)
			} else {
				Info("Module '$Module' not found.")
			}
		}

		foreach my $Mod (@CustomKMs) {
			Alert(
				8189,
				"Module '$Mod' discovered and live.",
				"Recommended action is to blacklist the module."
			) if grep({$_ eq $Mod} @Modules)
		}
	} else {
		Info("Missing prerequisites -- skipping 'KernMods' key.")
	}
} else {
	Info("Ignoring kernel modules.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------Check Filesystem Sizes

if ($DiskSpace eq 'true') {
	if (-f MOUNT_FILE) {
		FileChk(MOUNT_FILE);
		open(my $FH, '<', MOUNT_FILE) or die("$!");

		while (<$FH>) {
			chomp(my @Arr = split());

			# Using this REGEX over just '^/' avoids statfs errors.
			if ($Arr[0] =~ '^/dev/(sd|hd|fd)[[:alpha:]]+[[:digit:]]+$') {
				# Avoids `not a directory` error, for EFI setups.
				next() if $Arr[1] eq '/boot/efi';
				next() unless -b $Arr[0];

				Info("Looking at '$Arr[0]' partition.");

				our $Mount = $Arr[1] =~ s/\\040/ /gr;
				our ($Used, $Free) = (df($Mount))[2,3] or next();
				($Used, $Free) = ($Used * 1024, $Free * 1024);
				our $Size = $Free + $Used;
				our $Perc = int(($Used / $Size) * 100);

				if ($Perc >= $DSLimit) {
					Alert(4612,
						"Partition '$Arr[0]' is $Perc% full.",
						"Recommended action is to clear out junk."
					)
				} else {
					Info("Partition '$Arr[0]' is using $Perc% of space.");
				}
			}
		}

		close($FH) or die("$!");
	} else {
		Info("Missing prerequisites -- skipping 'DiskSpace' key.")
	}
} else {
	Info("Ignoring disk space availability.") unless $HushIgnored eq 'true'
}

#----------------------Specific File & Directory Permissions, Group & Ownership

if ($DirPerms eq 'true') {
	foreach ( # [ALERTID] [MODE] [UID] [GID]
		"5440:700:${\USER_ID}:${\GROUP_ID}:$ENV{HOME}",
		'5436:700:0:0:/boot',
		'5446:700:0:0:/root'
	) {
		my ($AlertID, $TargetMode, $TargetUID, $TargetGID, $Path) = split(':');

		next unless -d $Path;

		Info("Looking at '$Path' directory.");

		my ($Mode, $Owner, $Group) = (stat($Path))[2,4,5];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		Alert(
			$AlertID,
			"Directory '$Path' is mode '$Mode'.",
			"Recommended mode is '$TargetMode'."
		) unless $Mode == $TargetMode;

		Alert(
			$AlertID,
			"Directory '$Path' is owned by '$Owner'.",
			"Recommended UID is '$TargetUID'."
		) unless $Owner == $TargetUID;

		Alert(
			$AlertID,
			"Directory '$Path' is in group '$Group'.",
			"Recommended GID is '$TargetGID'."
		) unless $Group == $TargetGID;
	}
} else {
	Info("Ignoring special file permissions & ownership.")
		unless $HushIgnored eq 'true'
}

#-----------------------------------------------------------------Laptop Checks

if ($Laptop eq 'true') {
	my $AdapOnline;
	if (-f PS_TYPE_FILE) {
		FileChk(PS_TYPE_FILE);
		open(my $FH, '<', PS_TYPE_FILE) or die("$!");
		chomp(my $AdapType = <$FH>);
		close($FH) or die("$!");

		if ($AdapType eq 'Mains') {
			FileChk(PS_ONLINE_FILE);
			open(my $FH, '<', PS_ONLINE_FILE) or die("$!");
			chomp($AdapOnline = <$FH>);
			close($FH) or die("$!");

			if ($AdapOnline == 0) {
				Info("Device is NOT plugged in.")
			} else {
				Info("Device is plugged in.")
			}
		}
	}

	if (-d PS_BASE_DIR) { # <-- Ensure at least one battery exists.
		foreach (glob(PS_BASE_DIR . '/BAT[1-9]')) {
			my $BatFile = "$_/capacity";
			my $KNowFile = "$_/charge_now";
			my $KMaxFile = "$_/charge_full_design";

			if (-f $BatFile) {
				FileChk($BatFile);
				open(my $FH, '<', $BatFile) or die("$!");
				chomp(my $BatPerc = <$FH>);
				close($FH) or die("$!");

				my $Battery = $BatFile =~ s/.*\/BAT([[:digit:]]+)\/capacity$/$1/r;

				my ($KNow, $KMax);
				if (-f $KNowFile and -f $KMaxFile) {
					FileChk($KNowFile);
					open(my $FH, '<', $KNowFile) or die("$!");
					chomp($KNow = substr(<$FH>, 0, length($KNow) - 4));
					close($FH) or die("$!");

					FileChk($KMaxFile);
					open($FH, '<', $KMaxFile) or die("$!");
					chomp($KMax = substr(<$FH>, 0, length($KMax) - 4));
					close($FH) or die("$!");
				}

				if ($BatPerc <= $BatCrit) {
					Alert(
						2850,
						"Battery #$Battery critical at $BatPerc% ($KNow mAh) capacity.",
						"Save your work and shut down the computer."
					) unless $AdapOnline == 1
				} elsif ($BatPerc <= $BatLow) {
					if (length($KMax) > 0 and length($KNow) > 0) {
						Alert(
							2849,
							"Battery #$Battery low at $BatPerc% ($KNow mAh) capacity.",
							"Suggested action is to charge the battery."
						) unless $AdapOnline == 1
					} else {
						Alert(
							2849,
							"Battery #$Battery low at $BatPerc% capacity.",
							"Suggested action is to charge the battery."
						) unless $AdapOnline == 1
					}
				} else {
					if (length($KMax) > 0 and length($KNow) > 0) {
						Info("Battery #$Battery still has $BatPerc% at $KNow mAh power.")
					} else {
						Info("Battery #$Battery still has $BatPerc% power left.")
					}
				}
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'Laptop' key.")
	}
} else {
	Info("Ignoring tweaks for a portable machine.")
		unless $HushIgnored eq 'true'
}

#------------------------------------------------------CPU Marked as Vulnerable

if ($ProcVuln eq 'true') {
	if (-d CPU_VULN_DIR) {
		die("Err: Directory '${\CPU_VULN_DIR}' unreadable.\n")
			unless -r CPU_VULN_DIR;

		die("Err: Unable to open '${\CPU_VULN_DIR}' directory.\n")
			unless -x CPU_VULN_DIR;

		foreach (glob(CPU_VULN_DIR . '/*')) {
			next() unless -f;

			my $Vuln = ($_ =~ m{(?:.*/)(.*)})[0];

			Info("Checking CPU for vulnerability to $Vuln.");

			FileChk($_);
			open(my $FH, '<', $_) or die("$!");
			chomp(my $Data = <$FH>);
			close($FH) or die("$!");

			if ($Data =~ /Vulnerable/i) {
				Alert(
					4811,
					"CPU marked as vulnerable to $Vuln.",
					"Don't panic -- refer to: ${\PROGRAM} -Q 4811"
				)
			} elsif ($Data =~ /Not affected/i) {
				Info("Unaffected by $Vuln vulnerability.")
			} elsif ($Data =~ /Mitigation/i) {
				Info("Vulnerability $Vuln mitigated.")
			} else {
				Alert(
					4812,
					"Unrecognised vulnerability status to $Vuln.",
					"Don't panic -- refer to: ${\PROGRAM} -Q 4812"
				)
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'ProcVuln' key.")
	}
} else {
	Info("Ignoring any CPU vulnerabilities.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------Mount Options for HOME

if ($MountHome eq 'true') {
	if (-f MOUNT_FILE) {
		FileChk(MOUNT_FILE);
		open(my $FH, '<', MOUNT_FILE) or die("$!");

		my ($Device, $Options);
		while (<$FH>) {
			chomp(my @Arr = split(' '));

			# Using this REGEX over just '^/' avoids statfs errors.
			if ($Arr[1] eq '/home') {
				($Device, $Options) = @Arr[0,3];
				last()
			}
		}

		close($FH) or die("$!");

		if (length($Device) > 0) {
			Info("Mountpoint '/home' points to '$Device'.");

			my @OptArr = split(',', $Options);
				my ($AlertID, $Option) = split(',');

			foreach (
				'1356,noexec',
				'1357,nodev',
				'1358,nosuid'
			) {
				my ($AlertID, $Option) = split(',');

				if (grep({$_ eq $Option} @SkipMountOpts)) {
					Info("Module '$Option' found but ignored.");
					next() # <-- Skipping the below alert.
				}

				if (grep({$_ eq $Option} @OptArr)) {
					Info("Mount option '$Option' for '/home' is set.")
				} else {
					Alert($AlertID,
						"Missing mount option '$Option' for '/home'.",
						"Please refer to: ${\PROGRAM} -Q $AlertID"
					)
				}
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'MountHome' key.")
	}
} else {
	Info("Ignoring any HOME mount options.") unless $HushIgnored eq 'true'
}

#---------------------------------------------------------CPU Core Temperatures

# There are several ways to get the system's CPU temperature(s), without
# dragging in another program, but for now, I'll program for this particular
# method, adding additional ones as issues are reported.
if ($CPUTemp eq 'true') {
	my $Dir;
	if (-d '/sys/devices/platform/coretemp.0/hwmon/hwmon3') {
		$Dir = '/sys/devices/platform/coretemp.0/hwmon/hwmon3'
	} elsif (-d '/sys/class/hwmon/hwmon1') {
		$Dir = '/sys/class/hwmon/hwmon1'
	} else {
		Info("Missing prerequisites -- skipping 'CPUTemp' key.")
	}

	if (defined($Dir)) {
		die("Err: Directory '$Dir' unreadable.\n")
			unless -r $Dir;

		die("Err: Directory '$Dir' unexecutable.\n")
			unless -x $Dir;

		# Gather a hash of (only) the core temperatures.
		my (%TempData, $Temp);
		foreach (glob("$Dir/temp*")) {
			next() unless -f and m{/temp[[:digit:]]+_(input|label)$};

			FileChk($_);
			open(my $FH, '<', $_) or die("$!");
			chomp(my $Data = <$FH>);
			close($FH) or die("$!");

			# The files are ordered from input to label, so we need to process
			# it backwards, otherwise the output would be borked.
			if (/_input$/) {
				$Temp = $Data
			} elsif (/_label$/) {
				$TempData{$Data} = $Temp
			}
		}

		# Begin checking on each of the core temperatures, per the above hash.
		foreach (sort({$a cmp $b} keys(%TempData))) {
			next() unless /^Core [[:digit:]]+$/;

			# Initially, this value is in Celsius (unconfirmed).
			my $TempInt = CelsFahr(
				$TempScale, substr($TempData{$_},
				0, length($TempData{$_}) - 3)
			);

			my $TempStr = "$TempIntÂ°$TempScale";
			my $CoreInt = (m{(?:.* )(.*)})[0];

			# Ensure the right suffix for 1'st', 2'nd', 3'rd', and N'th'.
			my $CoreStr = Suffix($CoreInt);

			if ($TempInt >= $CoreTempCrit) {
				Alert(
					6237,
					"CPU's $CoreStr core critical at $TempStr.",
					"Suggested action is to improve system cooling."
				)
			} else {
				Info("CPU core #$CoreInt stable at $TempStr.")
			}
		}
	}
} else {
	Info("Ignoring CPU temperatures.") unless $HushIgnored eq 'true'
}

#----------------------------------------------------------APT Cache Disk Usage

if ($AptCache eq 'true') {
	if (-d APT_ARCHIVES_DIR) {
		# Ignoring `partial` directory, as it often needs root access to use.
		# The same goes for files like `lock`, as they're irrelevant here.
		my ($FileCount, $Size);
		foreach (glob(APT_ARCHIVES_DIR . '/*.deb')) {
			$Size += -s;
			$FileCount++;

			if ($Verbose eq 'true') {
				my $Human = Human($Size);
				my $BaseName = ($_ =~ m{(?:.*/)(.*)})[0];

				Info("Found '$BaseName', using $Human.");
			}
		}

		if ($Size > 0) {
			my $Human = Human($Size);
			if ($Size / 1024 / 1024 >= $AptCacheMBLimit) {
				unless (DepChk('sudo')) {
					Alert(
						9708,
						"Found $FileCount cached Debian packages, totalling $Human.",
						"Suggested action is to run: sudo apt-get clean"
					);
				} else {
					Alert(
						9708,
						"Found $FileCount cached Debian packages, totalling $Human.",
						"Suggested action is to, as root, run: apt-get clean"
					);
				}
			} else {
				Info("Cached Debian packages take up only $Human.");
			}
		} else {
			Info("Found no cached Debian packages.");
		}
	} else {
		Info("Missing prerequisites -- skipping 'AptCache' key.")
	}
} else {
	Info("Ignoring APT cache disk usage.") unless $HushIgnored eq 'true'
}

#-----------------------------------------------------------------------LightDM

if ($LightDM eq 'true') {
	if (-f LDM_CONFIG_FILE) {
		FileChk(LDM_CONFIG_FILE);
		open(my $FH, '<', LDM_CONFIG_FILE) or die("$!");

		my $AllowGuest;
		while (<$FH>) {
			chomp();

			# Correct, at least in Ubuntu 16.04.6 base. Ubuntu 18.04.4 seems to
			# not use this file by default, but it can still be found at:
			#
			#  /usr/share/lightdm/lightdm.conf.d/50-disable-guest.conf
			#
			if (/(^| )allow-guest=true( |$)/) {
				$AllowGuest = 'true'; last
			} elsif (/(^| )allow-guest=false( |$)/) {
				$AllowGuest = 'false'; last
			}
		}

		close($FH) or die("$!");

		if ($AllowGuest eq 'true') {
			Alert(
				9188,
				'Guest logins are allowed with LightDM.',
				'Recommended action is to disable guest logins.'
			);
		} elsif ($AllowGuest eq 'false') {
			Info('LightDM does not permit guest logins.')
		} else {
			Alert(
				9188,
				'Guest logins may be allowed with LightDM.',
				"Recommended action is to ensure it's disabled."
			);
		}
	} else {
		Info("Missing prerequisites -- skipping 'LightDM' key.")
	}
} else {
	Info("Ignoring any LightDM configurations.")
		unless $HushIgnored eq 'true'
}

#----------------------------------------------------------RootKits, Worms, etc

# This section is based on information from this GitHub repository:
#
#   https://github.com/ossec/ossec-hids
#
# Also inspired by various checks made by rkhunter(8).
if ($RootKits eq 'true') {
	die("Err: File '${\RK_DATABASE}' not found.\n")
		unless -f RK_DATABASE;

	die("Err: File '${\RK_DATABASE}' unreadable.\n")
		unless -r RK_DATABASE;

	open(my $FH, '<', RK_DATABASE) or die("$!");
	my @DBData = <$FH>;
	close($FH) or die("$!");

	foreach my $Line (@DBData) {
		my ($AlertID, $Name);

		chomp($Line);

		next() if $Line =~ '^#';
		if ($Line =~ '^:') {
			($AlertID, $Name) = (split(':', $Line))[1..2];
			Info("Searching: $Name");
		} elsif (length($Line) > 0) {
			next() unless -e $Line =~ tr/_/ /r;

			Alert(
				$AlertID,
				"Found: $Line",
				"File associated with $Name."
			) unless grep({$_ eq $Line} @IgnoreFiles)
		}
	}
} else {
	Info("Ignoring rootkits, detected or not.") unless $HushIgnored eq 'true'
}

#------------------------------------------------------------------User's Cache

if ($HomeCache eq 'true') {
	if (-d USER_CACHE_DIR) {
		my $Size = GetDirSize(USER_CACHE_DIR);
		if ($Size) {
			my $SizeMB = int($Size / (1024 * 1024));
			my $Human = Human($Size);
			if ($SizeMB >= $HomeCacheMBLimit) {
				Alert(
					7619,
					"User '$ENV{USER}' has a cache total of $Human.",
					"Suggested action is to remove unneeded files."
				)
			} else {
				Info("User '$ENV{USER}' caches only $Human.")
			}
		} else {
			Info("User '$ENV{USER}' directory '~/.cache' is empty.")
		}
	} else {
		Info("Missing prerequisites -- skipping 'HomeCache' key.")
	}
} else {
	Info("Ignoring user's own general cache.") unless $HushIgnored eq 'true'
}

#-------------------------------------------------------------User's Thumbnails

if ($Thumbnails eq 'true') {
	if (-d USER_THUMB_DIR) {
		my $Size = GetDirSize(USER_THUMB_DIR);
		if ($Size) {
			my $SizeMB = int($Size / 1024 / 1024);
			my $Human = Human($Size);
			if ($SizeMB >= $ThumbsMBLimit) {
				Alert(
					7620,
					"User '$ENV{USER}' has a thumbnails total of $Human.",
					"Suggested action is to remove unneeded files."
				)
			} else {
				Info("User '$ENV{USER}' thumbnails take up only $Human.")
			}
		} else {
			Info("User '$ENV{USER}' directory '~/.thumbnails' is empty.")
		}
	} else {
		Info("Missing prerequisites -- skipping 'Thumbnails' key.")
	}
} else {
	Info("Ignoring user's own thumbnail cache.") unless $HushIgnored eq 'true'
}

#------------------------------------------------------------DPKG Configuration

if ($DpkgConf eq 'true') {
	if (-f DPKG_CONFIG_FILE) {
		FileChk(DPKG_CONFIG_FILE);
		open(my $FH, '<', DPKG_CONFIG_FILE) or die("$!");

		my ($FoundNoDebSig, $FoundLog);
		while (<$FH>) {
			chomp();
			next() if /^(#|$)/;

			$FoundNoDebSig = 'true' if /^no-debsig($|[[:space:]]+.*)/;
			$FoundLog = 'true' if /^log /;
		}

		close($FH) or die("$!");

		my $ChkStatus = grep({$_ eq 'no-debsig'} @SkipDpkgOpts);
		unless ($FoundNoDebSig eq 'true' and not $ChkStatus) {
			Alert(
				3790,
				"Potentially-unsupported 'debsig' not disabled.",
				"Recommended action is to verify it's supported."
			)
		} else {
				Info("Configuration value 'no-debsig' found.");
		}

		$ChkStatus = grep({$_ eq 'log'} @SkipDpkgOpts);
		unless ($FoundLog eq 'true' and not $ChkStatus) {
			Alert(
				3791,
				"Status changes and actions not being logged by DPKG.",
				"Recommended action is to enable this feature."
			)
		} else {
				Info("Configuration value 'log' found.");
		}
	} else {
		Info("Missing prerequisites -- skipping 'DpkgConf' key.")
	}
} else {
	Info("Ignoring any DPKG configurations.") unless $HushIgnored eq 'true'
}

#-------------------------------------------------------------------------Swaps

if ($Swaps eq 'true') {
	if (-f SWAPS_FILE) {
		FileChk(SWAPS_FILE);
		open(my $FH, '<', SWAPS_FILE) or die("$!");

		my (@Swaps, $SwapCount);
		while (<$FH>) {
			chomp();

			# Skip header.
			next() if $. == 1;

			my ($File, $Type, $Size, $Used, $Priority) = split(' ');
			my $HumSize = Human($Size * 1024);
			my $HumUsed = Human($Used * 1024);
			my $MRemains = int(($Size - $Used) / 1024);

			if ($Type eq 'file') {
				my ($Mode, $Owner, $Group) = (stat($File))[2,4,5];
				$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

				Alert(
					6232,
					"File '$File' is mode '$Mode'.",
					"Recommended mode is '600'."
				) unless $Mode == 600;

				Alert(
					6233,
					"File '$File' is owned by '$Owner'.",
					"Recommended UID is '0'."
				) unless $Owner == 0;

				Alert(
					6234,
					"File '$File' is in group '$Group'.",
					"Recommended GID is '0'."
				) unless $Group == 0;
			}

			# Just in-case the file is in the user's HOME.
			$File = $File =~ s/$ENV{HOME}/~/r;

			if ($MRemains >= $MBMaxSwap) {
				Info("Swap $Type '$File' using $HumUsed/$HumSize.");
			} else {
				my $HumRemains = Human(($Size - $Used) * 1024);

				Alert(
					8759,
					"Only $HumRemains left on '$File' $Type.",
					"Suggested action is to increase swap size."
				)
			}

			$SwapCount++
		}

		if ($SwapCount) {
			Info("System has $SwapCount active swap areas.")
		} elsif (not $SwapCount) {
			Alert(
				8760,
				"Detected no assigned swap space on the system.",
				"Suggested action is to add a swap file or partition."
			)
		}

		close($FH) or die("$!")
	} else {
		Info("Missing prerequisites -- skipping 'Swaps' key.")
	}
} else {
	Info("Ignoring any Swap configurations.") unless $HushIgnored eq 'true'
}

#---------------------------------------------------------------------------RAM

if ($RAM eq 'true') {
	if (-f MEMINFO_FILE) {
		FileChk(MEMINFO_FILE);
		open(my $FH, '<', MEMINFO_FILE) or die("$!");

		my (
			$BShared, $BSwap, $BTotal, $BFree,
			$BCache, $HumFree, $BSRec, $BBuf
		);

		while (<$FH>) {
			chomp(my @Line = split(' '));

			if ($Line[0] eq 'MemTotal:') {
				$BTotal = $Line[1] * 1024
			} elsif ($Line[0] eq 'MemFree:') {
				$BFree = $Line[1] * 1024
			} elsif ($Line[0] eq 'Buffers:') {
				$BBuf = $Line[1] * 1024
			} elsif ($Line[0] eq 'Cached:') {
				$BCache = $Line[1] * 1024
			} elsif ($Line[0] eq 'Shmem:') {
				$BShared = $Line[1] * 1024
			} elsif ($Line[0] eq 'SwapTotal:') {
				$BSwap = $Line[1] * 1024
			} elsif ($Line[0] eq 'SReclaimable:') {
				$BSRec = $Line[1] * 1024
			}
		}

		close($FH) or die("$!");

		my $HumTotal = Human($BTotal);

		# Ignore shared memory, buffers, and cache, similar to htop(1).
		my $BUsed = ($BTotal - $BFree) - ($BBuf + $BCache + $BSRec);

		# As the free(1) utility shows by default.
		my $MUsed = int($BUsed / (1024 * 1024));
		my $HumUsed = Human($BUsed);

		if ($MUsed <= $MBMaxRAM) {
			Info("Using only $HumUsed of $HumTotal available RAM.")
		} else {
			Alert(
				8971,
				"Using $HumUsed of $HumTotal available RAM.",
				"Please refer to: ${\PROGRAM} -Q 8971"
			)
		}
	} else {
		Info("Missing prerequisites -- skipping 'RAM' key.")
	}
} else {
	Info("Ignoring RAM availability.") unless $HushIgnored eq 'true'
}

#------------------------------------------------------------------CMOS Battery

if ($CMOS eq 'true') {
	if (-f RTC_FILE) {
		open(my $FH, '<', RTC_FILE) or die("$!");

		my $BatStatus;
		while (<$FH>) {
			chomp();
			my @Line = split(': ');
			$BatStatus = $Line[1]
		}

		close($FH) or die("$!");

		if ($BatStatus eq 'okay') {
			Info("CMOS battery appears to be OK.")
		} else {
			Alert(
				1118,
				"Detected a non-'okay' CMOS battery status.",
				"Recommended action is to physically check it."
			)
		}
	} else {
		Info("Missing prerequisites -- skipping 'CMOS' key.")
	}
} else {
	Info("Ignoring any CMOS battery.") unless $HushIgnored eq 'true'
}

#-------------------------------------------------------------------/etc/passwd

if ($ChkPasswd eq 'true') {
	if (-f PASSWD_FILE) {
		open(my $FH, '<', PASSWD_FILE) or die("$!");

		my ($WormFound, @Roots);
		while (<$FH>) {
			$WormFound = $. if /w0rm/;

			if ($ID0NonRoots eq 'true') {
				chomp(my @Line = split(':'));

				if ($Line[2] == 0 or $Line[3] == 0) {
					push(@Roots, $Line[0]) unless grep({$_ eq $Line[0]} @Roots);
				}
			}
		}

		close($FH) or die("$!");

		unless (length($WormFound) > 0) {
			Info("Cannot see 'w0rm' in '${\PASSWD_FILE}' file.")
		} else {
			Alert(
				1428,
				"Found 'w0rm' on line #$WormFound in '${\PASSWD_FILE}' file.",
				"Please refer to a search engine."
			)
		}

		if ($ID0NonRoots eq 'true') {
			unless (@Roots > 1) {
				Info("Just 'root' with '0:0' found in '${\PASSWD_FILE}' file.")
			} else {
				if (@Roots > 1) {
					my ($Wording1, $Wording2);
					if (@Roots == 2) {
						$Wording1 = 'user';
						$Wording2 = 'this user is'
					} else {
						$Wording1 = 'users';
						$Wording2 = 'these users are'
					}

					Alert(
						9848,
						"Non-root $Wording1 with '0' UID/GID in '${\PASSWD_FILE}' file.",
						"Recommended action is to confirm $Wording2 legitimate."
					);

					foreach (@Roots) {
						Info("User '$_' has '0' UID/GID.") unless $_ eq 'root'
					}
				}
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'ChkPasswd' key.");

		Info("Missing prerequisites -- skipping 'ID0NonRoots' key.")
			if $ID0NonRoots eq 'true'
	}
} else {
	Info("Ignoring system's passwd file.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------SystemD Units/Services

if ($UFW eq 'true') {
	if (DepChk('systemctl') == 0) {
		chomp(my $Active = `systemctl is-active ufw 2> /dev/null`);
		unless ($Active eq 'active') {
			Alert(
				5541,
				"UFW is installed but its service inactive.",
				"Recommended action is to start the UFW service."
			)
		} else {
			Info('The UFW service is active.')
		}

		chomp(my $Enabled = `systemctl is-enabled ufw 2> /dev/null`);
		unless ($Enabled eq 'enabled') {
			Alert(
				5542,
				"UFW is installed but its service disabled.",
				"Recommended action is to enable the UFW service."
			)
		} else {
			Info('The UFW service is enabled.')
		}
	} else {
		Info("Missing prerequisites -- skipping 'UFW' key.")
	}
} else {
	Info("Ignoring any installations of UFW.") unless $HushIgnored eq 'true'
}

if ($AppArmor eq 'true') {
	if (DepChk('systemctl') == 0) {
		chomp(my $Active = `systemctl is-active apparmor 2> /dev/null`);
		unless ($Active eq 'active') {
			Alert(
				1298,
				"AppArmor is installed but its service inactive.",
				"Recommended action is to start the AppArmor service."
			)
		} else {
			Info('The AppArmor service is active.')
		}

		chomp(my $Enabled = `systemctl is-enabled apparmor 2> /dev/null`);
		unless ($Enabled eq 'enabled') {
			Alert(
				1299,
				"AppArmor is installed but its service disabled.",
				"Recommended action is to enable the AppArmor service."
			)
		} else {
			Info('The AppArmor service is enabled.')
		}
	} else {
		Info("Missing prerequisites -- skipping 'AppArmor' key.")
	}
} else {
	Info("Ignoring any installations of AppArmor.")
		unless $HushIgnored eq 'true'
}

#---------------------------------------------------------Failed Login Attempts

if ($FailedLogins eq 'true') {
	if (-f FAILLOG_FILE) {
		unless (-s FAILLOG_FILE) {
			Alert(
				2223,
				'Detected possible failed login attempts.',
				'Please execute the faillog(8) command.'
			)
		} else {
			Info('No failed login attempts detected.')
		}
	} else {
		Info("Missing prerequisites -- skipping 'FailedLogins' key.")
	}
} else {
	Info("Ignoring any failed login attempts.") unless $HushIgnored eq 'true'
}

#-----------------------------------------------Check for '/proc/kallsyms' Mode

if ($SymsFileMode eq 'true') {
	if (-f SYMS_FILE) {
		my $Mode = (stat(SYMS_FILE))[2];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		if ($Mode == 400) {
			Info("Mode '400' set for '${\SYMS_FILE}'.")
		} else {
			Alert(
				8128,
				"Mode for '${\SYMS_FILE}' file found.",
				"Recommended mode is '400'."
			)
		}
	} else {
		Info("Missing prerequisites -- skipping 'SymsFileMode' key.")
	}
} else {
	Info("Ignoring mode of '${\SYMS_FILE}' file.") unless $HushIgnored eq 'true'
}

#----------------------------------------------Check CPU Governor Is As Desired

# Tested and working with 1 CPU on 5.17.2 of Linux.
if (length($CPUGovernor)) {
	my (%Governors, $FoundFile);
	foreach my $Dir (glob(CPU_GOV_DIR . '/*')) {
		next() unless -d $Dir;

		foreach my $File ("$Dir/cpufreq/scaling_governor") {
			next() unless -f $File;

			$FoundFile = 'true';

			my $Core = ($Dir =~ m{(?:^.*/cpu)(\d+$)})[0];
			$Governors{$Core} = SlurpFile($File);
		}
	}

	if ($FoundFile eq 'true') {
		foreach (sort({$a <=> $b} keys(%Governors))) {
			Info("CPU Core #$_ using '$Governors{$_}' governor.");

			unless ($Governors{$_} eq $CPUGovernor) {
				Alert(
					2623,
					"CPU Core #$_ using '$Governors{$_}' governor.",
					"Configured to prefer '$CPUGovernor'."
				)
			}
		}
	} else {
		Info("Missing prerequisites -- skipping 'CPUGovernor' key.")
	}
} else {
	Info("Ignoring CPU governors.") unless $HushIgnored eq 'true'
}

#------------------------------------------------------------------------Finish

if ($ShowTTL eq 'true') {
	print(
		$ColorHash{'Color_AlertTTLText'} . "Alerted " . color('reset') .
		$ColorHash{'Color_AlertTTL'} . "$AlertCount" . color('reset') .
		$ColorHash{'Color_AlertTTLText'} . " time(s).\n" . color('reset')
	) if $AlertCount;
} else {
	Info("Omitting display of total number of alerts.")
		unless $HushIgnored eq 'true'
}

#-------------------Default Configuration (Formerly '/usr/share/ubuchk/config')

__DATA__

# Core Settings
ANSIColors=true
AutoQuery=false
QueryIndent=6
Recommend=true
ShowTTL=true
SkipIDs=
Verbose=false

# Characters
Char_Margin=+

# ANSI Colors
Color_AlertBracket=red
Color_AlertID=bright_red
Color_AlertTTL=bright_white
Color_AlertTTLText=white
Color_AlertText=bright_white
Color_AlertRecommend=bright_green
Color_QueryText=white
Color_QueryMargin=bright_black

# Disk Usage
AptCache=true
AptCacheMBLimit=100
DSLimit=90
DiskSpace=true
HomeCache=true
HomeCacheMBLimit=100
Thumbnails=true
ThumbsMBLimit=40

# Packaging Configurations
DpkgConf=true
HardAPT=true
PurgeChk=true
SkipAPT=APT::Install-Recommends
SkipDpkgOpts=

# Potentially Unwanted Packages
UnwantedPKGs=atftpd
UnwantedPKGs=kerneloops
UnwantedPKGs=kerneloops-applet
UnwantedPKGs=kerneloops-daemon
UnwantedPKGs=nis
UnwantedPKGs=popularity-contest
UnwantedPKGs=rsh-client
UnwantedPKGs=rsh-redone-client
UnwantedPKGs=rsh-redone-server
UnwantedPKGs=rsh-server
UnwantedPKGs=telnet
UnwantedPKGs=telnet-ssl
UnwantedPKGs=telnetd
UnwantedPKGs=telnetd-ssl
UnwantedPKGs=tftpd
UnwantedPKGs=tftpd-hpa
UnwantedPKGs=time
UnwantedPKGs=virtualbox-guest-additions-iso
UnwantedPKGs=virtualbox-guest-dkms
UnwantedPKGs=virtualbox-guest-dkms-hwe
UnwantedPKGs=virtualbox-guest-source
UnwantedPKGs=virtualbox-guest-source-hwe
UnwantedPKGs=virtualbox-guest-utils
UnwantedPKGs=virtualbox-guest-utils-hwe
UnwantedPKGs=virtualbox-guest-x11
UnwantedPKGs=virtualbox-guest-x11-hwe
UnwantedPKGs=whoopsie
#UnwantedPKGs=whoopsie-preferences
UnwantedPKGs=xinetd
UnwantedPKGs=xul-ext-ubufox
UnwantedPKGs=yp-tools

# Kernel
CustomKMs=
KernMods=true
KernParams=true
SkipKMs=joydev
SkipKP=fs.protected_hardlinks
SkipKP=fs.protected_symlinks

# Mode, Owner, and Group
DirPerms=true
PathPerms=true

# SSH
SSHClient=true
SSHDConfig=/etc/ssh/sshd_config
SSHServer=true

# SystemD
SkipSysD=
SystemD=true

# Portable Machine
BatCrit=10
BatLow=20
Laptop=true

# Mount Options
MountHome=true
SkipMountOpts=

# Sensors
CPUTemp=true
CoreTempCrit=70
TempScale=C

# RootKits, Worms, etc
RootKits=true
IgnoreFile=

# RAM & Swap
MBMaxRAM=2048
MBMaxSwap=512
RAM=false
Swaps=false

# `/etc/passwd`
ChkPasswd=true
ID0NonRoots=true

# Units/Services
AppArmor=true
UFW=true

# Miscellaneous
CMOS=false
CPUGovernor=
FailedLogins=true
LightDM=true
ProcVuln=true
SymsFileMode=true
