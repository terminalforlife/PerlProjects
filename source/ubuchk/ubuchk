#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/ubuchk
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/ubuchk/ubuchk
# Started On        - Mon  3 Feb 18:22:57 GMT 2020
# Last Change       - Fri 29 Jan 16:40:43 GMT 2021
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# An ever-growing Perl rewrite and vast overhaul of `ubuntu-syschk`.
#
# Features:
#
#TODO: Check for Firefox parameters, whether to optimize or make more secure.
#
#      https://forums.linuxmint.com/viewtopic.php?p=1962270#p1962270
#      https://forums.linuxmint.com/viewtopic.php?p=1962675#p1962675
#
#TODO: Search for files without a user and/or group assigned to them.
#
#      For example, in Shell: find / -xdev \( -nouser -o -nogroup \)
#
#TODO: Check for module `pam_namespace` for user's own `/tmp` and `/var/tmp`.
#TODO: Add file permissions and ownership section (not just directories).
#TODO: Add SSH permission and ownership checks for contents of ~/.ssh.
#TODO: Add `AllowUsers` check to `SSHServer` key.
#TODO: Add `kernel.exec-shield` parameter; recommend value of `1`.
#TODO: Add a voltage check for the CMOS battery.
#TODO: Add check for CPU governor when using a laptop and regular PC.
#TODO: Add check for X amount of space taken up in Trash.
#TODO: Add check for fan speeds; alert when low/off.
#TODO: Add check for listening TCP/UDP ports, via netstat(8) or ss(8).
#TODO: Add check for using something other than `UUID=` in `fstab`.
#TODO: Add checks for unsecure network-related packages. (RSH, for example)
#TODO: Add keys for block size 1000 and 1024, and for SI toggling.
#TODO: Add netstat(8) and ss(8) port and/or address security checks.
#TODO: Alert of all SUID (+4000) and SGID (+2000) files in PATH.
#TODO: Check (almost) entire system for non-group & non-user files.
#TODO: Check `/etc/inetd.conf` for malicious lines. (IE: Ramen Worm; '^asp')
#TODO: Check `/proc/kallsyms` file for malicious lines. ('(adore|sebek)')
#TODO: Check chklastlog(1) & chkwtmp(1) executables.
#TODO: Check for APT options without the use of `apt-config` executable.
#TODO: Check for Flash & Java (OpenJDK & Oracle Java) to suggest removal.
#TODO: Check for SSH scanners, via `/{var/tmp,tmp}/{vuln.txt,ssh-scan,pscan2}`.
#TODO: Check for UFW service without the use of `systemctl` executable.
#TODO: Check for Wine packages and (separately) Mono packages; suggest removal.
#TODO: Check for `apparmor=1` and `security=apparmor` in GRUB command line.
#TODO: Check for `apparmor=1` and `security=apparmor` in LILO command line.
#TODO: Check for installation of fonts unrelated to the user's region/language.
#TODO: Check for periodic filesystem check. (EXT2/3/4)
#TODO: Check if the Secure Boot is enabled; suggest disabling it, if so.
#TODO: Check it's not possible to log in as the `root` user.
#TODO: Check most of the system for files writeable by anybody.
#TODO: Check the `/etc/shadow` file for empty user passwords.
#TODO: Have `postinst` shell script check for appropriate default settings.
#TODO: Parse `/etc/{logrotate.conf,logrotate.d/*}` to suggest reducing logs.
#TODO: Parse files, like `sources.list`, for abnormals, like 'Proposed' & PPAs.
#TODO: Somehow check for reduction in SystemD log file, via journalctl(1).
#TODO: Somehow handle the first digit in `stat()` mode.
#
# Ports for which to add a check:
#
#   114,   145,   465,   511,   600,  1008,  1524,  1978,  1999,  2881,  3049,
#  3133,  3879,  4000,  4369,  5190,  5665,  6667,  7222, 10008, 12321, 23132,
# 27374, 29364, 30999, 31336, 31337, 37998, 45454, 47017, 47889, 60001
#
# Those ports can be found via the REGEX '[0-9:]443', with `netstat -tunla` or
# `ss -tunla`), and for which are also searched in chkrootkit(1).
#
# Bugs:
#
#TODO: Key overriding using OPT is ignored if key not found in config.
#
#      Simply assigning a default set of values (default config) would fix
#      this, but it would be easier (not really, but more dynamic) to have
#      UbuChk programmatically resort to the existing default config.
#
#      This bug and its potential resolution will likely be present and
#      applicable in some similarly-written programs of mine, like TuDu.
#
#TODO: Alerts and/or `Info()` calls are repeated for duplicate keys.
#TODO: Mismatch between temperatures shown from UbuChk and sensors(1).
#TODO: Not checking for invalid keys specified with `--key|-k` option.
#TODO: Not checking for valid `Color_*` and `Char_*` keys.
#TODO: Potentially, `UnwantedPKGs` are not being detected, despite existing.
#TODO: Queries, when auto-shown, showing duplicates. (correct, but unintended)
#
#      Not sure if this is still applicable, as I've yet to notice this since.
#
# Dependencies:
#
#   libfilesys-diskspace-perl (>= 0.05-16)
#   libnumber-bytes-human-perl (>= 0.09-1)
#   libterm-readkey-perl (>= 2.33-1build1)
#   libtext-wrapi18n-perl (>= 0.06-7.1)
#   perl (>= 5.22.1-9)
#------------------------------------------------------------------------------

require Filesys::DiskSpace;
require Number::Bytes::Human;
require POSIX;
require Term::ANSIColor;
require Term::ReadKey;
require Text::Wrap;

use v5.22.1;
use strict;
use warnings;
use autodie;
use Term::ANSIColor 'color', 'colorvalid';

no warnings 'uninitialized';

my $CurVer = '2021-01-29';
my $Progrm = 'ubuchk';
my $ProgrmFancy = 'UbuChk';

my $Domain = 'https://github.com/terminalforlife/PerlProjects';

sub Usage{
	print(qq{Usage: $Progrm [OPTS]

		  -h, --help               - Display this help information.
		  -v, --version            - Output the version datestamp.
		  --force-reset            - Force generation of config file.
		  --force-run              - Execute as though in Ubuntu Linux.
		  --hush-ignored           - When verbose, omit 'Ignoring' messages.
		  --list-dbalerts          - List alerts found within the database.
		  --list-keys              - List available configuration keys.
		  --skip=N[,N ...]         - Skip one or more N alerts, by ID.
		  -Q, --query N            - Read about alert ID number N.
		  -V, --verbose            - Execute checks verbosely.
		  -k, --key K=V            - Override key K with value V.
	} =~ tr/\t//dr)
}

my (
	$ForceReset, $KernParams, $PathPerms, @SkipKP, $Query, $HelpAlertID,
	@UnwantedPKGs, $ForceRun, $PurgeChk, $HardAPT, @SkipAPT, $SSHServer,
	$SSHDConfig, $Verbose, $UFW, $SystemD, $KernMods, @CustomKMs,
	@SkipKMs, @SkipIDs, $AlertCount, $Recommend, $SSHClient, $ProcVuln,
	$DiskSpace, @ShownAlerts, $AutoQuery, $QueryIndent, $DSLimit, @DBData,
	$DirPerms, @SkipSysD, $Laptop, @Installed, @NotPurged, $BatCrit, $BatLow,
	$MountHome, @SkipMountOpts, $CPUTemp, $CoreTempCrit, $FailedLogins,
	$TempScale, $AptCache, $AptCacheMBLimit, $LightDM, $RootKits, @IgnoreFiles,
	$HomeCache, $HomeCacheMBLimit, $Thumbnails, $ThumbsMBLimit, $DpkgConf,
	@SkipDpkgOpts, $Swaps, $MBMaxSwap, $RAM, $MBMaxRAM, $CMOS, $ListKeys,
	$ListDbAlerts, $ChkPasswd, %KeyOpt, $ID0NonRoots, $AppArmor, %ColorHash,
	$ANSIColors, $Char_Margin, %Syms, $ShowTTL, $HushIgnored, $SymsFileMode,
	$CPUGovernor
);

my $SymsFile = '/proc/kallsyms';

# Let me know if I missed any.
my @ValidGovs = (
	'performance', 'schedutil', 'powersave',
	'conservative', 'userspace', 'ondemand'
);

# These distributions are deemed supported and these strings are the value to
# the 'ID' key in the '/etc/os-release' file.
my @SupportedLSBs = ('ubuntu', 'pop');

my $MainDir = "$ENV{HOME}/.config/$Progrm";
my $ConfigFile = "$MainDir/config";
my $Database = '/usr/share/ubuchk/database';
my $RKDatabase = '/usr/share/ubuchk/database-rk';
my $DefaultConfigFile = "/usr/share/$Progrm/config";

my $GID = (split(' ', $())[0];

mkdir($MainDir) unless -d $MainDir;

while (defined($ARGV[0])){
	if ($ARGV[0] =~ /^(--help|-h|-\?)$/){
		Usage(); exit(0)
	}elsif ($ARGV[0] =~ /^(--version|-v)$/){
		print("$CurVer\n"); exit(0)
	}elsif($ARGV[0] =~ /^(--config|-c)$/){
		unless (length($ARGV[1]) > 0){
			die("Option '$ARGV[0]' requires a PATH")
		}elsif (not -f -r $ARGV[1]){
			die("Alternative configuration file missing or inaccessible")
		}

		shift();

		$ConfigFile = $ARGV[0]
	}elsif($ARGV[0] =~ /^(--force-reset|-F)$/){
		$ForceReset = 'true'
	}elsif($ARGV[0] eq '--force-run'){
		$ForceRun = 'true'
	}elsif($ARGV[0] eq '--hush-ignored'){
		$HushIgnored = 'true'
	}elsif($ARGV[0] =~ /^(--query|-Q)$/){
		length($ARGV[1]) > 0 or die("Option '$ARGV[0]' requires an alert ID");

		shift();

		$ARGV[0] =~ '^[0-9]{4}$' or die("Invalid alert ID");

		$Query = 'true';
		$HelpAlertID = $ARGV[0]
	}elsif($ARGV[0] =~ /^--skip=/){
		@SkipIDs = split(',', $ARGV[0] =~ s/^--skip=//r);

		@SkipIDs > 0 or die("Option '--skip=' requires at least one alert ID");

		foreach (@SkipIDs){
			/^[0-9]{4}$/ or die("Invalid alert ID")
		}
	}elsif($ARGV[0] =~ /^(--verbose|-V)$/){
		$Verbose = 'true'
	}elsif($ARGV[0] eq '--list-keys'){
		$ListKeys = 'true'
	}elsif($ARGV[0] eq '--list-dbalerts'){
		$ListDbAlerts = 'true'
	}elsif($ARGV[0] =~ /--key|-k/){
		length($ARGV[1]) > 0 or die("Option '$ARGV[0]' requires a key");

		shift();

		my ($Key, $Value) = split('=', $ARGV[0]);
		$KeyOpt{$Key} = $Value
	}elsif ($ARGV[0] =~ /^-/){
		die("Incorrect option(s) specified.")
	}else{
		last
	}

	shift()
}

sub DepChk{
	my @Files;
	foreach my $Dir (split(':', $ENV{'PATH'})) {
		-d $Dir or next;
		opendir(my $DH, $Dir) or next;
		push(@Files, readdir($DH));
		closedir($DH);
	}

	my $Found = scalar(@_);
	foreach my $CurDep (@_) {
		grep({$_ eq $CurDep} @Files) and $Found--
	}

	return($Found)
}

# Taken directly from the TFL module. (2020-02-29)
sub GetDirSize{
	my (@Dirs, $Size);
	foreach (glob("$_[0]/{*,.*}")){
		next if m{/(\.\.|\.)$};
		next if -l; # <-- Avoid infinite loop.

		push(@Dirs, $_) if -d -x;

		$Size += -s if -f
	}

	foreach (@Dirs){
		foreach (glob("$_/{*,.*}")){
			next if m{/(\.\.|\.)$};
			next if -l; # <-- Avoid infinite loop.

			push(@Dirs, $_) if -d -x;

			$Size += -s if -f
		}
	}

	return($Size)
}

#---------------------------------------------------------------OS & LSB Checks

unless ($ForceRun eq 'true'){
	if ($^O ne 'linux'){
		# Second & final chance to determine the OS type.
		my $VerFile = '/proc/version';
		if (-f -r $VerFile){
			open(my $FH, '<', $VerFile);
			my $OS = (split(' ', <$FH>))[0];
			close($FH);

			$OS eq 'Linux' or die("Unsupported OS")
		}else{
			die("Unrecognised OS")
		}
	}

	my $OSRelFile = '/etc/os-release';
	if (-f -r $OSRelFile){
		open(my $FH, '<', $OSRelFile);

		my $Found;
		while (my $Line = <$FH>){
			chomp(my ($Key, $Value) = split('=', $Line));
			if ($Key eq 'ID' and grep({$_ eq 'ubuntu'} @SupportedLSBs)){
				$Found = 'true'
			}
		}

		close($FH);

		$Found eq 'true' or die("Unsupported LSB")
	}else{
		die("Unrecognised LSB")
	}
}

# Needs to be here, for the FileChk() function.
my $VulnDir = '/sys/devices/system/cpu/vulnerabilities';

#-----------------------------------------------------Miscellaneous Subroutines

sub Human{
	use Number::Bytes::Human 'format_bytes';

	return(
		format_bytes($_[0], 'bs' => 1024, 'si' => 1, 'round_style' => 'round')
	)
}

sub Info{ # Usage: [STRING]
	print("$_[0]\n") if $Verbose eq 'true'
}

sub FileChk{ # Usage: [FILE]
	my $Errs;
	unless (-r $_[0]){
		warn("File '$_[0]' unreadable"); $Errs++
	}elsif (-B -s $_[0]){
		warn("File '$_[0]' is binary"); $Errs++
	}

	exit(1) if $Errs > 0;

	my $BaseName = ($_[0] =~ m{(?:.*/)(.*)})[0];
}

# Moving this here fixes bug when `AutoQuery` is on and a kernel parameter
# alert is shown. Not sure why; something about changing a read-only variable.
# This is usually not ideal, but at least when there are many alerts, the file
# won't constantly be opened and processed.
if (-f $Database){
	-r $Database or die("File '$Database' unreadable");

	open(my $FH, '<', $Database);
	@DBData = <$FH>;
	close($FH);
}else{
	unless ($AutoQuery ne 'true' and $Query ne 'true'){
		# Only error out here if queries are NOT completely disabled.
		die("File '$Database' not found")
	}
}

sub QueryAlert{
	use Term::ReadKey 'GetTerminalSize';
	use Text::Wrap 'wrap';

	$HelpAlertID = $_[1] if length($HelpAlertID) == 0;

	my ($Found, @Body);
	foreach (@DBData){
		chomp();

		if (/^:[0-9,]+$/){
			last if $Found eq 'true';

			my @CurIDs = split(',', substr($_, 1));
			foreach (@CurIDs){
				next unless $_ == $HelpAlertID;

				$Found = 'true';
				last
			}
		}elsif ($Found eq 'true'){
			push(@Body, $_)
		}
	}

	$Found eq 'true' or die("Alert '$HelpAlertID' not found");

	$Text::Wrap::columns = (GetTerminalSize())[0] - 2;

	print("Alert #$HelpAlertID:\n") unless length($_[1]) > 0;

	print("\n");
	foreach (@Body){
		# Ensures paragraphing works properly. The database must have a
		# single period (`.`) on an otherwise empty line, for this to work.
		print(
			' ' x $QueryIndent .
			$ColorHash{'Color_QueryMargin'} . "$Syms{'Char_Margin'} " . color('reset') . "\n"
		) and next if $_ eq '.';

		print(
			wrap(
				' ' x $QueryIndent .
				$ColorHash{'Color_QueryMargin'} . "$Syms{'Char_Margin'} " . color('reset') .
				$ColorHash{'Color_QueryText'}, ' ' x $QueryIndent .
				$ColorHash{'Color_QueryMargin'} . "$Syms{'Char_Margin'} " . color('reset') .
				$ColorHash{'Color_QueryText'},
				$ColorHash{'Color_QueryText'} . "$_" . color('reset') . "\n"
			)
		);
	}

	exit($_[0]) unless $_[1] > 0;

	# Prevents a query from being persistent with `AutoQuery`.
	$HelpAlertID = ''
}

sub Alert{ # Usage: [ALERT_ID] [STRING]
	unless (grep({$_ eq $_[0]} @SkipIDs)){
		$AlertCount++;

		printf(
			$ColorHash{'Color_AlertBracket'} . "[" . color('reset') .
			$ColorHash{'Color_AlertID'} . "A%0.4d" . color('reset').
			$ColorHash{'Color_AlertBracket'} . "]" . color('reset') .
			$ColorHash{'Color_AlertText'} . " %s\n" . color('reset'),
			$_[0], $_[1]
		);

		printf(
			$ColorHash{'Color_AlertRecommend'} . ' ' x 8 .
			"%s\n" . color('reset'), $_[2] . color('reset')
		) if $Recommend eq 'true';

		if ($AutoQuery eq 'true'){
			# Don't want to keep showing the same query.
			unless (grep({$_ eq $_[0]} @ShownAlerts)){
				QueryAlert(0, $_[0]);
				push(@ShownAlerts, $_[0]);
				print("\n")
			}
		}
	}else{
		Info("Skipping alert #$_[0], as requested.")
	}
}

sub ParseDpkgStatus{ # Usage: [STATUS_STRING]
	my $DpkgStatus = '/var/lib/dpkg/status';

	unless (-f $DpkgStatus){
		warn("File '$DpkgStatus' not found")
	}else{
		FileChk($DpkgStatus);
		open(my $FH, '<', $DpkgStatus);

		my ($Package, $Arch, $Status, @Packages);
		while (<$FH>){
			chomp();
			next if $_ eq '';

			my ($Key, $Value) = split(':');

			if ($Key eq 'Package'){
				$Package = $Value =~ tr/ //dr;
			}elsif ($Key eq 'Status'){
				$Status = $Value =~ tr/ //dr;
			}elsif ($Key eq 'Architecture'){
				$Arch = $Value =~ tr/ //dr;

				next unless $Status eq $_[0];

				push(@Packages, "$Package:$Arch")
			}
		}

		close($FH);

		Info("Finished with '$DpkgStatus' file.");

		return(sort(@Packages))
	}
}

#-----------------------List Keys and Gather Total Number of Alerts in Database

if ($ListKeys eq 'true'){
	my @Keys;
	while (<DATA>){
		next if /^(#|$)/;
		my @Line = split('=');
		push(@Keys, $Line[0])
	}

	my $Old;
	foreach (sort(@Keys)){
		print("$_\n") unless $Old eq $_;
		$Old = $_
	}

	exit(0)
}elsif ($ListDbAlerts eq 'true'){
	open(my $FH, '<', $Database);

	while (<$FH>){
		chomp();
		next unless substr($_, 0, 1) eq ':';
		print("$_\n") foreach split(' ', tr/:,/ /r)
	}

	close($FH);

	exit(0)
}

#-------------------------------------Configuration File Parsing and Generation

# Look for old file no longer used as of UbuChk 2021-01-01 version. Ideally, -
# this would be taken care of by the installer, but just in-case, check. Might
# avoid any confusion by the user, plus it's just cleaner.
if ($Verbose eq 'true' and -f $DefaultConfigFile) {
	print("NOTE: Found '$DefaultConfigFile' -- see: man $Progrm\n");
}

unlink($ConfigFile) if $ForceReset eq 'true' and -f $ConfigFile;

sub Boolean{
	$_[0] =~ '^(true|false)$' or die("Invalid boolean '$_[0]' detected")
}

if (-f -r -T $ConfigFile){
	my $InvalidKeyCount;

	open(my $FH, '<', $ConfigFile);

	while (<$FH>){
		chomp(my ($Key, $Value) = split('='));
		next if /^(#|$)/;

		# If the current key was provided to the `--key|-k` option, then
		# override the user's configuration file for this key.
		$Value = $KeyOpt{$Key} if grep({$_ eq $Key} keys(%KeyOpt));

		if ($Key =~ '^Color_.*'){
			colorvalid($Value) or die("Invalid color '$Value' detected");

			next if $ANSIColors eq 'false';

			$ColorHash{$Key} = color($Value =~ tr/['"]//dr)
		}elsif ($Key eq 'ANSIColors'){
			Boolean($Value);
			$ANSIColors = $Value
		}elsif ($Key =~ '^Char_.*'){
			if (length($Value) > 1){
				die("Invalid 'Char_*' value detected")
			}elsif (length($Value) == 0){
				next
			}else{
				$Syms{$Key} = $Value =~ tr/['"]//dr
			}
		}elsif ($Key eq 'KernParams'){
			Boolean($Value);
			$KernParams = $Value
		}elsif ($Key eq 'PathPerms'){
			Boolean($Value);
			$PathPerms = $Value
		}elsif ($Key eq 'SkipKP'){
			push(@SkipKP, $Value)
		}elsif ($Key eq 'SkipAPT'){
			push(@SkipAPT, $Value)
		}elsif ($Key eq 'PurgeChk'){
			Boolean($Value);
			$PurgeChk = $Value
		}elsif ($Key eq 'HardAPT'){
			$Value =~ '^([01]|true|false)$'
				or die("Invalid boolean '$Value' detected");

			$HardAPT = $Value
		}elsif ($Key eq 'SSHDConfig'){
			$SSHDConfig = $Value
		}elsif ($Key eq 'SSHServer'){
			Boolean($Value);
			$SSHServer = $Value
		}elsif ($Key eq 'SSHClient'){
			Boolean($Value);
			$SSHClient = $Value
		}elsif ($Key eq 'UnwantedPKGs'){
			push(@UnwantedPKGs, $Value)
		}elsif ($Key eq 'Verbose'){
			Boolean($Value);
			$Verbose = $Value unless $Verbose eq 'true'
		}elsif ($Key eq 'UFW'){
			Boolean($Value);
			$UFW = $Value
		}elsif ($Key eq 'SystemD'){
			Boolean($Value);
			$SystemD = $Value
		}elsif ($Key eq 'KernMods'){
			Boolean($Value);
			$KernMods = $Value
		}elsif ($Key eq 'CustomKMs'){
			push(@CustomKMs, $Value)
		}elsif ($Key eq 'SkipKMs'){
			push(@SkipKMs, $Value)
		}elsif ($Key eq 'SkipIDs'){
			push(@SkipIDs, split(',', $Value))
		}elsif ($Key eq 'Recommend'){
			Boolean($Value);
			$Recommend = $Value
		}elsif ($Key eq 'DiskSpace'){
			Boolean($Value);
			$DiskSpace = $Value
		}elsif ($Key eq 'AutoQuery'){
			Boolean($Value);
			$AutoQuery = $Value
		}elsif ($Key eq 'QueryIndent'){
			if ($Value =~ /^[0-9]+$/){
				# Default value and its bounds are mentioned in the config.
				$Value > 0 and $Value <= 9 or die("Key '$Key' out of bounds");

				$QueryIndent = $Value
			}else{
				die("Key '$Key' requires an integer");
			}
		}elsif ($Key eq 'DSLimit'){
			if ($Value =~ /^[0-9]+$/){
				# Default value and its bounds are mentioned in the config.
				unless ($Value >= 10 and $Value <= 100) {
					die("Key '$Key' out of bounds")
				}

				$DSLimit = $Value
			}else{
				die("Key '$Key' requires an integer");
			}
		}elsif ($Key eq 'DirPerms'){
			Boolean($Value);
			$DirPerms = $Value
		}elsif ($Key eq 'SkipSysD'){
			push(@SkipSysD, $Value)
		}elsif ($Key eq 'Laptop'){
			Boolean($Value);
			$Laptop = $Value
		}elsif ($Key eq 'BatCrit'){
			if ($Value =~ /^[0-9]+$/){
				unless ($Value > 0 and $Value <= 99) {
					die("Key '$Key' out of bounds")
				}

				$BatCrit = $Value
			}else{
				die("Key '$Key' requires an integer");
			}
		}elsif ($Key eq 'BatLow'){
			if ($Value =~ /^[0-9]+$/){
				unless ($Value > 0 and $Value <= 99) {
					die("Key '$Key' out of bounds")
				}

				$BatLow = $Value
			}else{
				die("Key '$Key' requires an integer");
			}
		}elsif ($Key eq 'ProcVuln'){
			Boolean($Value);
			$ProcVuln = $Value
		}elsif ($Key eq 'MountHome'){
			Boolean($Value);
			$MountHome = $Value
		}elsif ($Key eq 'SkipMountOpts'){
			push(@SkipMountOpts, split(',', $Value))
		}elsif ($Key eq 'CPUTemp'){
			Boolean($Value);
			$CPUTemp = $Value
		}elsif ($Key eq 'CoreTempCrit'){
			if ($Value =~ /^[0-9]+$/){
				$CoreTempCrit = $Value
			}else{
				die("Key '$Key' requires an integer");
			}
		}elsif ($Key eq 'TempScale'){
			if ($Value =~ /^[C|F]$/){
				$TempScale = $Value
			}else{
				die("Key '$Key' must be either 'F' or 'C'");
			}
		}elsif ($Key eq 'AptCache'){
			Boolean($Value);
			$AptCache = $Value
		}elsif ($Key eq 'AptCacheMBLimit'){
			if ($Value =~ /^[0-9]+$/){
				$AptCacheMBLimit = $Value
			}else{
				die("Key '$Key' requires an integer in MB");
			}
		}elsif ($Key eq 'LightDM'){
			Boolean($Value);
			$LightDM = $Value
		}elsif ($Key eq 'RootKits'){
			Boolean($Value);
			$RootKits = $Value
		}elsif ($Key eq 'IgnoreFile'){
			push(@IgnoreFiles, $Value)
		}elsif ($Key eq 'HomeCache'){
			Boolean($Value);
			$HomeCache = $Value
		}elsif ($Key eq 'HomeCacheMBLimit'){
			if ($Value =~ /^[0-9]+$/){
				$HomeCacheMBLimit = $Value
			}else{
				die("Key '$Key' requires an integer");
			}
		}elsif ($Key eq 'Thumbnails'){
			Boolean($Value);
			$Thumbnails = $Value
		}elsif ($Key eq 'ThumbsMBLimit'){
			if ($Value =~ /^[0-9]+$/){
				$ThumbsMBLimit = $Value
			}else{
				die("Key '$Key' requires an integer");
			}
		}elsif ($Key eq 'DpkgConf'){
			Boolean($Value);
			$DpkgConf = $Value
		}elsif ($Key eq 'DpkgConf'){
			Boolean($Value);
			$DpkgConf = $Value
		}elsif ($Key eq 'SkipDpkgOpts'){
			push(@SkipDpkgOpts, $Value)
		}elsif ($Key eq 'Swaps'){
			Boolean($Value);
			$Swaps = $Value
		}elsif ($Key eq 'MBMaxSwap'){
			if ($Value =~ /^[0-9]+$/){
				$MBMaxSwap = $Value
			}else{
				die("Key '$Key' requires an integer");
			}
		}elsif ($Key eq 'RAM'){
			Boolean($Value);
			$RAM = $Value
		}elsif ($Key eq 'MBMaxRAM'){
			if ($Value =~ /^[0-9]+$/){
				$MBMaxRAM = $Value
			}else{
				die("Key '$Key' requires an integer");
			}
		}elsif ($Key eq 'CMOS'){
			Boolean($Value);
			$CMOS = $Value
		}elsif ($Key eq 'ChkPasswd'){
			Boolean($Value);
			$ChkPasswd = $Value
		}elsif ($Key eq 'ID0NonRoots'){
			Boolean($Value);
			$ID0NonRoots = $Value
		}elsif ($Key eq 'AppArmor'){
			Boolean($Value);
			$AppArmor = $Value
		}elsif ($Key eq 'FailedLogins'){
			Boolean($Value);
			$FailedLogins = $Value
		}elsif ($Key eq 'ShowTTL'){
			Boolean($Value);
			$ShowTTL = $Value
		}elsif ($Key eq 'SymsFileMode'){
			Boolean($Value);
			$SymsFileMode = $Value
		}elsif ($Key eq 'CPUGovernor'){
			if (length($CPUGovernor) > 0 and not grep($Value, @ValidGovs)){
				die("CPU governor '$CPUGovernor' not recognised")
			}

			$CPUGovernor = $Value
		}else{
			warn("Key '$Key' unknown");

			$InvalidKeyCount++
		}
	}

	close($FH);

	exit(1) if $InvalidKeyCount > 0;

	# Because this would otherwise make no sense.
	if ($Laptop eq 'true' and $BatCrit >= $BatLow) {
		die("Key conflict with 'BatCrit' and 'BatLow'")
	}
}else{
	# Store contents into buffer, sans initial and now-unneeded Cito line.
	my @Buffer = <DATA>;
	my @Corrected = @Buffer[1..@Buffer];

	# Write to new user's-own config file.
	open(my $FH, '>', $ConfigFile);
	print($FH "# User configuration file for $ProgrmFancy (>= $CurVer)\n");
	print($FH "# Refer to $Progrm(8) to learn about these settings.\n\n");
	print($FH @Corrected);
	close($FH);

	print("File '~/.config/$Progrm/config' generated\n");
	exit(0)
}

if (@SkipIDs > 0){
	foreach (@SkipIDs){
		/^[0-9]{4}$/ or die("Invalid alert ID")
	}
}

@Installed = sort(ParseDpkgStatus('installokinstalled'))
	if @UnwantedPKGs > 0;

@NotPurged = sort(ParseDpkgStatus('deinstallokconfig-files'))
	if $PurgeChk eq 'true';

#-------------------------------------------------------------Querying an Alert

QueryAlert(0) if $Query eq 'true';

#-------------------------------------------------------------Kernel Parameters

if ($KernParams eq 'true'){
	my ($Value, $AlertID, $GoodValue, $Path, $ShowKey);

	foreach ( # [ALERT_ID] [DESIRED_VALUE] [KEY_PATH]
		'0913:1:/proc/sys/kernel/ctrl-alt-del',
		'1090:5:/proc/sys/net/ipv4/tcp_syn_retries',
		'1211:0:/proc/sys/net/ipv4/conf/all/accept_redirects',
		'1291:0:/proc/sys/net/ipv6/conf/default/accept_source_route',
		'1443:1:/proc/sys/kernel/yama/ptrace_scope',
		'1491:10:/proc/sys/vm/swappiness',
		'1821:1:/proc/sys/net/ipv4/conf/default/rp_filter',
		'2125:2048:/proc/sys/net/ipv4/tcp_max_syn_backlog',
		'2529:0:/proc/sys/net/ipv4/conf/default/send_redirects',
		'2847:1:/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses',
		'2916:0:/proc/sys/net/ipv6/conf/all/accept_redirects',
		'5434:1:/proc/sys/net/ipv4/icmp_echo_ignore_all',
		'5668:2:/proc/sys/net/ipv4/tcp_synack_retries',
		'6279:0:/proc/sys/net/ipv4/conf/default/accept_source_route',
		'6576:0:/proc/sys/net/ipv4/conf/all/accept_source_route',
		'7512:1:/proc/sys/net/ipv4/conf/all/rp_filter',
		'7536:0:/proc/sys/kernel/sysrq',
		'8560:2:/proc/sys/kernel/kptr_restrict',
		'8852:1:/proc/sys/net/ipv4/conf/all/log_martians',
		'8963:0:/proc/sys/net/ipv6/conf/all/accept_source_route',
		'9191:0:/proc/sys/net/ipv4/conf/all/send_redirects',
		'9211:2:/proc/sys/kernel/randomize_va_space',
		'9222:1:/proc/sys/net/ipv4/tcp_syncookies',
		'9623:1:/proc/sys/kernel/dmesg_restrict',
		'9992:0:/proc/sys/net/ipv4/ip_forward',
		'9993:1:/proc/sys/kernel/unprivileged_bpf_disabled',
		'9998:1:/proc/sys/fs/protected_symlinks',
		'9999:1:/proc/sys/fs/protected_hardlinks'
	){
		($AlertID, $GoodValue, $Path) = split(':');
		$ShowKey = $Path =~ tr/\//./r =~ s/\.proc\.sys\.//r;

		next if grep({$_ eq $ShowKey} @SkipKP);

		Info("Checking '$ShowKey' parameter.");

		if (-f $Path){
			unless (-r $Path){
				# Some parameters are more locked down than others.
				warn("Denied access to '$ShowKey' parameter");
				next
			}elsif (-B -s $Path){
				warn("Unable to determine '$ShowKey' parameter");
				next
			}

			open(my $FH, '<', $Path);
			chomp($Value = <$FH>);
			close($FH)
		}else{
			Info("Parameter '$ShowKey' unavailable.");

			next
		}

		Info("Parameter '$ShowKey' is '$Value'.");

		Alert(
			$AlertID,
			"Key '$ShowKey' assigned '$Value'.",
			"Recommended value is '$GoodValue'."
		) if $Value != $GoodValue
	}
}else{
	Info("Ignoring kernel parameters.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------PATH Permissions & Ownership

if ($PathPerms eq 'true'){
	if (length($ENV{'PATH'}) > 0){
		my @AlertPerms;
		foreach (split(':', $ENV{'PATH'})){
			Info("Looking in '$_' directory.");

			foreach (glob("$_/*")){
				my ($Mode, $Owner, $Group) = (stat($_))[2,4,5];
				$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

				Info("File '$_' is '$Mode' and '$Owner:$Group'.")
					if $Owner > 1 and $Owner < 1000
					or $Group > 1 and $Group < 1000
					or $Mode > 000 and $Mode < 755;

				Alert(
					7869,
					"File '$_' is mode '$Mode'.",
					"Recommended mode is '755'."
				) unless $Mode <= 755;

				# These executables should not be owned by a standard user, nor
				# should they be in such a group. <1000 is for system
				# users/groups. A stricter test (make optional?) would be to
				# flag all non-0s. There are exceptions, however, such as the
				# user having his or her own `bin` directory in their `/home`
				# directory.
				Alert(
					6005,
					"File '$_' is owned by '$Owner'.",
					"Recommended owner is '0' ('root')."
				) if $Owner >= 1000;

				Alert(
					3597,
					"File '$_' is in group '$Group'.",
					"Recommended group is '0' ('root')."
				) if $Group >= 1000
			}
		}
	}else{
		# This would have to be some seriously bizarre edge-case.
		Info("Missing prerequisites -- skipping 'PathPerms' key.")
	}
}else{
	Info("Ignoring PATH permissions & ownership.")
		unless $HushIgnored eq 'true'
}

#-----------------------------------------------------Packages Yet to Be Purged

if ($PurgeChk eq 'true'){
	Info("Looking for old package remains.");

	Alert(
		6712,
		"Package '$_' wasn't purged.",
		"Suggested action is to purge the package."
	) foreach @NotPurged;

	Info('No packages were found unpurged.') if @NotPurged == 0
}else{
	Info("Ignoring any unpurged packages.") unless $HushIgnored eq 'true'
}

#-----------------------------------------------------------APT Security Tweaks

if ($HardAPT eq 'true'){
	if (DepChk('apt-config') == 0){
		my %Settings;
		foreach (`apt-config dump --format '%f=%v%n' 2> /dev/null`){
			chomp();
			next if /^(#|$)/;

			my ($Key, $Value) = split('=');
			$Value = $Value =~ tr/"';//dr;

			# APT also accepts integer booleans.
			$Value = 'false' if $Value eq '0';
			$Value = 'true' if $Value eq '1';

			$Settings{$Key} = $Value
		}

		my ($Word, $Integer);
		foreach ( # [TARGET_VALUE] [KEY]
			'6135|6131|Recommended|false|APT::Get::AllowUnauthenticated',
			'6136|6132|Recommended|false|Acquire::http::AllowRedirect',
			'6137|6133|Recommended|false|APT::Install-Suggests',
			'6138|6134|Suggested|false|APT::Install-Recommends'
		){
			my ($AlertID1, $AlertID2, $RecSug, $Target, $Key) = split('\|');

			next if grep({$_ eq $Key} @SkipAPT);

			$Word = 'enabled' if $Settings{$Key} eq 'true';
			$Word = 'disabled' if $Settings{$Key} eq 'false';
			$Integer = 0 if $Target eq 'false';
			$Integer = 1 if $Target eq 'true';

			unless (exists($Settings{$Key})){
				Alert(
					$AlertID1,
					"APT key '$Key' is unassigned.",
					"$RecSug action is to assign it '$Target' or '$Integer'."
				)
			}elsif ($Settings{$Key} ne $Target){
				Alert(
					$AlertID2,
					"APT key '$Key' is $Word.",
					"$RecSug value is '$Target' or '$Integer'."
				)
			}else{
				Info("Key '$Key' is $Word.");
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'HardAPT' key.")
	}
}else{
	Info("Ignoring APT configuration.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------------------SSH Client

if ($SSHClient eq 'true'){
	my $SSHDir = "$ENV{HOME}/.ssh";

	if (-d $SSHDir){
		-r $SSHDir or die("Directory '$SSHDir' unreadable");
		-x $SSHDir or die("Directory '$SSHDir' denies execution");

		my ($Mode, $Owner, $Group) = (stat($SSHDir))[2,4,5];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		Alert(
			5431,
			"Directory '$SSHDir' is mode '$Mode'.",
			"Recommended mode is '700'."
		) unless $Mode == 700;

		Alert(
			5438,
			"Directory '$SSHDir' is owned by '$Owner'.",
			"Recommended UID is '$<'."
		) unless $Owner == $<;

		Alert(
			5439,
			"Directory '$SSHDir' is in group '$Group'.",
			"Recommended GID is '$GID'."
		) unless $Group == $GID;
	}else{
		Info("Missing prerequisites -- skipping 'SSHClient' key.")
	}
}else{
	Info("Ignoring SSH permissions & settings.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------------------SSH Server

if ($SSHServer eq 'true'){
	if (-f $SSHDConfig){
		-r $SSHDConfig or die("File '$SSHDConfig' unreadable");

		# Without the `-s` flag, zero-size files get flagged as binary.
		-B -s $SSHDConfig and die("File '$SSHDConfig' is binary");

		FileChk($SSHDConfig);
		open(my $FH, '<', $SSHDConfig);

		my %Settings;
		while (<$FH>){
			chomp();
			next if /(^#|^$)/;

			my ($Key, $Value) = split(' ');

			Info("Key '$Key' is '$Value'.");

			$Settings{$Key} = $Value
		}

		close($FH);

		foreach ( # [ALERT_ID_1] [ALERT_ID_2] [TARGET_VALUE] [KEY]
			'6990|6980|no|PermitRootLogin',
			'6991|6992|2|Protocol',
			'6996|6993|no|PermitEmptyPasswords',
			'6997|6994|no|PasswordAuthentication',
			'6998|6995|no|X11Forwarding'
		){
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next if grep({$_ eq $Key} @SkipAPT);

			unless (exists($Settings{$Key})){
				Alert(
					$AlertID1,
					"SSH daemon key '$Key' may not be assigned.",
					"Recommended action is to assign it '$Target'."
				)
			}elsif ($Settings{$Key} ne $Target){
				Alert(
					$AlertID2,
					"SSH daemon key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}

		# Ordinarily, you shouldn't use the commonplace `22` port.
		unless (exists($Settings{'Port'})){
			Alert(
				7541,
				"SSH daemon key 'Port' may not be assigned.",
				"Recommended action is NOT to assign it '22'."
			)
		}elsif ($Settings{'Port'} eq 22){
			Alert(
				6542,
				"SSH daemon key 'Port' assigned '$Settings{Port}'.",
				"Recommended value is one other than '22'."
			)
		}
	}else{
		Info("Missing prerequisites -- skipping 'SSHServer' key.")
	}
}else{
	Info("Ignoring whether SSH server is present.")
		unless $HushIgnored eq 'true'
}

#---------------------------------------------------------Packages Best Avoided

if (@UnwantedPKGs > 0){
	foreach my $CurPKG (@UnwantedPKGs){
		Info("Looking for '$CurPKG' package.");

		Alert(
			5656,
			"Package(s) matching '$CurPKG' installed.",
			"Suggested consideration of uninstallation."
		) if grep({($_ =~ m/(.*)(?::.*)/)[0] eq $CurPKG} @Installed)
	}
}else{
	Info("Ignoring any unwanted packages.") unless $HushIgnored eq 'true'
}

#----------------------------------------------------------------SystemD Tweaks

if ($SystemD eq 'true'){
	my $SDConfig = '/etc/systemd/system.conf';

	if (-f $SDConfig){
		FileChk($SDConfig);
		open(my $FH, '<', $SDConfig);

		my %Settings;
		while (<$FH>){
			chomp();
			next if /(^#|^$|^\[Manager\]$)/;

			my ($Key, $Value) = split('=');

			Info("Key '$Key' is '$Value'.");

			$Settings{$Key} = $Value
		}

		close($FH);

		foreach ( # [TARGET_VALUE] [KEY]
			'1411|1415|1024|DefaultLimitNPROC',
			'1412|1416|1024|DefaultLimitNOFILE',
			'1413|1417|no|CrashShell',
			'1414|1418|no|DumpCore'
		){
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next if grep({$_ eq $Key} @SkipSysD);

			unless (exists($Settings{$Key})){
				Alert(
					$AlertID1,
					"SystemD key '$Key' may not be assigned.",
					"Recommended action is to assign it '$Target'."
				)
			}elsif ($Settings{$Key} ne $Target){
				Alert(
					$AlertID2,
					"SystemD key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'SystemD' key.")
	}
}else{
	Info("Ignoring SystemD-related tweaks.") unless $HushIgnored eq 'true'
}

#----------------------------------------------------------------Kernel Modules

if ($KernMods eq 'true'){
	my $ProcMods = '/proc/modules';

	if (-f $ProcMods){
		FileChk($ProcMods);
		open(my $FH, '<', $ProcMods);

		my @Modules;
		while (<$FH>){
			chomp();

			my @Line = split(' ');

			push(@Modules, $Line[0])
		}

		close($FH);

		foreach (
			'1274|mei',
			'1275|mei_me',
			'1276|mei_wtk',
			'7416|joydev',
			'8471|psmouse'
		){
			my ($AlertID, $Module) = split('\|');

			if (grep({$_ eq $Module} @Modules)){
				unless (grep({$_ eq $Module} @SkipKMs)){
					Info("Module '$Module' found but ignored.");
					next # <-- Skipping the below alert.
				}

				Alert(
					$AlertID,
					"Module '$Module' discovered and live.",
					"Recommended action is to blacklist the module."
				)
			}else{
				Info("Module '$Module' not found.")
			}
		}

		foreach my $Mod (@CustomKMs){
			Alert(
				8189,
				"Module '$Mod' discovered and live.",
				"Recommended action is to blacklist the module."
			) if grep({$_ eq $Mod} @Modules)
		}
	}else{
		Info("Missing prerequisites -- skipping 'KernMods' key.")
	}
}else{
	Info("Ignoring kernel modules.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------Check Filesystem Sizes

if ($DiskSpace eq 'true'){
	my $MountFile = '/proc/mounts';

	if (-f $MountFile){
		use Filesys::DiskSpace 'df';

		FileChk($MountFile);
		open(my $FH, '<', $MountFile);

		my (@MountPoints, $Base, $Used, $Free, $Size, $Mount, $Perc);
		while (<$FH>){
			chomp(my @Arr = split(' '));

			# Using this REGEX over just '^/' avoids statfs errors.
			if ($Arr[0] =~ '^/dev/(sd|hd|fd)[[:alpha:]]+[0-9]+$'){
				# Avoids `not a directory` error, for EFI setups.
				next if $Arr[1] eq '/boot/efi';

				# Avoids other `not a directory` error instances.
				next unless -d $Arr[0];

				Info("Looking at '$Arr[0]' partition.");

				$Mount = $Arr[1] =~ s/\\040/ /gr;
				($Used, $Free) = (df($Mount))[2,3] or next;
				$Used = $Used * 1024;
				$Free = $Free * 1024;
				$Size = $Free + $Used;
				$Perc = int(($Used / $Size) * 100);

				if ($Perc >= $DSLimit){
					Alert(4612,
						"Partition '$Arr[0]' is $Perc% full.",
						"Recommended action is to clear out junk."
					)
				}else{
					Info("Partition '$Arr[0]' is using $Perc% of space.");
				}
			}
		}

		close($FH);
	}else{
		Info("Missing prerequisites -- skipping 'DiskSpace' key.")
	}
}else{
	Info("Ignoring disk space availability.") unless $HushIgnored eq 'true'
}

#----------------------Specific File & Directory Permissions, Group & Ownership

if ($DirPerms eq 'true'){
	foreach ( # [ALERTID] [MODE] [UID] [GID]
		"5440:700:$<:$GID:$ENV{HOME}",
		'5436:700:0:0:/boot',
		'5446:700:0:0:/root'
	){
		my ($AlertID, $TargetMode, $TargetUID, $TargetGID, $Path) = split(':');

		next unless -d $Path;

		Info("Looking at '$Path' directory.");

		my ($Mode, $Owner, $Group) = (stat($Path))[2,4,5];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		Alert(
			$AlertID,
			"Directory '$Path' is mode '$Mode'.",
			"Recommended mode is '$TargetMode'."
		) unless $Mode == $TargetMode;

		Alert(
			$AlertID,
			"Directory '$Path' is owned by '$Owner'.",
			"Recommended UID is '$TargetUID'."
		) unless $Owner == $TargetUID;

		Alert(
			$AlertID,
			"Directory '$Path' is in group '$Group'.",
			"Recommended GID is '$TargetGID'."
		) unless $Group == $TargetGID;
	}
}else{
	Info("Ignoring special file permissions & ownership.")
		unless $HushIgnored eq 'true'
}

#-----------------------------------------------------------------Laptop Checks

if ($Laptop eq 'true'){
	my $BaseDir = '/sys/class/power_supply';
	my $AdapTypeFile = "$BaseDir/ADP1/type";
	my $AdapOnlineFile = "$BaseDir/ADP1/online";

	my $AdapOnline;
	if (-f $AdapTypeFile){
		FileChk($AdapTypeFile);
		open(my $FH, '<', $AdapTypeFile);
		chomp(my $AdapType = <$FH>);
		close($FH);

		if ($AdapType eq 'Mains'){
			FileChk($AdapOnlineFile);
			open(my $FH, '<', $AdapOnlineFile);
			chomp($AdapOnline = <$FH>);
			close($FH);

			if ($AdapOnline == 0){
				Info("Device is NOT plugged in.")
			}else{
				Info("Device is plugged in.")
			}
		}
	}

	if (-d "$BaseDir/BAT1"){ # <-- Ensure at least one battery exists.
		foreach (glob("$BaseDir/BAT[1-9]")){
			my $BatFile = "$_/capacity";
			my $KNowFile = "$_/charge_now";
			my $KMaxFile = "$_/charge_full_design";

			if (-f $BatFile){
				FileChk($BatFile);
				open(my $FH, '<', $BatFile);
				chomp(my $BatPerc = <$FH>);
				close($FH);

				my $Battery = $BatFile =~ s/.*\/BAT([0-9]+)\/capacity$/$1/r;

				my ($KNow, $KMax);
				if (-f $KNowFile and -f $KMaxFile){
					FileChk($KNowFile);
					open(my $FH, '<', $KNowFile);
					chomp($KNow = substr(<$FH>, 0, length($KNow) - 4));
					close($FH);

					FileChk($KMaxFile);
					open($FH, '<', $KMaxFile);
					chomp($KMax = substr(<$FH>, 0, length($KMax) - 4));
					close($FH);
				}

				if ($BatPerc <= $BatCrit){
					Alert(
						2850,
						"Battery #$Battery critical at $BatPerc% ($KNow mAh) capacity.",
						"Save your work and shut down the computer."
					) unless $AdapOnline == 1
				}elsif ($BatPerc <= $BatLow){
					if (length($KMax) > 0 and length($KNow) > 0){
						Alert(
							2849,
							"Battery #$Battery low at $BatPerc% ($KNow mAh) capacity.",
							"Suggested action is to charge the battery."
						) unless $AdapOnline == 1
					}else{
						Alert(
							2849,
							"Battery #$Battery low at $BatPerc% capacity.",
							"Suggested action is to charge the battery."
						) unless $AdapOnline == 1
					}
				}else{
					if (length($KMax) > 0 and length($KNow) > 0){
						Info("Battery #$Battery still has $BatPerc% at $KNow mAh power.")
					}else{
						Info("Battery #$Battery still has $BatPerc% power left.")
					}
				}
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'Laptop' key.")
	}
}else{
	Info("Ignoring tweaks for a portable machine.")
		unless $HushIgnored eq 'true'
}

#------------------------------------------------------CPU Marked as Vulnerable

if ($ProcVuln eq 'true'){
	if (-d $VulnDir){
		-r $VulnDir or die("Directory '$VulnDir' unreadable");
		-x $VulnDir or die("Unable to open '$VulnDir' directory");

		foreach (glob("$VulnDir/*")){
			next unless -f;

			my $Vuln = ($_ =~ m{(?:.*/)(.*)})[0];

			Info("Checking CPU for vulnerability to $Vuln.");

			FileChk($_);
			open(my $FH, '<', $_);
			chomp(my $Data = <$FH>);
			close($FH);

			if ($Data =~ /Vulnerable/i){
				Alert(
					4811,
					"CPU marked as vulnerable to $Vuln.",
					"Don't panic -- refer to: $Progrm -Q 4811"
				)
			}elsif ($Data =~ /Not affected/i){
				Info("Unaffected by $Vuln vulnerability.")
			}elsif ($Data =~ /Mitigation/i){
				Info("Vulnerability $Vuln mitigated.")
			}else{
				Alert(
					4812,
					"Unrecognised vulnerability status to $Vuln.",
					"Don't panic -- refer to: $Progrm -Q 4812"
				)
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'ProcVuln' key.")
	}
}else{
	Info("Ignoring any CPU vulnerabilities.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------Mount Options for HOME

if ($MountHome eq 'true'){
	my $MountFile = '/proc/mounts';

	if (-f $MountFile){
		FileChk($MountFile);
		open(my $FH, '<', $MountFile);

		my ($Device, $Options);
		while (<$FH>){
			chomp(my @Arr = split(' '));

			# Using this REGEX over just '^/' avoids statfs errors.
			if ($Arr[1] eq '/home'){
				($Device, $Options) = @Arr[0,3];
				last
			}
		}

		close($FH);

		if (length($Device) > 0){
			Info("Mountpoint '/home' points to '$Device'.");

			my @OptArr = split(',', $Options);
				my ($AlertID, $Option) = split(',');

			foreach (
				'1356,noexec',
				'1357,nodev',
				'1358,nosuid'
			){
				my ($AlertID, $Option) = split(',');

				if (grep({$_ eq $Option} @SkipMountOpts)){
					Info("Module '$Option' found but ignored.");
					next # <-- Skipping the below alert.
				}

				if (grep({$_ eq $Option} @OptArr)){
					Info("Mount option '$Option' for '/home' is set.")
				}else{
					Alert($AlertID,
						"Missing mount option '$Option' for '/home'.",
						"Please refer to: $Progrm -Q $AlertID"
					)
				}
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'MountHome' key.")
	}
}else{
	Info("Ignoring any HOME mount options.") unless $HushIgnored eq 'true'
}

#---------------------------------------------------------CPU Core Temperatures

# There are several ways to get the system's CPU temperature(s), without
# dragging in another program, but for now, I'll program for this particular
# method, adding additional ones as issues are reported.
if ($CPUTemp eq 'true'){
	my $Dir;
	if (-d '/sys/devices/platform/coretemp.0/hwmon/hwmon3'){
		$Dir = '/sys/devices/platform/coretemp.0/hwmon/hwmon3'
	}elsif (-d '/sys/class/hwmon/hwmon1'){
		$Dir = '/sys/class/hwmon/hwmon1'
	}else{
		Info("Missing prerequisites -- skipping 'CPUTemp' key.")
	}

	if (defined($Dir)){
		-r $Dir or die("Directory '$Dir' unreadable");
		-x $Dir or die("Directory '$Dir' denies execution");

		# Gather a hash of (only) the core temperatures.
		my (%TempData, $Temp);
		foreach (glob("$Dir/temp*")){
			next unless -f and m{/temp[0-9]+_(input|label)$};

			FileChk($_);
			open(my $FH, '<', $_);
			chomp(my $Data = <$FH>);
			close($FH);

			# The files are ordered from input to label, so we need to process
			# it backwards, otherwise the output would be borked.
			if (/_input$/){
				$Temp = $Data
			}elsif (/_label$/){
				$TempData{$Data} = $Temp
			}
		}

		# Ensure we have the right suffix for 1'st', 2'nd', 3'rd', and N'th'.
		sub Suffix{ # Usage: [INT]
			my $Num = $_[0] + 1;
			return("${Num}st") if $Num =~ '1$';
			return("${Num}nd") if $Num =~ '2$';
			return("${Num}rd") if $Num =~ '3$';
			return("${Num}th")
		}

		# Taken directly from the TFL module. (2020-02-29)
		sub CelsFahr{
			if ($_[0] eq 'F'){
				use POSIX 'ceil';

				return(ceil(($_[1] * 9/5) + 32))
			}elsif ($_[0] eq 'C'){
				return($_[1])
			}
		}

		# Begin checking on each of the core temperatures, per the above hash.
		foreach (sort(keys(%TempData))){
			next unless /^Core [0-9]+$/;

			# Initially, this value is in Celsius (unconfirmed).
			my $TempInt = CelsFahr(
				$TempScale, substr($TempData{$_}, 0, length($TempData{$_}) - 3)
			);

			my $TempStr = "$TempIntÂ°$TempScale";
			my $CoreInt = (m{(?:.* )(.*)})[0];
			my $CoreStr = Suffix($CoreInt);
			if ($TempInt >= $CoreTempCrit){
				Alert(
					6237,
					"CPU's $CoreStr core critical at $TempStr.",
					"Suggested action is to improve system cooling."
				)
			}else{
				Info("CPU core #$CoreInt stable at $TempStr.")
			}
		}
	}
}else{
	Info("Ignoring CPU temperatures.") unless $HushIgnored eq 'true'
}

#----------------------------------------------------------APT Cache Disk Usage

if ($AptCache eq 'true'){
	my $Dir = '/var/cache/apt/archives';

	if (-d $Dir){
		# Ignoring `partial` directory, as it often needs root access to use.
		# The same goes for files like `lock`, as they're irrelevant here.
		my ($FileCount, $Size);
		foreach (glob("$Dir/*.deb")){
			$Size += -s;
			$FileCount++;

			if ($Verbose eq 'true'){
				my $Human = Human($Size);
				my $BaseName = ($_ =~ m{(?:.*/)(.*)})[0];

				Info("Found '$BaseName', using $Human.");
			}
		}

		if ($Size > 0){
			my $Human = Human($Size);
			if ($Size / 1024 / 1024 >= $AptCacheMBLimit){
				if (DepChk('sudo') == 0){
					Alert(
						9708,
						"Found $FileCount cached Debian packages, totalling $Human.",
						"Suggested action is to run: sudo apt-get clean"
					);
				}else{
					Alert(
						9708,
						"Found $FileCount cached Debian packages, totalling $Human.",
						"Suggested action is to, as root, run: apt-get clean"
					);
				}
			}else{
				Info("Cached Debian packages take up only $Human.");
			}
		}else{
			Info("Found no cached Debian packages.");
		}
	}else{
		Info("Missing prerequisites -- skipping 'AptCache' key.")
	}
}else{
	Info("Ignoring APT cache disk usage.") unless $HushIgnored eq 'true'
}

#-----------------------------------------------------------------------LightDM

if ($LightDM eq 'true'){
	my $Config = '/etc/lightdm/lightdm.conf.d/50-no-guest.conf';

	if (-f $Config){
		FileChk($Config);
		open(my $FH, '<', $Config);

		my $AllowGuest;
		while (<$FH>){
			chomp();

			# Correct, at least in Ubuntu 16.04.6 base. Ubuntu 18.04.4 seems to
			# not use this file by default, but it can still be found at:
			#
			#  /usr/share/lightdm/lightdm.conf.d/50-disable-guest.conf
			#
			if (/(^| )allow-guest=true( |$)/){
				$AllowGuest = 'true'; last
			}elsif (/(^| )allow-guest=false( |$)/){
				$AllowGuest = 'false'; last
			}
		}

		close($FH);

		if ($AllowGuest eq 'true'){
			Alert(
				9188,
				'Guest logins are allowed with LightDM.',
				'Recommended action is to disable guest logins.'
			);
		}elsif ($AllowGuest eq 'false'){
			Info('LightDM does not permit guest logins.')
		}else{
			Alert(
				9188,
				'Guest logins may be allowed with LightDM.',
				"Recommended action is to ensure it's disabled."
			);
		}
	}else{
		Info("Missing prerequisites -- skipping 'LightDM' key.")
	}
}else{
	Info("Ignoring any LightDM configurations.") unless $HushIgnored eq 'true'
}

#----------------------------------------------------------RootKits, Worms, etc

# This section is based on information from this GitHub repository:
#
#   https://github.com/ossec/ossec-hids
#
# Also inspired by various checks made by rkhunter(8).
if ($RootKits eq 'true'){
	-f $RKDatabase or die("File '$RKDatabase' not found");
	-r $RKDatabase or die("File '$RKDatabase' unreadable");

	open(my $FH, '<', $RKDatabase);
	my @DBData = <$FH>;
	close($FH);

	my ($AlertID, $Name);
	foreach my $Line (@DBData){
		chomp($Line);

		next if $Line =~ '^#';
		if ($Line =~ '^:'){
			($AlertID, $Name) = (split(':', $Line))[1..2];
			Info("Searching: $Name");
		}elsif (length($Line) > 0){
			next unless -e $Line =~ tr/_/ /r;

			Alert(
				$AlertID,
				"Found: $Line",
				"File associated with $Name."
			) unless grep({$_ eq $Line} @IgnoreFiles)
		}
	}
}else{
	Info("Ignoring rootkits, detected or not.") unless $HushIgnored eq 'true'
}

#------------------------------------------------------------------User's Cache

if ($HomeCache eq 'true'){
	my $CacheDir = "$ENV{HOME}/.cache";

	if (-d $CacheDir){
		my $Size = GetDirSize($CacheDir);
		if ($Size > 0){
			use POSIX 'ceil';

			my $SizeMB = ceil($Size / (1024 * 1024));
			my $Human = Human($Size);
			if ($SizeMB >= $HomeCacheMBLimit){
				Alert(
					7619,
					"User '$ENV{USER}' has a cache total of $Human.",
					"Suggested action is to remove unneeded files."
				)
			}else{
				Info("User '$ENV{USER}' caches only $Human.")
			}
		}else{
			Info("User '$ENV{USER}' directory '~/.cache' is empty.")
		}
	}else{
		Info("Missing prerequisites -- skipping 'HomeCache' key.")
	}
}else{
	Info("Ignoring user's own general cache.") unless $HushIgnored eq 'true'
}

#-------------------------------------------------------------User's Thumbnails

if ($Thumbnails eq 'true'){
	my $ThumbDir = "$ENV{HOME}/.thumbnails";

	if (-d $ThumbDir){
		my $Size = GetDirSize($ThumbDir);
		if ($Size > 0){
			use POSIX 'ceil';

			my $SizeMB = ceil($Size / 1024 / 1024);
			my $Human = Human($Size);
			if ($SizeMB >= $ThumbsMBLimit){
				Alert(
					7620,
					"User '$ENV{USER}' has a thumbnails total of $Human.",
					"Suggested action is to remove unneeded files."
				)
			}else{
				Info("User '$ENV{USER}' thumbnails take up only $Human.")
			}
		}else{
			Info("User '$ENV{USER}' directory '~/.thumbnails' is empty.")
		}
	}else{
		Info("Missing prerequisites -- skipping 'Thumbnails' key.")
	}
}else{
	Info("Ignoring user's own thumbnail cache.") unless $HushIgnored eq 'true'
}

#------------------------------------------------------------DPKG Configuration

if ($DpkgConf eq 'true'){
	my $DpkgConfFile = '/etc/dpkg/dpkg.cfg';

	if (-f $DpkgConfFile){
		FileChk($DpkgConfFile);
		open(my $FH, '<', $DpkgConfFile);

		my ($FoundNoDebSig, $FoundLog);
		while (<$FH>){
			chomp();
			next if /^(#|$)/;

			$FoundNoDebSig = 'true' if /^no-debsig($|[[:space:]]+.*)/;
			$FoundLog = 'true' if /^log /;
		}

		close($FH);

		my $ChkStatus = grep({$_ eq 'no-debsig'} @SkipDpkgOpts);
		unless ($FoundNoDebSig eq 'true' and not $ChkStatus){
			Alert(
				3790,
				"Potentially-unsupported 'debsig' not disabled.",
				"Recommended action is to verify it's supported."
			)
		}else{
				Info("Configuration value 'no-debsig' found.");
		}

		$ChkStatus = grep({$_ eq 'log'} @SkipDpkgOpts);
		unless ($FoundLog eq 'true' and not $ChkStatus){
			Alert(
				3791,
				"Status changes and actions not being logged by DPKG.",
				"Recommended action is to enable this feature."
			)
		}else{
				Info("Configuration value 'log' found.");
		}
	}else{
		Info("Missing prerequisites -- skipping 'DpkgConf' key.")
	}
}else{
	Info("Ignoring any DPKG configurations.") unless $HushIgnored eq 'true'
}

#-------------------------------------------------------------------------Swaps

if ($Swaps eq 'true'){
	my $SwapFile = '/proc/swaps';

	if (-f $SwapFile){
		use POSIX 'ceil';

		FileChk($SwapFile);
		open(my $FH, '<', $SwapFile);

		my (@Swaps, $SwapCount);
		while (<$FH>){
			chomp();

			# Skip header.
			next if $. == 1;

			my ($File, $Type, $Size, $Used, $Priority) = split(' ');
			my $HumSize = Human($Size * 1024);
			my $HumUsed = Human($Used * 1024);
			my $MRemains = ceil(($Size - $Used) / 1024);

			if ($Type eq 'file'){
				my ($Mode, $Owner, $Group) = (stat($File))[2,4,5];
				$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

				Alert(
					6232,
					"File '$File' is mode '$Mode'.",
					"Recommended mode is '600'."
				) unless $Mode == 600;

				Alert(
					6233,
					"File '$File' is owned by '$Owner'.",
					"Recommended UID is '0'."
				) unless $Owner == 0;

				Alert(
					6234,
					"File '$File' is in group '$Group'.",
					"Recommended GID is '0'."
				) unless $Group == 0;
			}

			# Just in-case the file is in the user's HOME.
			$File = $File =~ s/$ENV{HOME}/~/r;

			if ($MRemains >= $MBMaxSwap){
				Info("Swap $Type '$File' using $HumUsed/$HumSize.");
			}else{
				my $HumRemains = Human(($Size - $Used) * 1024);

				Alert(
					8759,
					"Only $HumRemains left on '$File' $Type.",
					"Suggested action is to increase swap size."
				)
			}

			$SwapCount++
		}

		if ($SwapCount > 1){
			Info("System has $SwapCount active swap areas.")
		}elsif ($SwapCount == 0){
			Alert(
				8760,
				"Detected no assigned swap space on the system.",
				"Suggested action is to add a swap file or partition."
			)
		}

		close($FH)
	}else{
		Info("Missing prerequisites -- skipping 'Swaps' key.")
	}
}else{
	Info("Ignoring any Swap configurations.") unless $HushIgnored eq 'true'
}

#---------------------------------------------------------------------------RAM

if ($RAM eq 'true'){
	my $MemFile = '/proc/meminfo';

	if (-f $MemFile){
		use POSIX 'ceil';

		FileChk($MemFile);
		open(my $FH, '<', $MemFile);

		my (
			$BShared, $BSwap, $BTotal, $BFree,
			$BCache, $HumFree, $BSRec, $BBuf
		);

		while (<$FH>){
			chomp(my @Line = split(' '));

			if ($Line[0] eq 'MemTotal:'){
				$BTotal = $Line[1] * 1024
			}elsif ($Line[0] eq 'MemFree:'){
				$BFree = $Line[1] * 1024
			}elsif ($Line[0] eq 'Buffers:'){
				$BBuf = $Line[1] * 1024
			}elsif ($Line[0] eq 'Cached:'){
				$BCache = $Line[1] * 1024
			}elsif ($Line[0] eq 'Shmem:'){
				$BShared = $Line[1] * 1024
			}elsif ($Line[0] eq 'SwapTotal:'){
				$BSwap = $Line[1] * 1024
			}elsif ($Line[0] eq 'SReclaimable:'){
				$BSRec = $Line[1] * 1024
			}
		}

		close($FH);

		my $HumTotal = Human($BTotal);

		# Ignore shared memory, buffers, and cache, similar to htop(1).
		my $BUsed = ($BTotal - $BFree) - ($BBuf + $BCache + $BSRec);

		# As the free(1) utility shows by default.
		my $MUsed = ceil($BUsed / (1024 * 1024));
		my $HumUsed = Human($BUsed);

		if ($MUsed <= $MBMaxRAM){
			Info("Using only $HumUsed of $HumTotal available RAM.")
		}else{
			Alert(
				8971,
				"Using $HumUsed of $HumTotal available RAM.",
				"Please refer to: $Progrm -Q 8971"
			)
		}
	}else{
		Info("Missing prerequisites -- skipping 'RAM' key.")
	}
}else{
	Info("Ignoring RAM availability.") unless $HushIgnored eq 'true'
}

#------------------------------------------------------------------CMOS Battery

if ($CMOS eq 'true'){
	my $RTCFile = '/proc/driver/rtc';

	if (-f $RTCFile){
		open(my $FH, '<', $RTCFile);

		my $BatStatus;
		while (<$FH>){
			chomp();
			my @Line = split(': ');
			$BatStatus = $Line[1]
		}

		close($FH);

		if ($BatStatus eq 'okay'){
			Info("CMOS battery appears to be okay.")
		}else{
			Alert(
				1118,
				"Detected a non-'okay' CMOS battery status.",
				"Recommended action is to physically check it."
			)
		}
	}else{
		Info("Missing prerequisites -- skipping 'CMOS' key.")
	}
}else{
	Info("Ignoring any CMOS battery.") unless $HushIgnored eq 'true'
}

#-------------------------------------------------------------------/etc/passwd

if ($ChkPasswd eq 'true'){
	my $PasswdFile = '/etc/passwd';

	if (-f $PasswdFile){
		open(my $FH, '<', $PasswdFile);

		my ($WormFound, @Roots);
		while (<$FH>){
			$WormFound = $. if /w0rm/;

			if ($ID0NonRoots eq 'true'){
				chomp(my @Line = split(':'));

				if ($Line[2] == 0 or $Line[3] == 0){
					push(@Roots, $Line[0]) unless grep({$_ eq $Line[0]} @Roots);
				}
			}
		}

		close($FH);

		unless (length($WormFound) > 0){
			Info("Cannot see 'w0rm' in '$PasswdFile' file.")
		}else{
			Alert(
				1428,
				"Found 'w0rm' on line #$WormFound in '$PasswdFile' file.",
				"Please refer to a search engine."
			)
		}

		if ($ID0NonRoots eq 'true'){
			unless (@Roots > 1){
				Info("Just 'root' with '0:0' found in '$PasswdFile' file.")
			}else{
				if (@Roots > 1){
					my ($Wording1, $Wording2);
					if (@Roots == 2){
						$Wording1 = 'user';
						$Wording2 = 'this user is'
					}else{
						$Wording1 = 'users';
						$Wording2 = 'these users are'
					}

					Alert(
						9848,
						"Non-root $Wording1 with '0' UID/GID in '$PasswdFile' file.",
						"Recommended action is to confirm $Wording2 legitimate."
					);

					foreach (@Roots){
						Info("User '$_' has '0' UID/GID.") unless $_ eq 'root'
					}
				}
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'ChkPasswd' key.");

		Info("Missing prerequisites -- skipping 'ID0NonRoots' key.")
			if $ID0NonRoots eq 'true'
	}
}else{
	Info("Ignoring system's passwd file.") unless $HushIgnored eq 'true'
}

#--------------------------------------------------------SystemD Units/Services

if ($UFW eq 'true'){
	if (DepChk('systemctl') == 0){
		chomp(my $Active = `systemctl is-active ufw 2> /dev/null`);
		unless ($Active eq 'active'){
			Alert(
				5541,
				"UFW is installed but its service inactive.",
				"Recommended action is to start the UFW service."
			)
		}else{
			Info('The UFW service is active.')
		}

		chomp(my $Enabled = `systemctl is-enabled ufw 2> /dev/null`);
		unless ($Enabled eq 'enabled'){
			Alert(
				5542,
				"UFW is installed but its service disabled.",
				"Recommended action is to enable the UFW service."
			)
		}else{
			Info('The UFW service is enabled.')
		}
	}else{
		Info("Missing prerequisites -- skipping 'UFW' key.")
	}
}else{
	Info("Ignoring any installations of UFW.") unless $HushIgnored eq 'true'
}

if ($AppArmor eq 'true'){
	if (DepChk('systemctl') == 0){
		chomp(my $Active = `systemctl is-active apparmor 2> /dev/null`);
		unless ($Active eq 'active'){
			Alert(
				1298,
				"AppArmor is installed but its service inactive.",
				"Recommended action is to start the AppArmor service."
			)
		}else{
			Info('The AppArmor service is active.')
		}

		chomp(my $Enabled = `systemctl is-enabled apparmor 2> /dev/null`);
		unless ($Enabled eq 'enabled'){
			Alert(
				1299,
				"AppArmor is installed but its service disabled.",
				"Recommended action is to enable the AppArmor service."
			)
		}else{
			Info('The AppArmor service is enabled.')
		}
	}else{
		Info("Missing prerequisites -- skipping 'AppArmor' key.")
	}
}else{
	Info("Ignoring any installations of AppArmor.")
		unless $HushIgnored eq 'true'
}

#---------------------------------------------------------Failed Login Attempts

if ($FailedLogins eq 'true'){
	my $FailFile = '/var/log/faillog';

	if (-f $FailFile){
		unless (-s $FailFile){
			Alert(
				2223,
				'Detected possible failed login attempts.',
				'Please execute the faillog(8) command.'
			)
		}else{
			Info('No failed login attempts detected.')
		}
	}else{
		Info("Missing prerequisites -- skipping 'FailedLogins' key.")
	}
}else{
	Info("Ignoring any failed login attempts.") unless $HushIgnored eq 'true'
}

#-----------------------------------------------Check for '/proc/kallsyms' Mode

if ($SymsFileMode eq 'true'){
	if (-f $SymsFile){
		my $Mode = (stat($SymsFile))[2];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		if ($Mode == 400){
			Info("Mode '400' set for '$SymsFile'.")
		}else{
			Alert(
				8128,
				"Mode for '$SymsFile' file found.",
				"Recommended mode is '400'."
			)
		}
	}else{
		Info("Missing prerequisites -- skipping 'SymsFileMode' key.")
	}
}else{
	Info("Ignoring mode of '$SymsFile' file.") unless $HushIgnored eq 'true'
}

#----------------------------------------------Check CPU Governor Is As Desired

if (length($CPUGovernor) > 0){
	my $GovDir = '/sys/devices/system/cpu/cpufreq';

	my (%Governors, $FoundFile);
	foreach my $Dir (glob("$GovDir/*")) {
		-d $Dir or next;

		foreach my $File ("$Dir/scaling_governor") {
			$FoundFile = 'true';

			open(my $FH, '<', $File);

			chomp(my $Data = <$FH>);
			my $Core = ($Dir =~ m{.*/policy([0-9]+)})[0] + 1;
			$Governors{$Core} = $Data;

			close($FH)
		}
	}

	if ($FoundFile eq 'true'){
		foreach (sort({$a > $b} keys(%Governors))) {
			Info("CPU Core #$_ using '$Governors{$_}' governor.");

			unless ($Governors{$_} eq $CPUGovernor) {
				Alert(
					2623,
					"CPU Core #$_ using '$Governors{$_}' governor.",
					"Configured to prefer '$CPUGovernor'."
				)
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'CPUGovernor' key.")
	}
}else{
	Info("Ignoring CPU governors.") unless $HushIgnored eq 'true'
}

#------------------------------------------------------------------------Finish

if ($ShowTTL eq 'true'){
	print(
		$ColorHash{'Color_AlertTTLText'} . "Alerted " . color('reset') .
		$ColorHash{'Color_AlertTTL'} . "$AlertCount" . color('reset') .
		$ColorHash{'Color_AlertTTLText'} . " time(s).\n" . color('reset')
	) if $AlertCount > 0;
}else{
	Info("Omitting display of total number of alerts.")
		unless $HushIgnored eq 'true'
}

#-------------------Default Configuration (Formerly '/usr/share/ubuchk/config')

__DATA__

# Core Settings
ANSIColors=true
AutoQuery=false
QueryIndent=6
Recommend=true
ShowTTL=true
SkipIDs=
Verbose=false

# Characters
Char_Margin=+

# ANSI Colors
Color_AlertBracket=red
Color_AlertID=bright_red
Color_AlertTTL=bright_white
Color_AlertTTLText=white
Color_AlertText=bright_white
Color_AlertRecommend=bright_green
Color_QueryText=white
Color_QueryMargin=bright_black

# Disk Usage
AptCache=true
AptCacheMBLimit=100
DSLimit=90
DiskSpace=true
HomeCache=true
HomeCacheMBLimit=100
Thumbnails=true
ThumbsMBLimit=40

# Packaging Configurations
DpkgConf=true
HardAPT=true
PurgeChk=true
SkipAPT=APT::Install-Recommends
SkipDpkgOpts=

# Potentially Unwanted Packages
UnwantedPKGs=atftpd
UnwantedPKGs=kerneloops
UnwantedPKGs=kerneloops-applet
UnwantedPKGs=kerneloops-daemon
UnwantedPKGs=nis
UnwantedPKGs=popularity-contest
UnwantedPKGs=rsh-client
UnwantedPKGs=rsh-redone-client
UnwantedPKGs=rsh-redone-server
UnwantedPKGs=rsh-server
UnwantedPKGs=telnet
UnwantedPKGs=telnet-ssl
UnwantedPKGs=telnetd
UnwantedPKGs=telnetd-ssl
UnwantedPKGs=tftpd
UnwantedPKGs=tftpd-hpa
UnwantedPKGs=time
UnwantedPKGs=virtualbox-guest-additions-iso
UnwantedPKGs=virtualbox-guest-dkms
UnwantedPKGs=virtualbox-guest-dkms-hwe
UnwantedPKGs=virtualbox-guest-source
UnwantedPKGs=virtualbox-guest-source-hwe
UnwantedPKGs=virtualbox-guest-utils
UnwantedPKGs=virtualbox-guest-utils-hwe
UnwantedPKGs=virtualbox-guest-x11
UnwantedPKGs=virtualbox-guest-x11-hwe
UnwantedPKGs=whoopsie
#UnwantedPKGs=whoopsie-preferences
UnwantedPKGs=xinetd
UnwantedPKGs=xul-ext-ubufox
UnwantedPKGs=yp-tools

# Kernel
CustomKMs=
KernMods=true
KernParams=true
SkipKMs=joydev
SkipKP=fs.protected_hardlinks
SkipKP=fs.protected_symlinks

# Mode, Owner, and Group
DirPerms=true
PathPerms=true

# SSH
SSHClient=true
SSHDConfig=/etc/ssh/sshd_config
SSHServer=true

# SystemD
SkipSysD=
SystemD=true

# Portable Machine
BatCrit=10
BatLow=20
Laptop=true

# Mount Options
MountHome=true
SkipMountOpts=

# Sensors
CPUTemp=true
CoreTempCrit=70
TempScale=C

# RootKits, Worms, etc
RootKits=true
IgnoreFile=

# RAM & Swap
MBMaxRAM=2048
MBMaxSwap=512
RAM=false
Swaps=false

# `/etc/passwd`
ChkPasswd=true
ID0NonRoots=true

# Units/Services
AppArmor=true
UFW=true

# Miscellaneous
CMOS=false
CPUGovernor=
FailedLogins=true
LightDM=true
ProcVuln=true
SymsFileMode=true
