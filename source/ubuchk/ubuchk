#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/ubuchk
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/ubuchk/ubuchk
# Started On        - Mon  3 Feb 18:22:57 GMT 2020
# Last Change       - Thu 20 Feb 03:26:22 GMT 2020
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# A work-in-progress Perl rewrite and overhaul of `ubuntu-syschk`.
#
# Features:
#
#TODO: Add ANSI color support and configuration items for it.
#TODO: Add SSH permission and ownership checks for contents of ~/.ssh.
#TODO: Add `Info()` for `Laptop` when it's plugged in and charging.
#TODO: Add a second level of verbosity, for those wanting lots of information.
#TODO: Add a stricter ownership PATH check, for the more paranoid.
#TODO: Add check for CPU governer when using a laptop and regular PC.
#TODO: Add check for X amount of space taken up in Trash.
#TODO: Add check for fan speeds; alert when low/off.
#TODO: Add check for using something other than `UUID=` in `fstab`.
#TODO: Add check(s) for swapfile permissions if it's detected in `/`.
#TODO: Add update feature, because it's important to keep this updated.
#TODO: Check for UFW service without the use of `systemctl` executable.
#TODO: Don't rely just on '50-no-guest.conf' file for LightDM guest check.
#TODO: Somehow handle the first digit in `stat()` mode.
#
# Bugs:
#
#TODO: Queries, when auto-shown, showing duplicates. (correct, but unintended)
#
# Dependencies:
#
#   libfilesys-diskspace-perl (>= 0.05-16)
#   libnumber-bytes-human-perl (>= 0.09-1)
#   libterm-readkey-perl (>= 2.33-1build1)
#   libtext-wrapi18n-perl (>= 0.06-7.1)
#   libtfl-perl (>= 2020-02-20)
#   perl (>= 5.22.1-9)
#------------------------------------------------------------------------------

use strict;
use warnings;
use autodie;
use TFL qw{FErr Boolean DepChk InitialDirs CelsFahr GetDirSize};

no warnings 'uninitialized';

my $CurVer = '2020-02-20';

my $Domain = 'https://github.com/terminalforlife/PerlProjects';

sub Usage{
	print(qq{Usage: $TFL::PROGNAME [OPTS]

		  -h, --help               - Display this help information.
		  -v, --version            - Output the version datestamp.
		  --force-reset            - Force generation of config file.
		  --is-ubuntu              - Execute as though in Ubuntu.
		  -Q, --query N            - Read about alert ID number N.
		  --skip=N[,N ...]         - Skip one or more N alerts, by ID.
		  -V, --verbose            - Execute checks verbosely.
	} =~ tr/\t//dr)
}

my (
	$ForceReset, $KernParams, $PathPerms, @SkipKP, $Query, $HelpAlertID,
	@UnwantedPKGs, $IsUbuntu, $PurgeChk, $HardAPT, @SkipAPT, $SSHServer,
	$SSHDConfig, $Verbose, $Firewall, $SystemD, $KernMods, @CustomKMs,
	@SkipKMs, @SkipIDs, $AlertCount, $Recommend, $SSHClient, $ProcVuln,
	$DiskSpace, @ShownAlerts, $AutoQuery, $QueryIndent, $DSLimit, @DBData,
	$DirPerms, @SkipSysD, $Laptop, @Installed, @NotPurged, $BatCrit, $BatLow,
	$OSOverride, $MountHome, @SkipMountOpts, $CPUTemp, $CoreTempCrit,
	$TempScale, $AptCache, $AptCacheMBLimit, $LightDM, $RootKits, @SkipRKs,
	$HomeCache, $HomeCacheMBLimit, $Thumbnails, $ThumbsMBLimit
);

my $MainDir = "$ENV{HOME}/.config/$TFL::PROGNAME";
my $ConfigFile = "$MainDir/config";
my $Database = '/usr/share/ubuchk/database';
my $DefaultConfigFile = "/usr/share/$TFL::PROGNAME/config";

my $GID = (split(' ', $())[0];

mkdir($MainDir) unless -d $MainDir;

while (defined($ARGV[0])){
	if ($ARGV[0] =~ '^(--help|-h|-\?)$'){
		Usage(); exit(0)
	}elsif ($ARGV[0] =~ '^(--version|-v)$'){
		print("$CurVer\n"); exit(0)
	}elsif($ARGV[0] =~ '^(--config|-c)$'){
		shift();

		unless (length($ARGV[0]) > 0){
			FErr(1, __LINE__, "Option '--config|-c' requires a PATH.")
		}elsif (not -f -r $ARGV[0]){
			FErr(1, __LINE__, "Alternative configuration file missing or inaccessible.")
		}

		$ConfigFile = $ARGV[0]
	}elsif($ARGV[0] =~ '^(--force-reset|-F)$'){
		$ForceReset = 'true'
	}elsif($ARGV[0] =~ '^(--query|-Q)$'){
		shift();

		FErr(1, __LINE__, "Option '--query|-Q' requires an alert ID.")
			unless length($ARGV[0]) > 0;

		FErr(1, __LINE__, "Invalid alert ID -- see: $TFL::PROGNAME -h")
			unless $ARGV[0] =~ '^[0-9]{4}$';

		$Query = 'true';
		$HelpAlertID = $ARGV[0]
	}elsif($ARGV[0] =~ '^--skip='){
		@SkipIDs = split(',', $ARGV[0] =~ s/^--skip=//r);

		FErr(1, __LINE__, "Option '--skip=' requires at least one alert ID.")
			unless @SkipIDs > 0;

		foreach (@SkipIDs){
			FErr(1, __LINE__, "Invalid alert ID -- see: $TFL::PROGNAME -h")
				unless /^[0-9]{4}$/;
		}
	}elsif($ARGV[0] =~ '^(--is-ubuntu|-U)$'){
		$IsUbuntu = 'true'
	}elsif($ARGV[0] =~ '^(--verbose|-V)$'){
		$Verbose = 'true'
	}elsif($ARGV[0] eq '--os-override'){
		$OSOverride = 'true'
	}elsif ($ARGV[0] =~ '^-'){
		FErr(1, __LINE__, "Incorrect option(s) specified.")
	}else{
		last
	}

	shift()
}

unless ($OSOverride eq 'true'){
	if (-f -r '/proc/version'){
		open(my $FH, '<', '/proc/version');
		my $OS = (split(' ', <$FH>))[0];
		close($FH);

		FErr(1, __LINE__, "Sorry, $OS is not supported by UbuChk.")
			unless $OS eq 'Linux'
	}else{
		FErr(1, __LINE__, 'Unable to determine OS -- refer to ubuchk(8).')
	}
}

# Needs to be here, for the FileChk() function.
my $VulnDir = '/sys/devices/system/cpu/vulnerabilities';

#-----------------------------------------------------Miscellaneous Subroutines

sub Info{ # Usage: [STRING]
	print("$_[0]\n") if $Verbose eq 'true'
}

sub FileChk{ # Usage: [FILE]
	my $Err;
	unless (-r $_[0]){
		FErr(0, __LINE__, "File '$_[0]' unreadable."); $Err++
	}elsif (-B $_[0]){
		FErr(0, __LINE__, "File '$_[0]' is binary."); $Err++
	}

	exit(1) if $Err > 0;

	#my $BaseName = ($_[0] =~ m{(?:.*/)(.*)})[0];
	#Info("Checking '$BaseName' file.")
}

# Moving this here fixes bug when `AutoQuery` is on and a kernel parameter
# alert is shown. Not sure why; something about changing a read-only variable.
# This is usually not ideal, but at least when there are many alerts, the file
# won't constantly be opened and processed.
if (-f $Database){
	FErr(1, __LINE__, "File '$Database' unreadable.") unless -r $Database;

	open(my $FH, '<', $Database);
	@DBData = <$FH>;
	close($FH);
}else{
	unless ($AutoQuery ne 'true' and $Query ne 'true'){
		if (DepChk(':', 'cito') == 0){
			FErr(0, __LINE__, "File '$Database' not found -- run:")
				unless -f $Database;

			print(
				STDERR "cito -r terminalforlife PerlProjects " .
				"master source/ubuchk/database\n"
			);

			exit(1)
		}

		# Only error out here if queries are NOT completely disabled.
		FErr(1, __LINE__, "File '$Database' not found.")
	}
}

sub QueryAlert{
	use Term::ReadKey 'GetTerminalSize';
	use Text::Wrap 'wrap';

	$HelpAlertID = $_[1] if length($HelpAlertID) == 0;

	my ($Found, @Body);
	foreach (@DBData){
		chomp();

		if (/^:[0-9,]+$/){
			last if $Found eq 'true';

			my @CurIDs = split(',', substr($_, 1));
			foreach (@CurIDs){
				next unless $_ == $HelpAlertID;

				$Found = 'true';
				last
			}
		}elsif ($Found eq 'true'){
			push(@Body, $_)
		}
	}

	FErr(1, __LINE__, "Alert '$HelpAlertID' not found -- are we up-to-date?")
		unless $Found eq 'true';

	$Text::Wrap::columns = (GetTerminalSize())[0] - 2;

	print("Alert #$HelpAlertID:\n\n") unless length($_[1]) > 0;

	print(' ' x $QueryIndent . "+\n");
	foreach (@Body){
		# Ensures paragraphing works properly. The database must have a
		# single period (`.`) on an otherwise empty line, for this to work.
		print(' ' x $QueryIndent . "|\n") and next if $_ eq '.';

		print(wrap(' ' x $QueryIndent . '|  ', ' ' x $QueryIndent . '|  ', "$_\n"));
	}
	print(' ' x $QueryIndent . "+\n");

	exit($_[0]) unless $_[1] > 0;

	# Prevents a query from being persistent with `AutoQuery`.
	$HelpAlertID = ''
}

sub Alert{ # Usage: [ALERT_ID] [STRING]
	unless (grep({$_ eq $_[0]} @SkipIDs)){
		$AlertCount++;

		printf("[A%0.4d] %s\n", $_[0], $_[1]);
		printf("        %s\n", $_[2]) if $Recommend eq 'true';

		if ($AutoQuery eq 'true'){
			# Don't want to keep showing the same query.
			unless (grep({$_ eq $_[0]} @ShownAlerts)){
				QueryAlert(0, $_[0]);
				push(@ShownAlerts, $_[0]);
				print("\n")
			}
		}
	}
}

sub ParseDpkgStatus{ # Usage: [STATUS_STRING]
	my $DpkgStatus = '/var/lib/dpkg/status';

	unless (-f $DpkgStatus){
		FErr(0, __LINE__, "File '$DpkgStatus' not found.")
	}else{
		FileChk($DpkgStatus);
		open(my $FH, '<', $DpkgStatus);

		my ($Package, $Arch, $Status, @Packages);
		while (<$FH>){
			chomp();
			next if $_ eq '';

			my ($Key, $Value) = split(':');

			if ($Key eq 'Package'){
				$Package = $Value =~ tr/ //dr;
			}elsif ($Key eq 'Status'){
				$Status = $Value =~ tr/ //dr;
			}elsif ($Key eq 'Architecture'){
				$Arch = $Value =~ tr/ //dr;

				next unless $Status eq $_[0];

				push(@Packages, "$Package:$Arch")
			}
		}

		close($FH);

		Info("Finished with '$DpkgStatus' file.");

		return(sort(@Packages))
	}
}

#-------------------------------------Configuration File Parsing and Generation

unlink($ConfigFile) if $ForceReset eq 'true' and -f $ConfigFile;

if (-f -r -T $ConfigFile){
	my $InvalidKeyCount;

	open(my $FH, '<', $ConfigFile);

	while (<$FH>){
		next if length() <= 1 or /^#/;
		chomp(my ($Key, $Value) = split('='));

		if ($Key eq 'KernParams'){
			Boolean($Value);
			$KernParams = $Value
		}elsif ($Key eq 'PathPerms'){
			Boolean($Value);
			$PathPerms = $Value
		}elsif ($Key eq 'SkipKP'){
			push(@SkipKP, $Value)
		}elsif ($Key eq 'SkipAPT'){
			push(@SkipAPT, $Value)
		}elsif ($Key eq 'PurgeChk'){
			Boolean($Value);
			$PurgeChk = $Value
		}elsif ($Key eq 'IsUbuntu'){
			Boolean($Value);
			$IsUbuntu = $Value unless $IsUbuntu eq 'true'
		}elsif ($Key eq 'HardAPT'){
			Boolean($Value);
			$HardAPT = $Value
		}elsif ($Key eq 'SSHDConfig'){
			$SSHDConfig = $Value
		}elsif ($Key eq 'SSHServer'){
			Boolean($Value);
			$SSHServer = $Value
		}elsif ($Key eq 'SSHClient'){
			Boolean($Value);
			$SSHClient = $Value
		}elsif ($Key eq 'UnwantedPKGs'){
			push(@UnwantedPKGs, $Value)
		}elsif ($Key eq 'Verbose'){
			Boolean($Value);
			$Verbose = $Value unless $Verbose eq 'true'
		}elsif ($Key eq 'Firewall'){
			Boolean($Value);
			$Firewall = $Value
		}elsif ($Key eq 'SystemD'){
			Boolean($Value);
			$SystemD = $Value
		}elsif ($Key eq 'KernMods'){
			Boolean($Value);
			$KernMods = $Value
		}elsif ($Key eq 'CustomKMs'){
			push(@CustomKMs, $Value)
		}elsif ($Key eq 'SkipKMs'){
			push(@SkipKMs, $Value)
		}elsif ($Key eq 'SkipIDs'){
			push(@SkipIDs, split(',', $Value))
		}elsif ($Key eq 'Recommend'){
			Boolean($Value);
			$Recommend = $Value
		}elsif ($Key eq 'DiskSpace'){
			Boolean($Value);
			$DiskSpace = $Value
		}elsif ($Key eq 'AutoQuery'){
			Boolean($Value);
			$AutoQuery = $Value
		}elsif ($Key eq 'QueryIndent'){
			if ($Value =~ /^[0-9]+$/){
				# Default value and its bounds are mentioned in the config.
				FErr(1, __LINE__, "Key '$Key' out of bounds.")
					unless $Value > 0 and $Value <= 9;

				$QueryIndent = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'DSLimit'){
			if ($Value =~ /^[0-9]+$/){
				# Default value and its bounds are mentioned in the config.
				FErr(1, __LINE__, "Key '$Key' out of bounds.")
					unless $Value >= 10 and $Value <= 100;

				$DSLimit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'DirPerms'){
			Boolean($Value);
			$DirPerms = $Value
		}elsif ($Key eq 'SkipSysD'){
			push(@SkipSysD, $Value)
		}elsif ($Key eq 'Laptop'){
			Boolean($Value);
			$Laptop = $Value
		}elsif ($Key eq 'BatCrit'){
			if ($Value =~ /^[0-9]+$/){
				FErr(1, __LINE__, "Key '$Key' out of bounds.")
					unless $Value > 0 and $Value <= 99;

				$BatCrit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'BatLow'){
			if ($Value =~ /^[0-9]+$/){
				FErr(1, __LINE__, "Key '$Key' out of bounds.")
					unless $Value > 0 and $Value <= 99;

				$BatLow = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'ProcVuln'){
			Boolean($Value);
			$ProcVuln = $Value
		}elsif ($Key eq 'MountHome'){
			Boolean($Value);
			$MountHome = $Value
		}elsif ($Key eq 'SkipMountOpts'){
			push(@SkipMountOpts, split(',', $Value))
		}elsif ($Key eq 'CPUTemp'){
			Boolean($Value);
			$CPUTemp = $Value
		}elsif ($Key eq 'CoreTempCrit'){
			if ($Value =~ /^[0-9]+$/){
				$CoreTempCrit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'TempScale'){
			if ($Value =~ /^[C|F]$/){
				$TempScale = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' must be either 'F' or 'C'.");
			}
		}elsif ($Key eq 'AptCache'){
			Boolean($Value);
			$AptCache = $Value
		}elsif ($Key eq 'AptCacheMBLimit'){
			if ($Value =~ /^[0-9]+$/){
				$AptCacheMBLimit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer in MB.");
			}
		}elsif ($Key eq 'LightDM'){
			Boolean($Value);
			$LightDM = $Value
		}elsif ($Key eq 'RootKits'){
			Boolean($Value);
			$RootKits = $Value
		}elsif ($Key eq 'SkipRKs'){
			push(@SkipRKs, $Value)
		}elsif ($Key eq 'HomeCache'){
			Boolean($Value);
			$HomeCache = $Value
		}elsif ($Key eq 'HomeCacheMBLimit'){
			if ($Value =~ /^[0-9]+$/){
				$HomeCacheMBLimit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}elsif ($Key eq 'Thumbnails'){
			Boolean($Value);
			$Thumbnails = $Value
		}elsif ($Key eq 'ThumbsMBLimit'){
			if ($Value =~ /^[0-9]+$/){
				$ThumbsMBLimit = $Value
			}else{
				FErr(1, __LINE__, "Key '$Key' requires an integer.");
			}
		}else{
			FErr(0, __LINE__, "Key '$Key' unrecognised.");

			$InvalidKeyCount++
		}
	}

	close($FH);

	exit(1) if $InvalidKeyCount > 0;

	# Because this would otherwise make no sense.
	FErr(1, __LINE__, "Key conflict with 'BatCrit' and 'BatLow'.")
		if $Laptop eq 'true' and $BatCrit >= $BatLow
}else{
	use File::Copy 'copy';

	if (-f $DefaultConfigFile){
		FileChk($DefaultConfigFile);
		copy($DefaultConfigFile, $ConfigFile)
			or FErr(1, __LINE__, "Failed to generate a configuration file.");

		printf("File '~/.config/$TFL::PROGNAME/config' generated -- reload me.\n");
		exit(0)
	}else{
		FErr(1, __LINE__, "File '/usr/share/$TFL::PROGNAME/config' not found.")
	}
}

if (@SkipIDs > 0){
	foreach (@SkipIDs){
		FErr(1, __LINE__, "Invalid alert ID -- see: $TFL::PROGNAME -h")
			unless /^[0-9]{4}$/
	}
}

@Installed = sort(ParseDpkgStatus('installokinstalled'))
	if @UnwantedPKGs > 0;

@NotPurged = sort(ParseDpkgStatus('deinstallokconfig-files'))
	if $PurgeChk eq 'true';

#---------------------------------------------------------------------LSB Check

unless ($IsUbuntu eq 'true'){
	my $OSRelease = '/etc/os-release';

	FileChk($OSRelease);
	open(my $FH, '<', $OSRelease);

	my ($LSB, $Found);
	while (<$FH>){
		chomp();
		next if /(^$|^#)/;
		next unless $_ eq 'ID=ubuntu';

		$Found = 'true';

		last
	}

	close($FH);

	FErr(1, __LINE__, "Your distribution is not supported.")
		unless $Found eq 'true'
}

#-------------------------------------------------------------Querying an Alert

QueryAlert(0) if $Query eq 'true';

#-------------------------------------------------------------Kernel Parameters

if ($KernParams eq 'true'){
	my ($Value, $AlertID, $GoodValue, $Path, $ShowKey);

	foreach ( # [ALERT_ID] [DESIRED_VALUE] [KEY_PATH]
		'0913:1:/proc/sys/kernel/ctrl-alt-del',
		'1090:5:/proc/sys/net/ipv4/tcp_syn_retries',
		'1211:0:/proc/sys/net/ipv4/conf/all/accept_redirects',
		'1291:0:/proc/sys/net/ipv6/conf/default/accept_source_route',
		'1443:1:/proc/sys/kernel/yama/ptrace_scope',
		'1491:10:/proc/sys/vm/swappiness',
		'1821:1:/proc/sys/net/ipv4/conf/default/rp_filter',
		'2125:2048:/proc/sys/net/ipv4/tcp_max_syn_backlog',
		'2529:0:/proc/sys/net/ipv4/conf/default/send_redirects',
		'2847:1:/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses',
		'2916:0:/proc/sys/net/ipv6/conf/all/accept_redirects',
		'5434:1:/proc/sys/net/ipv4/icmp_echo_ignore_all',
		'5668:2:/proc/sys/net/ipv4/tcp_synack_retries',
		'6279:0:/proc/sys/net/ipv4/conf/default/accept_source_route',
		'6576:0:/proc/sys/net/ipv4/conf/all/accept_source_route',
		'7512:1:/proc/sys/net/ipv4/conf/all/rp_filter',
		'7536:0:/proc/sys/kernel/sysrq',
		'8560:2:/proc/sys/kernel/kptr_restrict',
		'8852:1:/proc/sys/net/ipv4/conf/all/log_martians',
		'8963:0:/proc/sys/net/ipv6/conf/all/accept_source_route',
		'9191:0:/proc/sys/net/ipv4/conf/all/send_redirects',
		'9222:1:/proc/sys/net/ipv4/tcp_syncookies',
		'9623:1:/proc/sys/kernel/dmesg_restrict',
		'9998:1:/proc/sys/fs/protected_symlinks',
		'9999:1:/proc/sys/fs/protected_hardlinks'
	){
		($AlertID, $GoodValue, $Path) = split(':');
		$ShowKey = $Path =~ tr/\//./r =~ s/\.proc\.sys\.//r;

		next if grep({$_ eq $ShowKey} @SkipKP);

		Info("Checking '$ShowKey' parameter.");

		if (-f $Path){
			unless (-r $Path){
				# Some parameters are more locked down than others.
				FErr(0, __LINE__, "Denied access to '$ShowKey' parameter.");
				next
			}elsif (-B -s $Path){
				FErr(0, __LINE__, "Unable to determine '$ShowKey' parameter.");
				next
			}

			open(my $FH, '<', $Path);
			chomp($Value = <$FH>);
			close($FH)
		}else{
			Info("Parameter '$ShowKey' unavailable.");

			next
		}

		Info("Parameter '$ShowKey' is '$Value'.");

		Alert(
			$AlertID,
			"Key '$ShowKey' assigned '$Value'.",
			"Recommended value is '$GoodValue'."
		) if $Value != $GoodValue
	}
}

#--------------------------------------------------PATH Permissions & Ownership

if ($PathPerms eq 'true'){
	if (length($ENV{'PATH'}) > 0){
		my @AlertPerms;
		foreach (split(':', $ENV{'PATH'})){
			Info("Looking in '$_' directory.");

			foreach (glob("$_/*")){
				#Info("Checking '$_' file.");

				my ($Mode, $Owner, $Group) = (stat($_))[2,4,5];
				$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

				#Info("File '$_' is '$Mode' and '$Owner:$Group'.");

				Alert(
					7869,
					"File '$_' permits '$Mode'.",
					"Recommended permissions are '755'."
				) unless $Mode <= 755;

				# These executables should not be owned by a standard user, nor
				# should they be in such a group. <1000 is for system users/groups.
				# A stricter test (make optional?) would be to flag all non-0s.
				# There are exceptions, however, such as the user having his or her
				# own `bin` directory in their `/home` directory.
				Alert(
					6005,
					"File '$_' owned by '$Owner'.",
					"Recommended owner is '0' ('root')."
				) if $Owner >= 1000;

				Alert(
					3597,
					"File '$_' in group '$Group'.",
					"Recommended group is '0' ('root')."
				) if $Group >= 1000
			}
		}
	}else{
		# This would have to be some seriously bizarre edge-case.
		Info("Missing prerequisites -- skipping 'PathPerms' key.")
	}
}

#-----------------------------------------------------Packages Yet to Be Purged

if ($PurgeChk eq 'true'){
	Info("Looking for old package remains.");

	Alert(
		6712,
		"Package '$_' wasn't purged.",
		"Suggested action is to purge the package."
	) foreach @NotPurged;

	Info('No packages were found unpurged.') if @NotPurged == 0
}

#-----------------------------------------------------------APT Security Tweaks

if ($HardAPT eq 'true'){
	if (DepChk(':', 'apt-config') == 0){
		my %Settings;
		foreach (`apt-config dump --format '%f=%v%n' 2> /dev/null`){
			chomp();
			next if /(^#|^$)/;

			my ($Key, $Value) = split('=');
			$Value = $Value =~ tr/"';//dr;

			unless (/=$/){
				Info("Key '$Key' is '$Value'.");
			}else{
				Info("Key '$Key' is empty.");
			}

			$Settings{$Key} = $Value
		}

		foreach ( # [TARGET_VALUE] [KEY]
			'6135|6131|false|APT::Get::AllowUnauthenticated',
			'6136|6132|false|Acquire::http::AllowRedirect',
			'6137|6133|false|APT::Install-Suggests',
			'6138|6134|false|APT::Install-Recommends'
		){
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next if grep({$_ eq $Key} @SkipAPT);

			unless (exists($Settings{$Key})){
				Alert(
					$AlertID1,
					"APT key '$Key' not assigned.",
					"Recommended action is to assign it '$Target'."
				)
			}elsif ($Settings{$Key} ne $Target){
				Alert(
					$AlertID2,
					"APT key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'HardAPT' key.")
	}
}

#--------------------------------------------------------------------SSH Client

if ($SSHClient eq 'true'){
	my $SSHDir = "$ENV{HOME}/.ssh";

	if (-d $SSHDir){
		FErr(1, __LINE__, "Directory '$SSHDir' unreadable.") unless -r $SSHDir;
		FErr(1, __LINE__, "Directory '$SSHDir' denies execution.") unless -x $SSHDir;

		my ($Mode, $Owner, $Group) = (stat($SSHDir))[2,4,5];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		Alert(
			5431,
			"Directory '$SSHDir' is mode '$Mode'.",
			"Recommended permissions are '700'."
		) unless $Mode == 700;

		Alert(
			5438,
			"Directory '$SSHDir' is owned by '$Owner'.",
			"Recommended owner is your UID ('$<')."
		) unless $Owner == $<;

		Alert(
			5439,
			"Directory '$SSHDir' is in group '$Group'.",
			"Recommended group is your GID ('$GID')."
		) unless $Group == $GID;
	}else{
		Info("Missing prerequisites -- skipping 'SSHClient' key.")
	}
}

#--------------------------------------------------------------------SSH Server

if ($SSHServer eq 'true'){
	if (-f $SSHDConfig){
		FErr(1, __LINE__, "File '$SSHDConfig' unreadable.")
			unless -r $SSHDConfig;

		# Without the `-s` flag, zero-size files get flagged as binary.
		FErr(1, __LINE__, "File '$SSHDConfig' is binary.")
			if -B -s $SSHDConfig;

		FileChk($SSHDConfig);
		open(my $FH, '<', $SSHDConfig);

		my %Settings;
		while (<$FH>){
			chomp();
			next if /(^#|^$)/;

			my ($Key, $Value) = split(' ');

			Info("Key '$Key' is '$Value'.");

			$Settings{$Key} = $Value
		}

		close($FH);

		foreach ( # [TARGET_VALUE] [KEY]
			'6998|6995|no|X11Forwarding',
			'6997|6994|no|PasswordAuthentication',
			'6996|6993|no|PermitEmptyPasswords',
		){
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next if grep({$_ eq $Key} @SkipAPT);

			unless (exists($Settings{$Key})){
				Alert(
					$AlertID1,
					"SSH daemon key '$Key' not assigned.",
					"Recommended action is to assign it '$Target'."
				)
			}elsif ($Settings{$Key} ne $Target){
				Alert(
					$AlertID1,
					"SSH daemon key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}

		# Ordinarily, you shouldn't use the commonplace `22` port.
		unless (exists($Settings{'Port'})){
			Alert(
				7541,
				"SSH daemon key 'Port' not assigned.",
				"Recommended action is NOT to assign it '22'."
			)
		}elsif ($Settings{'Port'} eq 22){
			Alert(
				6542,
				"SSH daemon key 'Port' assigned '$Settings{Port}'.",
				"Recommended value is one other than '22'."
			)
		}
	}else{
		Info("Missing prerequisites -- skipping 'SSHServer' key.")
	}
}

#---------------------------------------------------------Packages Best Avoided

if (@UnwantedPKGs > 0){
	foreach my $CurPKG (@UnwantedPKGs){
		Info("Looking for '$CurPKG' package.");

		Alert(
			5656,
			"Package(s) matching '$CurPKG' installed.",
			"Suggested action is to uninstall the package(s)."
		) if grep(/$CurPKG/, @Installed)
	}
}

#------------------------------------------------------------UFW Firewall Check

if ($Firewall eq 'true'){
	if (DepChk(':', 'systemctl', 'ufw') == 0){
		Info('Finding out if UFW unit is active.');

		chomp(my $Result = `systemctl is-active ufw 2> /dev/null`);
		unless ($Result eq 'active'){
			Alert(
				5541,
				'The UFW service is inactive.',
				"Recommended action is to enable the service, ASAP."
			)
		}else{
			Info('Active UFW service detected.')
		}
	}else{
		Info("Missing prerequisites -- skipping 'Firewall' key.")
	}
}

#----------------------------------------------------------------SystemD Tweaks

if ($SystemD eq 'true'){
	my $SDConfig = '/etc/systemd/system.conf';

	if (-f $SDConfig){
		FileChk($SDConfig);
		open(my $FH, '<', $SDConfig);

		my %Settings;
		while (<$FH>){
			chomp();
			next if /(^#|^$|^\[Manager\]$)/;

			my ($Key, $Value) = split('=');

			Info("Key '$Key' is '$Value'.");

			$Settings{$Key} = $Value
		}

		close($FH);

		foreach ( # [TARGET_VALUE] [KEY]
			'1411|1415|1024|DefaultLimitNPROC',
			'1412|1416|1024|DefaultLimitNOFILE',
			'1413|1417|no|CrashShell',
			'1414|1418|no|DumpCore'
		){
			my ($AlertID1, $AlertID2, $Target, $Key) = split('\|');

			next if grep({$_ eq $Key} @SkipSysD);

			unless (exists($Settings{$Key})){
				Alert(
					$AlertID1,
					"SystemD key '$Key' not assigned.",
					"Recommended action is to assign it '$Target'."
				)
			}elsif ($Settings{$Key} ne $Target){
				Alert(
					$AlertID2,
					"SystemD key '$Key' assigned '$Settings{$Key}'.",
					"Recommended value is '$Target'."
				)
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'SystemD' key.")
	}
}

#----------------------------------------------------------------Kernel Modules

if ($KernMods eq 'true'){
	my $ProcMods = '/proc/modules';

	if (-f $ProcMods){
		FileChk($ProcMods);
		open(my $FH, '<', $ProcMods);

		my @Modules;
		while (<$FH>){
			chomp();

			my @Line = split(' ');

			push(@Modules, $Line[0])
		}

		close($FH);

		foreach (
			'1274|mei',
			'1275|mei_me',
			'1276|mei_wtk',
			'7416|joydev',
			'8471|psmouse'
		){
			my ($AlertID, $Module) = split('\|');

			if (grep({$_ eq $Module} @Modules)){
				unless (grep({$_ eq $Module} @SkipKMs)){
					Info("Module '$Module' found but ignored.");
					next # <-- Skipping the below alert.
				}

				Alert(
					$AlertID,
					"Module '$Module' discovered and live.",
					"Recommended action is to blacklist the module."
				)
			}else{
				Info("Module '$Module' not found.")
			}
		}

		foreach my $Mod (@CustomKMs){
			Alert(
				8189,
				"Module '$Mod' discovered and live.",
				"Recommended action is to blacklist the module."
			) if grep({$_ eq $Mod} @Modules)
		}
	}else{
		Info("Missing prerequisites -- skipping 'KernMods' key.")
	}
}

#--------------------------------------------------------Check Filesystem Sizes

if ($DiskSpace eq 'true'){
	my $MountFile = '/proc/mounts';

	if (-f $MountFile){
		use Filesys::DiskSpace 'df';

		FileChk($MountFile);
		open(my $FH, '<', $MountFile);

		my (@MountPoints, $Base, $Used, $Free, $Size, $Mount, $Perc);
		while (<$FH>){
			chomp(my @Arr = split(' '));

			# Using this REGEX over just '^/' avoids statfs errors.
			if ($Arr[0] =~ '^/dev/(sd|hd|fd)[[:alpha:]]+[0-9]+$'){
				# Avoids `not a directory` error, for EFI setups.
				next if $Arr[1] eq '/boot/efi';

				Info("Looking at '$Arr[0]' partition.");

				$Mount = $Arr[1] =~ s/\\040/ /gr;
				($Used, $Free) = (df($Mount))[2,3] or next;
				$Used = $Used * 1024;
				$Free = $Free * 1024;
				$Size = $Free + $Used;
				$Perc = int(($Used / $Size) * 100);

				if ($Perc >= $DSLimit){
					Alert(4612,
						"Partition '$Arr[0]' is $Perc% full.",
						"Recommended action is to clear out junk."
					)
				}else{
					Info("Partition '$Arr[0]' is using $Perc% of space.");
				}
			}
		}

		close($FH);
	}else{
		Info("Missing prerequisites -- skipping 'DiskSpace' key.")
	}
}

#----------------------Specific File & Directory Permissions, Group & Ownership

if ($DirPerms eq 'true'){
	foreach ( # [ALERTID] [MODE] [UID] [GID]
		"5440:700:$<:$GID:/home/$ENV{USER}",
		'5436:700:0:0:/boot',
		'5446:700:0:0:/root'
	){
		my ($AlertID, $TargetMode, $TargetUID, $TargetGID, $Path) = split(':');

		next unless -d $Path;

		Info("Looking at '$Path' directory.");

		my ($Mode, $Owner, $Group) = (stat($Path))[2,4,5];
		$Mode = substr(sprintf('%04o', $Mode & 07777), 1);

		Alert(
			$AlertID,
			"Directory '$Path' is mode '$Mode'.",
			"Recommended permissions are '$TargetMode'."
		) unless $Mode == $TargetMode;

		Alert(
			$AlertID,
			"Directory '$Path' is owned by '$Owner'.",
			"Recommended owner is your UID ('$TargetUID')."
		) unless $Owner == $TargetUID;

		Alert(
			$AlertID,
			"Directory '$Path' is in group '$Group'.",
			"Recommended group is your GID ('$TargetGID')."
		) unless $Group == $TargetGID;
	}
}

#-----------------------------------------------------------------Laptop Checks

if ($Laptop eq 'true'){
	my $BatFile = '/sys/class/power_supply/BAT1/capacity';

	if (-f $BatFile){
		FileChk($BatFile);
		open(my $FH, '<', $BatFile);
		chomp(my $BatPerc = <$FH>);
		close($FH);

		my $Battery = $BatFile =~ s/.*\/BAT([0-9]+)\/capacity$/$1/r;

		if ($BatPerc <= $BatCrit){
			Alert(
				2850,
				"Battery #$Battery is at $BatPerc% capacity.",
				"Save your work and shut down the computer."
			)
		}elsif ($BatPerc <= $BatLow){
			Alert(
				2849,
				"Battery #$Battery is at $BatPerc% capacity.",
				"Recommended action is to charge the battery."
			)
		}else{
			Info("Battery #$Battery still has $BatPerc% left.")
		}
	}else{
		Info("Missing prerequisites -- skipping 'Laptop' key.")
	}
}

#------------------------------------------------------CPU Marked as Vulnerable

if ($ProcVuln eq 'true'){
	if (-d $VulnDir){
		FErr(1, __LINE__, "Directory '$VulnDir' unreadable.")
			unless -r $VulnDir;

		FErr(1, __LINE__, "Unable to open '$VulnDir' directory.")
			unless -x $VulnDir;

		foreach (glob("$VulnDir/*")){
			next unless -f;

			my $Vuln = ($_ =~ m{(?:.*/)(.*)})[0];

			Info("Checking CPU for vulnerability to $Vuln.");

			FileChk($_);
			open(my $FH, '<', $_);
			chomp(my $Data = <$FH>);
			close($FH);

			if ($Data =~ /Vulnerable/i){
				Alert(
					4811,
					"CPU marked as vulnerable to $Vuln.",
					"Don't panic -- refer to: $TFL::PROGNAME -Q 4811"
				)
			}elsif ($Data =~ /Not affected/i){
				Info("Unaffected by $Vuln vulnerability.")
			}elsif ($Data =~ /Mitigation/i){
				Info("Vulnerability $Vuln mitigated.")
			}else{
				Alert(
					4812,
					"Unrecognised vulnerability status to $Vuln.",
					"Don't panic -- refer to: $TFL::PROGNAME -Q 4812"
				)
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'ProcVuln' key.")
	}
}

#--------------------------------------------------------Mount Options for HOME

if ($MountHome eq 'true'){
	my $MountFile = '/proc/mounts';

	if (-f $MountFile){
		FileChk($MountFile);
		open(my $FH, '<', $MountFile);

		my ($Device, $Options);
		while (<$FH>){
			chomp(my @Arr = split(' '));

			# Using this REGEX over just '^/' avoids statfs errors.
			if ($Arr[1] eq '/home'){
				($Device, $Options) = @Arr[0,3];
				last
			}
		}

		close($FH);

		if (length($Device) > 0){
			Info("Mountpoint '/home' points to '$Device'.");

			my @OptArr = split(',', $Options);

			foreach (
				'1356,noexec',
				'1357,nodev',
				'1358,nosuid'
			){
				my ($AlertID, $Option) = split(',');

				if (grep({$_ eq $Option} @SkipMountOpts)){
					Info("Module '$Option' found but ignored.");
					next # <-- Skipping the below alert.
				}

				if (grep({$_ eq $Option} @OptArr)){
					Info("Mount option '$Option' for '/home' is set.")
				}else{
					Alert($AlertID,
						"Missing mount option '$Option' for '/home'.",
						"Please refer to: $TFL::PROGNAME -Q $AlertID"
					)
				}
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'MountHome' key.")
	}
}

#---------------------------------------------------------CPU Core Temperatures

# There are several ways to get the system's CPU temperature(s), without
# dragging in another program, but for now, I'll program for this particular
# method, adding additional ones as issues are reported.
if ($CPUTemp eq 'true'){
	my $Dir = '/sys/devices/platform/coretemp.0/hwmon/hwmon3';

	if (-d $Dir){
		FErr(1, __LINE__, "Directory '$Dir' unreadable.") unless -r $Dir;
		FErr(1, __LINE__, "Directory '$Dir' denies execution.") unless -x $Dir;

		# Gather a hash of (only) the core temperatures.
		my (%TempData, $Temp);
		foreach (glob("$Dir/temp*")){
			next unless -f and m{/temp[0-9]+_(input|label)$};

			FileChk($_);
			open(my $FH, '<', $_);
			chomp(my $Data = <$FH>);
			close($FH);

			# The files are ordered from input to label, so we need to process
			# it backwards, otherwise the output would be borked.
			if (/_input$/){
				$Temp = $Data
			}elsif (/_label$/){
				$TempData{$Data} = $Temp
			}
		}

		# Ensure we have the right suffix for 1'st', 2'nd', 3'rd', and N'th'.
		sub Suffix{ # Usage: [INT]
			my $Num = $_[0] + 1;
			return("${Num}st") if $Num =~ '1$';
			return("${Num}nd") if $Num =~ '2$';
			return("${Num}rd") if $Num =~ '3$';
			return("${Num}th")
		}

		# Begin checking on each of the core temperatures, per the above hash.
		foreach (sort(keys(%TempData))){
			next unless /^Core [0-9]+$/;

			# Initially, this value is in Celsius (unconfirmed).
			my $TempInt = CelsFahr(
				$TempScale, substr($TempData{$_}, 0, length($TempData{$_}) - 3)
			);

			my $TempStr = "$TempIntÂ°$TempScale";
			my $CoreInt = (m{(?:.* )(.*)})[0];
			my $CoreStr = Suffix($CoreInt);
			if ($TempInt >= $CoreTempCrit){
				Alert(
					6237,
					"CPU's $CoreStr core critical at $TempStr.",
					"Suggested action is to improve system cooling."
				)
			}else{
				Info("CPU core #$CoreInt stable at $TempStr.")
			}
		}
	}else{
		Info("Missing prerequisites -- skipping 'CPUTemp' key.")
	}
}

#----------------------------------------------------------APT Cache Disk Usage

if ($AptCache eq 'true'){
	my $Dir = '/var/cache/apt/archives';

	if (-d $Dir){
		use Number::Bytes::Human 'format_bytes';

		# Ignoring `partial` directory, as it often needs root access to use.
		# The same goes for files like `lock`, as they're irrelevant here.
		my ($FileCount, $Size);
		foreach (glob("$Dir/*.deb")){
			$Size += -s;
			$FileCount++
		}

		if ($Size > 0){
			my $Human = format_bytes($Size);
			if ($Size / 1024 / 1024 >= $AptCacheMBLimit){
				if (DepChk(':', 'sudo') == 0){
					Alert(
						9708,
						"Found $FileCount cached Debian packages, totalling $Human.",
						"Suggested action is to run: sudo apt-get clean"
					);
				}else{
					Alert(
						9708,
						"Found $FileCount cached Debian packages, totalling $Human.",
						"Suggested action is to, as root, run: apt-get clean"
					);
				}
			}else{
				Info("Cached Debian packages take up only $Human.");
			}
		}else{
			Info("Found no cached Debian packages.");
		}
	}else{
		Info("Missing prerequisites -- skipping 'AptCache' key.")
	}
}

#-----------------------------------------------------------------------LightDM

if ($LightDM eq 'true'){
	if (DepChk(':', 'lightdm') == 0){
		my $Config = '/etc/lightdm/lightdm.conf.d/50-no-guest.conf';

		if (-f $Config){
			FileChk($Config);
			open(my $FH, '<', $Config);

			my $AllowGuest;
			while (<$FH>){
				chomp();

				# Correct, at least in Ubuntu 16.04.6 base.
				if (/^\[SeatDefaults\] allow-guest=true$/){
					$AllowGuest = 'true';
					last
				}
			}

			close($FH);

			if ($AllowGuest eq 'true'){
				Alert(
					9188,
					'Guest logins are allowed with LightDM.',
					'Recommended action is to disable guest logins.'
				);
			}else{
				Info('LightDM does not permit guest logins.')
			}
		}else{
			FErr(0, __LINE__, "File '$Config' not found.")
		}
	}else{
		Info("Missing prerequisites -- skipping 'LightDM' key.")
	}
}

#----------------------------------------------------------RootKits, Worms, etc

if ($RootKits eq 'true'){
	# Based on information from this GitHub repository:
	#
	#   https://github.com/ossec/ossec-hids
	#
	foreach (
		'7125|/tmp/{mcliZokhb,mclzaKmfa}|Bash door|infection',
		'7126|/dev/.shit/red.tgz,/usr/{lib/libt,bin/adore}|Adore Worm|worm',
		'7127|/usr/bin/{soucemask,sourcemask}|TRK Rootkit|rootkit',
		'7128|/tmp/.../{a,r}|55808.A Worm|worm',
		'7129|/usr/{lib,bin}/volc|Volc Rootkit|rootkit',
		'7129|/{lib/security/.config,usr/bin/sia,etc/ld.so.hash}|Illogic Rootkit|rootkit',
		'7130|/{usr/src/.puta,usr/info/.t0rn,lib/ldlib.tk,etc/ttyhash,sbin/xlogin}|t0rn Rootkit|rootkit',
		'7131|/{bin/{rtty,squit},sbin/pback,proc/kset,usr/src/linux/modules/{autod.o,soundx.o}}|RK17|infection',
		'7132|/usr/{lib/ldlib{[pn]s,login}.so,src/.poop,tmp/ramen.tgz,etc/xinetd.d/asp}|Ramen Worm|worm',
		'7133|/dev/cuc|Sadmind/IIS Worm|worm',
		'7134|/{lib/defs,usr/lib/libpikapp.a}|Monkit|infection',
		'7134|/{usr/bin/{kr4p,n3tstat,chsh2,slice2},etc/rc.d/rsha}|RSHA|infection',
		'7135|/{bin/home,sbin/home,usr/sbin/in.slogind}|ShitC|worm',
	){
		my ($AlertID, $Infection, $Name, $Type) = split('\|');

		my ($Alert, $Info);
		foreach (glob($Infection)){
			next if grep({$_ eq $Name} @SkipRKs);

			if (-e $_){
				Alert(
					$AlertID,
					"Potential '$Name' $Type detected!",
					'Seek immediate medical attention.'
				) unless $Alert eq 'true';

				$Alert = 'true'
			}else{
				Info("No sign of '$Name' found.")
					unless $Info eq 'true' or $Alert eq 'true';

				$Info = 'true'
			}
		}
	}
}

#------------------------------------------------------------------User's Cache

if ($HomeCache eq 'true'){
	my $CacheDir = "$ENV{HOME}/.cache";

	if (-d $CacheDir){
		my $Size = GetDirSize($CacheDir);
		if ($Size > 0){
			use POSIX 'ceil';

			my $SizeMB = ceil($Size / 1024 / 1024);
			if ($SizeMB >= $HomeCacheMBLimit){
				Alert(
					7619,
					"User '$ENV{USER}' has a cache total of ${SizeMB}M.",
					"Suggested action is to remove unneeded files."
				)
			}else{
				use Number::Bytes::Human 'format_bytes';

				my $Human = format_bytes($Size);

				Info("User '$ENV{USER}' caches only $Human.")
			}
		}else{
			Info("User '$ENV{USER}' directory '~/.cache' is empty.")
		}
	}else{
		Info("Missing prerequisites -- skipping 'HomeCache' key.")
	}
}

#-------------------------------------------------------------User's Thumbnails

if ($Thumbnails eq 'true'){
	my $ThumbDir = "$ENV{HOME}/.thumbnails";

	if (-d $ThumbDir){
		my $Size = GetDirSize($ThumbDir);
		if ($Size > 0){
			use POSIX 'ceil';

			my $SizeMB = ceil($Size / 1024 / 1024);
			if ($SizeMB >= $ThumbsMBLimit){
				Alert(
					7620,
					"User '$ENV{USER}' has a cache total of ${SizeMB}M.",
					"Suggested action is to remove unneeded files."
				)
			}else{
				use Number::Bytes::Human 'format_bytes';

				my $Human = format_bytes($Size);

				Info("User '$ENV{USER}' thumbnails take up only $Human.")
			}
		}else{
			Info("User '$ENV{USER}' directory '~/.thumbnails' is empty.")
		}
	}else{
		Info("Missing prerequisites -- skipping 'Thumbnails' key.")
	}
}

#------------------------------------------------------------------------Finish

my $Word;
$AlertCount > 0 ? $Word = 'times' : $Word = 'time';
print("Alerted $AlertCount $Word.\n") if $AlertCount > 0;
