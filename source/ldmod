#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/ldmod
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/ldmod
# Started On        - Sat 11 Jan 14:33:58 GMT 2020
# Last Change       - Mon 11 Apr 01:38:36 BST 2022
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# Perl rewrite of and expansion on an old TFL shell function called `lsmodd()`.
# LDMod stands for 'List and Describe Modules'.
#
# Dependencies:
#
#   kmod (>= 22-1)
#   perl (>= 5.10)
#------------------------------------------------------------------------------

use feature 'say';
use strict;
use warnings;

no warnings 'uninitialized';

use constant VERSION => '2022-04-11';
use constant PROGRAM => 'ldmod';

sub Usage() {
	print(qq{Usage: ${\PROGRAM} [OPTS] [REGEX]

		  -h, --help               - Display this help information.
		  -v, --version            - Output the version datestamp.
		  -a, --show-all           - Don't omit undescribed modules.
		  -i, --ignore-case        - Case-insensitive REGEX search.

		  Where REGEX is a regular expression string to use in order
		  to filter modules by their names, not their descriptions.
	} =~ tr/\t//dr)
}

use constant PROC_MOD => '/proc/modules';

my ($DoCase, $ShowAll, $LiveOnly);

while (defined($ARGV[0])) {
	if ($ARGV[0] =~ '^(--help|-h|-\?)$') {
		Usage(); exit(0)
	} elsif ($ARGV[0] =~ '^(--version|-v)$') {
		say($CurVer); exit(0)
	} elsif ($ARGV[0] =~ '^(--ignore-case|-i)$') {
		$DoCase = 'i'
	} elsif ($ARGV[0] =~ '^(--show-all|-a)$') {
		$ShowAll = 1
	} elsif ($ARGV[0] =~ '^-') {
		die("Err: Incorrect option(s) specified.\n")
	} else {
		last()
	}

	shift()
}

my $RegexStr = $ARGV[0] if defined($ARGV[0]);

if (@ARGV) {
	die("Too many arguments -- see: ${\PROGRAM} -h")
} elsif ($DoCase eq 'i' and not @ARGV) {
	die("Option '--ignore-case|-i' used, but no REGEX provided.")
} elsif (not -f -r PROC_MOD) {
	die(1, "File '${\PROC_MOD}' missing or inaccessible.")
}

sub FetchMods($) {
	open(my $FH, '<', $_[0]) or die("$!");

	my @Mods;
	while (<$FH>) {
		chomp(my @LineArr = split());

		push(@Mods, $LineArr[0])
	}

	close($FH) or die("$!");

	return(@Mods);
}

foreach (sort({$a cmp $b} FetchMods($ProcMod))) {
	# Look for user-provided REGEX in line, if one is given.
	if (defined($RegexStr)) {
		if ($DoCase eq 'i') {
			next() unless grep(m/$RegexStr/i, $_)
		} else {
			next() unless grep(m/$RegexStr/, $_)
		}
	}

	# This is hopefully just a temporary measure.
	chomp(my $Desc = `modinfo -d "$_" 2> /dev/null` || '?');

	if ($ShowAll) {
		say("$_ - $Desc")
	} else {
		say("$_ - $Desc") unless $Desc eq '?'
	}
}
