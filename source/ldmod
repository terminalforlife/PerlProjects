#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/ldmod
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/ldmod
# Started On        - Sat 11 Jan 14:33:58 GMT 2020
# Last Change       - Sat 16 Apr 00:22:50 BST 2022
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# Perl rewrite of and expansion on an old TFL shell function called `lsmodd()`.
# LDMod stands for 'List and Describe Modules'.
#
# Dependencies:
#
#   kmod (>= 22-1)
#   perl (>= 5.26.1)
#------------------------------------------------------------------------------

use feature 'say';
use strict;
use warnings;

no warnings 'uninitialized';

use constant VERSION => '2022-04-16';
use constant PROGRAM => 'ldmod';

sub Usage() {
	print(qq{Usage: ${\PROGRAM} [OPTS] [REGEX]

		  -h, --help               - Display this help information.
		  -v, --version            - Output the version datestamp.
		  -C, --no-color           - Disable ANSI color escape sequences.
		  -a, --show-all           - Don't omit undescribed modules.
		  -i, --ignore-case        - Case-insensitive REGEX search.

		  Where REGEX is a regular expression string to use in order
		  to filter modules by their names, not their descriptions.
	} =~ tr/\t//dr)
}

use constant PROC_MOD => '/proc/modules';

my ($DoCase, $ShowAll, $LiveOnly);

my $C_Grey = "\e[37m";
my $C_Red = "\e[91m";
my $C_Reset = "\e[0m";

while (defined($ARGV[0])) {
	if ($ARGV[0] =~ '^(--help|-h|-\?)$') {
		Usage(); exit(0)
	} elsif ($ARGV[0] =~ '^(--version|-v)$') {
		say(VERSION); exit(0)
	} elsif ($ARGV[0] =~ '^(--no-color|-C)$') {
		$C_Grey = '';
		$C_Red = '';
		$C_Reset = '';
	} elsif ($ARGV[0] =~ '^(--ignore-case|-i)$') {
		$DoCase = 'i'
	} elsif ($ARGV[0] =~ '^(--show-all|-a)$') {
		$ShowAll = 1
	} elsif ($ARGV[0] =~ '^-') {
		die("Err: Incorrect option(s) specified.\n")
	} else {
		last()
	}

	shift()
}

my $RegexStr = $ARGV[0] if defined($ARGV[0]);

if (@ARGV > 1) {
	die("Too many arguments -- see: ${\PROGRAM} -h")
} elsif ($DoCase eq 'i' and not @ARGV) {
	die("Option '--ignore-case|-i' used, but no REGEX provided.")
} elsif (not -f -r PROC_MOD) {
	die(1, "File '${\PROC_MOD}' missing or inaccessible.")
}

open(my $FH, '<', PROC_MOD) or die("$!");

my %Modules;
while (<$FH>) {
	chomp(my ($Module, $Refs) = (split())[0,2]);
	$Modules{$Module} = $Refs
}

close($FH) or die("$!");

foreach (sort({$a cmp $b} keys(%Modules))) {
	# Look for user-provided REGEX in line, if one is given.
	if (defined($RegexStr)) {
		if ($DoCase eq 'i') {
			next() unless grep(m/$RegexStr/i, $_)
		} else {
			next() unless grep(m/$RegexStr/, $_)
		}
	}

	my $Len = length($Modules{$_});
	our $MaxLen = $Len if $Len > $MaxLen;

	# This is hopefully just a temporary measure.
	chomp(my $Desc = `modinfo -d "$_" 2> /dev/null`);
	$Desc = "${C_Red}[Unknown]$C_Reset" unless length($Desc);

	printf(
		"$C_Grey%*d$C_Reset %s $C_Grey- %s$C_Reset\n",
		$MaxLen, $Modules{$_}, $_, $Desc
	)
}
