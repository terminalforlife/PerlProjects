#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/i3-workspaces
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/i3-workspaces/i3-workspaces
# Started On        - Fri 21 Jan 18:01:01 GMT 2022
# Last Change       - Sat 22 Jan 19:12:15 GMT 2022
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# Features:
#
#TODO: Consider colorizing True (green) and false (red) values.
#
# Bugs:
#
# N/A
#
# Dependencies:
#
#   libanyevent-i3-perl (>= 0.17-1)
#   perl (>= 5.22.1-9)
#------------------------------------------------------------------------------

require AnyEvent::I3;

use v5.22.1;
use strict;
use warnings;
use AnyEvent::I3 'i3', 'TYPE_GET_WORKSPACES';

no warnings 'uninitialized';

my $CurVer = '2022-01-22';
my $Progrm = 'i3-workspaces';

sub Usage {
	print(qq{Usage: $Progrm [OPTS] [NR PROP]

		  -h, --help               - Display this help information.
		  -v, --version            - Output the version datestamp.
		  --only-focused           - Filter out focused workspaces.
		  --only-visible           - Filter out visible workspaces.
		  -C, --no-color           - Disable ANSI color escape sequences.
		  -q, --quotes             - Quote protect NAME and OUTPUT fields.

		  It's also possible to output only property PROP of workspace NR.
		  Valid PROPs are name, visible, output, urgent, and focused.
	} =~ tr/\t//dr)
}

sub Err($;$) {
	printf(STDERR "Err: %s\n", $_[1]);
	exit($_[0]) if $_[0] > 0
}

my @Valids = ('name', 'visible', 'output', 'urgent', 'focused');
my $Grey = "\e[2;37m";
my $Reset = "\e[0m";
my $Quote = '';
my $GetValue = 0;
my $OnlyVisible = 0;
my $OnlyFocused = 0;

while (defined($ARGV[0])) {
	if ($ARGV[0] =~ '^(--help|-h)$') {
		Usage(); exit(0)
	} elsif ($ARGV[0] =~ '^(--version|-v)$') {
		print("$CurVer\n"); exit(0)
	} elsif ($ARGV[0] =~ '^(--version|-v)$') {
		print("$CurVer\n"); exit(0)
	} elsif ($ARGV[0] =~ '^(--no-color|-C)$') {
		$Grey = '';
		$Reset = ''
	} elsif ($ARGV[0] =~ '^(--quotes|-q)$') {
		$Quote = "'"
	} elsif ($ARGV[0] eq '--only-visible') {
		$OnlyVisible = 1
	} elsif ($ARGV[0] eq '--only-focused') {
		$OnlyFocused = 1
	} elsif ($ARGV[0] =~ '^-') {
		die("Incorrect option(s) specified")
	} else {
		last
	}

	shift()
}

Err(1, "Argument '$ARGV[2]' invalid.") if scalar(@ARGV) > 2;

my $Arg_Nr = lc($ARGV[0]);
my $Arg_Key = lc($ARGV[1]);
if (defined($ARGV[0]) or defined($ARGV[1])) {
	Err(1, 'Unpaired NR and PROP arguments.')
		unless defined($Arg_Nr) and defined($Arg_Key);

	Err(1, 'Unknown workspace property.')
		unless grep({$_ eq $ARGV[1]} @Valids);

	$GetValue = 1
}

my $i3 = i3();
$i3->connect()->recv() or Err(1, 'Failed to connect to i3-wm.');
my $JSON = $i3->message(TYPE_GET_WORKSPACES)->recv();

my $Nr_LenMax = 2;
my $ID_LenMax = 2;
my $Name_LenMax = 4;
my $Visible_LenMax = 7;
my $Output_LenMax = 6;
my $Urgent_LenMax = 6;
my $Focused_LenMax = 7;

#----------------------------------------------------------------Main Functions

sub Boolean($) {
	if ($_[0] == 0) {
		return("False")
	} elsif ($_[0] == 1) {
		return("True")
	}
}

# Usage: LenChk(LEN, MAX_LEN)
sub LenChk($;$) {
	if ($_[0] > $_[1]) {
		return($_[0])
	} else {
		return($_[1])
	}
}

#----------------------------------------------------------Fetch Data from JSON

my %Keys;
foreach (@{$JSON}) {
	my $Nr = $_->{num};
	my $Name = "$Quote$_->{name}$Quote";
	my $Output = "$Quote$_->{output}$Quote";
	my $Visible = Boolean($_->{visible});
	my $Urgent = Boolean($_->{urgent});
	my $Focused = Boolean($_->{focused});

	next() if $OnlyVisible and $Visible ne 'True';
	next() if $OnlyFocused and $Focused ne 'True';

	# Determine the correct width of the columns.
	$Nr_LenMax = LenChk(length($Nr), $Nr_LenMax);
	$Name_LenMax = LenChk(length($Name), $Name_LenMax);
	$Output_LenMax = LenChk(length($Output), $Output_LenMax);
	$Visible_LenMax = LenChk(length($Visible), $Visible_LenMax);
	$Urgent_LenMax = LenChk(length($Urgent), $Urgent_LenMax);
	$Focused_LenMax = LenChk(length($Focused), $Focused_LenMax);

	$Keys{$Nr} = {
		'name' => $Name,
		'output' => $Output,
		'visible' => $Visible,
		'urgent' => $Urgent,
		'focused' => $Focused
	}
}

#------------------------------------------------------------------Display Data

if ($GetValue) {
	Err(1, "Workspace #$Arg_Nr not found.")
		unless grep({$_ eq $Arg_Nr} keys(%Keys));

	Err(1, "Workspace '$Arg_Nr' invalid.")
		unless $Arg_Nr =~ /^[[:digit:]]+$/;

	print("$Keys{$Arg_Nr}{$Arg_Key}\n");
	exit(0)
}

printf(
	"$Grey%-*s %-*s %-*s %-*s %-*s %*s$Reset\n", $Nr_LenMax, 'NR',
	$Name_LenMax, 'NAME', $Output_LenMax, 'OUTPUT', $Visible_LenMax, 'VISIBLE',
	$Urgent_LenMax, 'URGENT', $Focused_LenMax, 'FOCUSED'
);

foreach my $Nr (sort({$a <=> $b} keys(%Keys))) {
	printf(
		"%-*d %-*s %-*s %-*s %-*s %*s\n", $Nr_LenMax, $Nr, $Name_LenMax,
		$Keys{$Nr}->{name}, $Output_LenMax, $Keys{$Nr}->{output},
		$Visible_LenMax, $Keys{$Nr}->{visible}, $Urgent_LenMax,
		$Keys{$Nr}->{urgent}, $Focused_LenMax, $Keys{$Nr}->{focused}
	)
}
