#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/tagged
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/tagged/tagged
# Started On        - Mon 10 Jan 12:34:57 GMT 2022
# Last Change       - Mon 10 Jan 23:31:57 GMT 2022
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# Features:
#
#TODO: Colorize the basename of paths to make it stand out.
#
# Bugs:
#
# N/A
#
# Dependencies:
#
#   git (>= 2.17.1)
#   perl (>= 5.22.1)
#------------------------------------------------------------------------------

use v5.22.1;
use strict;
use warnings;

my $CurVer = '2022-01-10';
my $Progrm = ($0 =~ m{(?:.*/)?([^/].*)})[0];

sub Usage {
	print(qq{Usage: $Progrm [OPTS] [FILE_1 [FILE_2] ...]

		  -h, --help               - Display this help information.
		  -v, --version            - Output the version datestamp.
		  -C, --no-color           - Disable ANSI color escape sequences.
		  -b, --basenames          - Show only the basename for each path.
		  -o, --only-total         - Display only the total number of commits.
		  -r, --reverse            - Show least number of commits first.
		  -t, --total              - Display the total number of commits.
		  -z, --zero               - Include files not part of any commits.

		  The CWD must be within the repository you're scanning.
	} =~ tr/\t//dr)
}

sub Err($;$) {
	printf(STDERR "Err: %s\n", $_[1]);
	$_[0] > 0 and exit($_[0])
}

my $Grey = "\e[37m";
my $Reset = "\e[0m";

my $Basenames = 0;
my $Color = 1;
my $OnlyTotal = 0;
my $Reverse = 0;
my $Total = 0;
my $Zero = 0;

my $ArgOnlyTotal;
while (defined($ARGV[0])) {
	if ($ARGV[0] =~ '^(--help|-h)$') {
		Usage(); exit(0)
	} elsif ($ARGV[0] =~ '^(--version|-v)$') {
		print("$CurVer\n"); exit(0)
	} elsif ($ARGV[0] =~ '^(--no-color|-C)$') {
		$Color = 0
	} elsif ($ARGV[0] =~ '^(--basenames|-b)$') {
		$Basenames = 1
	} elsif ($ARGV[0] =~ '^(--only-total|-o)$') {
		$ArgOnlyTotal = $ARGV[0];
		$OnlyTotal = 1
	} elsif ($ARGV[0] =~ '^(--reverse|-r)$') {
		$Reverse = 1
	} elsif ($ARGV[0] =~ '^(--total|-t)$') {
		$Total = 1
	} elsif ($ARGV[0] =~ '^(--zero|-z)$') {
		$Zero = 1
	} elsif ($ARGV[0] =~ '^-') {
		Err(1, "Incorrect option(s) specified.")
	} else {
		last()
	}

	shift()
}

if ($OnlyTotal and not $Total) {
	Err(1, "Option '$ArgOnlyTotal' missing its pair.")
} elsif (scalar(@ARGV) == 0) {
	Err(1, "No files given -- see: $Progrm --help")
}

unless ($Color) {
	$Grey = '';
	$Reset = ''
}

#------------------------------------------------------Check for git(1) in PATH

my $GitFound = 0;
foreach my $Dir (split(':', $ENV{PATH})) {
	next() unless -d $Dir;

	foreach my $File (glob("$Dir/*")) {
		next() unless -f $File;

		my $Basename = ($File =~ m{(?:.*/)?([^/].*)})[0];
		$GitFound = 1 unless $Basename eq 'git'
	}
}

Err(1, "Dependency 'git' not met.") unless $GitFound;

#-------------------------Use git(1) to Get the Number of Commits for Each File


my $LenMax = 0;
my (@Files, $Len);
my $TotalCommits = 0;
foreach my $File (@ARGV) {
	next() unless -f $File;

	my $Failed = 0;
	my $Commits = 0;
	foreach (`git rev-list HEAD -- "$File"`) {
		if (/^[[:alnum:]]{40}$/) {
			$Commits++
		} else {
			$Failed = 1;
			last()
		}
	}

	$TotalCommits += $Commits;
	if ($Zero || $Commits > 0) {
		push(@Files, "$Commits:$File")
	}

	$Len = length($Commits);
	$Len > $LenMax and $LenMax = $Len
}

#--------------------------------------------------Array Sorting & Data Display

if ($OnlyTotal) {
	print($TotalCommits)
} else {
	if ($Reverse) {
		@Files = sort({$a =~ s/:.*$//gr <=> $b =~ s/:.*$//gr} @Files)
	} else {
		@Files = sort({$b =~ s/:.*$//gr <=> $a =~ s/:.*$//gr} @Files)
	}

	foreach (@Files) {
		my $Commits = $_ =~ s/:.*$//gr;
		my $File = $_ = $_ =~ s/^.*://r;
		$File = ($File =~ m{(?:.*/)?([^/].*)})[0] if $Basenames;

		printf("%*d $Grey%s$Reset\n", $LenMax, $Commits, $File)
	}

	printf("\nTotal: %d\n", $TotalCommits) if $Total
}
